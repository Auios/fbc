{{fbdoc item="title" value="THREADCREATE"}}----
Starts a user-defined procedure in a separate execution thread

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Threadcreate** ( [[KeyPgByval byval]] //proc// [[KeyPgAs as]] [[KeyPgSub sub]] ( [[KeyPgByval byval]] [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] ), [[KeyPgByval byval]] //param// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] = 0, [[KeyPgByval byval]] //stack_size// [[KeyPgAs as]] [[KeyPgInteger integer]] = 0 ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Threadcreate** ( //proc// [, [ //param// ] [, //stack_size// ] ] )
##
{{fbdoc item="param"}}
	##//proc//##
		A pointer to the ##[[KeyPgSub Sub]]## intended to work as a thread.
	##//param//##
		Optional [[KeyPgAny any]] [[KeyPgPtr ptr]] argument for the ##[[KeyPgSub Sub]]## pointed to by //proc// (it can be a pointer to a structure or an array if more arguments are needed).
	##//stack_size//##
		Optional number of bytes to reserve for this thread's stack.

{{fbdoc item="ret"}}
	**Threadcreate** returns an ##[[KeyPgAny any]] [[KeyPgPtr ptr]]## handle to the thread created, or the null pointer (0) on failure.

{{fbdoc item="desc"}}
	The user function is started as a thread executes in parallel with the main part of the program. The OS achieves this by assigning it to a different processor if it exists, or using the waiting times in the main program.

	Before closing, a program must wait for the termination of all the threads it has launched; see ##[[KeyPgThreadWait Threadwait]]##.

	To avoid simultaneous access to shared resources from different threads, FB implements mutexes, mutual exclusion locks that can be "owned" by a single thread when doing critical work. See ##[[KeyPgMutexCreate Mutexcreate]]##, ##[[KeyPgMutexLock Mutexlock]]##, ##[[KeyPgMutexUnlock Mutexunlock]]##, ##[[KeyPgMutexDestroy Mutexdestroy]]##.

	On some systems, the stack automatically grows beyond ##//stack_size//## if more space is needed; on others, this is the fixed maximum allowed. Behavior is undefined when more stack is used than the reserved size on systems where stacks are not growable.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/threadcreate.bas"}}%%(freebasic)
dim shared terminate as integer =0

sub mythread (param as any ptr)
  dim a as integer, b as integer
  while 1
	b=0
	while b<80
	  print "*";
	  a=0
	   while a<&h7ffffff
	     a+=1
	  wend
	  b+=1
	wend
	if terminate=1 then exit sub
  wend
end sub

dim thread as any ptr
dim a as integer, b as integer

print "Main program prints dots"
print "Thread prints asterisks"
thread=threadcreate(@mythread,0)
print "Thread launched";
b=0
  while b<80

	a=0
	 while a<&h3
	    print ".";
	   a+=1
	wend
	b+=1
  wend
terminate=1
print "Terminate launched";
threadwait (thread)
print "Thread terminated"
sleep
%%

{{fbdoc item="lang"}}
	- Threading is not allowed in -lang qb

{{fbdoc item="target"}}
	- The DOS version of FreeBASIC does not allow for threads, as the OS does not support them.
	- In Linux the threads are always started in the order they are created, this can't be assumed in Win32. It's an OS, not a FB issue. 

{{fbdoc item="diff"}}
	- New to FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgThreadWait Threadwait]]##
	- ##[[KeyPgMutexCreate Mutexcreate]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}
{{fbdoc item="title" value="ALLOCATE"}}
----
Allocates a certain number of bytes from the free store.

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Allocate**( //count// [[KeyPgAs as]] [[KeyPgInteger integer]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
		//storage// = Allocate( //count// )
##
{{fbdoc item="param"}}
	##//count//##
		An integer specifying the number of bytes to be allocated.

{{fbdoc item="ret"}}
	The address of the newly allocated memory. A null (0) pointer is returned if the requested memory could not be allocated, or if ##//count//## < 0.

{{fbdoc item="desc"}}
	Attempts to allocate, or reserve, ##//count//## number of bytes from the free store (heap). Initial value of newly allocated memory is unspecified. The pointer returned points to the start of the allocated memory. If ##//count//## is zero, the pointer is guaranteed to be unique.

	Allocated memory must be deallocated, or freed, with ##[[KeyPgDeallocate Deallocate]]## when no longer needed.
	This function is not part of the FB RTLib, it is an alias for the C lib's //malloc//, so it's not garanteed to be thread safe in all platforms.

{{fbdoc item="ex"}}
##%%(qbasic)'' This program uses the ALLOCATE(...) function to create a buffer of 15 integers that is
'' then filled with the first 15 numbers of the Fibonacci Sequence. Note the call to
'' DEALLOCATE(...) at the end of the program.
option explicit

   const integerCount as integer = 15                    '' try to allocate memory for
   dim as integer ptr buffer                             '' 15 integers; get the address
   buffer = allocate( integerCount * len( integer ) )    '' of the first integer


   if( buffer = 0 ) then                                 '' allocation failed if the
	  print "Error: unable to allocate memory"           '' pointer returned is 0
	  end -1
   end if

   buffer[ 0 ] = 0                                       '' prime our fibonacci
   buffer[ 1 ] = 1                                       '' sequence ...

   dim as integer i
   for i = 2 to integerCount - 1
	  buffer[ i ] = buffer[ i-1 ] + buffer[ i-2 ]        '' ... and complete it
   next

   for i = 0 to integerCount - 1
	  print buffer[ i ] ;                                '' display the sequence
   next
   
   deallocate( buffer )                                  '' free the memory back
   end 0                                                 '' to the system
   
%%##
	Output is:
	<<  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377>>
	::c::

There are some things to be aware of when allocating memory. Take a look at the following example, which makes use of a single pointer to point to 2 different newly allocated memory locations.

%%(qbasic)option explicit

function AllocateExample2()
   dim as integer ptr integerPtr = 0                     '' initialize a pointer to null

'' first_allocation:
   integerPtr = allocate( len( integer ) )               '' assign pointer to new memory

'' second_allocation:
   integerPtr = allocate( len( integer ) )               '' reassign pointer to different
	                                                     '' memory
   deallocate( integerPtr )
end function

   AllocateExample2()
   sleep : end 0
%%

The above example leaks memory, since the first block of allocated memory is never deallocated. As a general rule, only reassign a pointer if you know that there is more than one reference to that memory location. If there isn't, then the first allocated memory block must be deallocated before reassigning the pointer.

{{fbdoc item="diff"}}
	- New to FreeBasic

{{fbdoc item="see"}}
	- ##[[KeyPgReallocate Reallocate]]##
	- ##[[KeyPgDeallocate Deallocate]]##

{{fbdoc item="back" value="CatPgFullIndex|Alphabetical Keywords List"}}

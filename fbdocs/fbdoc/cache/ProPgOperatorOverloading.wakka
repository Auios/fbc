{{fbdoc item="title" value="Operator Overloading"}}{{anchor name="top"}}----
Items discussed in this wiki:

==={{anchor name="item1|[item 1] What is an operator?"}}===
==={{anchor name="item2|[item 2] What is operator overloading?"}}===
==={{anchor name="item3|[item 3] What operators can I overload inside a Type definition?"}}===
==={{anchor name="item4|[item 4] How can I access Protected or Private members in global operator overloads?"}}===
==={{anchor name="item5|[item 5] What's a better way of doing that?"}}===
==={{anchor name="item6|[item 6] What about mathematical and logical operators?}}===
==={{anchor name="item7|[item 7] What's special about the assignment operator?"}}===
==={{anchor name="item8|[item 8] !!!WRITEME OVERLOADING NEW AND DELETE WRITEME!!!"}}===

----
~&{{anchor name="item1"}}==={{color c="blue" text="[item 1] What is an operator?"}}===
An operator is just a procedure, like most others. Some operators, like [[KeyPgCast operator cast]], even look like procedures. Others, like [[KeyPgLessThanOrEqual operator <=]], have a different syntax //(as of the time of this writing, calling these operators by name is not supported, but may be in the future)//. However they are called, the result is the same: some procedure is invoked based on the types of operands - the arguments of an operator call - that are passed to it.

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item2"}}==={{color c="blue" text="[item 2] What is operator overloading?"}}===
Operator overloading is just like normal procedure overloading, that is, an operator with the same name as an existing operator is defined to take different types of operands (parameters). Operators that take built-in types like [[KeyPgInteger integers]] or [[KeyPgString strings]] are already defined by the compiler, and so cannot be redefined. You can define operators with operands of user-defined types, however, and this is what operator overloading is.

There are two types of operators you can overload: global operators and member operators. Global operators are declared and defined in module-level code - globally. These are !!!WRITEME!!!. Member operators are declared within a [[KeyPgType Type]] or [[KeyPgClass Class]] definition, and are discussed {{anchor name="item3|in the next item"}}.

Overloading a global operator is much like overloading a normal procedure, you declare and define an existing operator with new operand types:

%%(qbasic)
type Rational
	as integer num, den
end type

'' operator <= declaration:
declare operator <= (byref as Rational, byref as Rational) as integer

'' operator <= definition:
operator <= (byref lhs as Rational, byref rhs as Rational) as integer
	return (lhs.num / lhs.den) <= (rhs.num / rhs.den)
end operator

'' Call global operator <= and check the result:
dim as Rational x = (1, 2), y = (3, 4)
if x <= y then
	print "Yay, it works!"
end if
%%

Note that global operators are like module-level procedures in that the [[KeyPgProtected Protected]] and [[KeyPgPrivate Private]] members of a [[KeyPgType Type]] or [[KeyPgClass Class]] are inaccessible. This is discussed {{anchor name="item4|in this item"}}.

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item3"}}==={{color c="blue" text="[item 3] What operators can I overload inside a Type definition?"}}===
Member operators are operators declared within a [[KeyPgType Type]] or [[KeyPgClass Class]] definition. The member operators are the assignment operators - like [[KeyPgOpAssignment operator let]] and [[KeyPgCombineOr operator or=]] - [[KeyPgCast operator cast]], [[KeyPgNew operator new]] and [[KeyPgDelete operator delete]], !!!WRITEME!!!.

Member operators are declared and defined like member procedures, with the keyword [[KeyPgOperator Operator]] instead of [[KeyPgSub Sub]] or [[KeyPgFunction Function]] and the operator name:

%%(qbasic)
type Rational
	declare constructor (num as integer, den as integer)

	'' Declare a copy assignment and cast operator:
	declare operator let (byref as Rational)
	declare operator cast () as double
private:
	as integer num, den
end type

constructor Rational (num as integer, den as integer)
	this.num = num
	this.den = den
end constructor

'' Define Rational's copy assignment and cast operator:
operator Rational.let (byref rhs as Rational)
	num = rhs.num
	den = rhs.den
end operator

operator Rational.cast () as double
	return iif (0 = den, cast(double, 0), num / den)
end operator

'' Initialize some Rationals by calling their ctors:
dim as Rational x = Rational(1, 2), y = Rational(3, 4)

'' Call x.operator let(y):
x = y

dim float as double

'' Implicitly call x.operator cast():
float = x
'' Explicitly call y.operator cast():
float = cast(double, y)
%%

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item4"}}==={{color c="blue" text="[item 4] How can I access Protected or Private members in global operator overloads?"}}===
Since global operators are {{anchor name="item2|declared and defined outside of any Type or Class definition"}}, they have only [[KeyPgPublic Public]] access rights to the object operands passed to them. Continuing in our Rational example, if both [[KeyPgInteger Integer]] data members are [[KeyPgPrivate Private]], how can a global operator - like the relational [[KeyPgLessThanOrEqual operator <=]] access them ?

One way is to simply make them [[KeyPgPublic Public]], for all the world to see. Object-orientated programming practices see this as a severe no-no though, so the more studious of you should be looking for a different approach.

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item5"}}==={{color c="blue" text="[item 5] What's a better way of doing that?"}}===
Short of {{anchor name="item4|making certain members Public so overloaded global operators can access them"}}, there is a much less disastrous method of solving that problem.

Static member procedures. After perusing through the [[ProPgMemberProcedures Member Procedures wiki]], you will find out that static member procedures have full access rights to the [[KeyPgType Type]]s or [[KeyPgClass Class]]es they are declared in. This makes them good candidates for handling the job of comparing Rational's [[KeyPgPrivate Private]] members. (in this situation, a non-static member procedure would work fine as well)

%%(qbasic)
type Rational
	'' ... Rational declarations as before ...

	declare static function lessThanOrEqual (byref a as Rational, byref b as Rational) as integer
private:
	as integer num, den
end type

function Rational.lessThanOrEqual (byref lhs as Rational, byref rhs as Rational) as integer
	'' do the actual comparing here:
	return iif (0 = lhs.den, cast(double, 0), lhs.num / lhs.den) _
		<= iif (0 = rhs.den, cast(double, 0), rhs.num / rhs.den)
end function

operator <= (byref lhs as Rational, byref rhs as Rational) as integer
	'' let the static member function Rational.lessThanOrEqual handle the work:
	return Rational.lessThanOrEqual(lhs, rhs)
end operator
%%

Here, the global [[KeyPgLessThanOrEqual operator <=]] passes along it's operands to a the static member procedure that does all of the work. Note that in this case, since we already have the member [[KeyPgCast operator cast]] defined, we could have had global [[KeyPgLessThanOrEqual operator <=]] simply use that instead of creating a static member procedure (##return cast(double, lhs) <= cast(double, rhs)##) - but what's the education in that? :)

You might be thinking that this method might be good when implementing the mathematical and logical operators, too - as they are also global operators. Typically though it's not, and that's discussed in {{anchor name="item6|the next item"}}.

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item6"}}==={{color c="blue" text="[item 6] What about mathematical and logical operators?"}}===
In the last item we talked about {{anchor name="item5|using member procedures as the workhorse of global operators"}} to get around the "I-can't-see-these-members-so-what-do-I-do" problem. It would seem that this would be a good way to implement all global operator overloads, but usually this is not the case. Here is a naive approach to implementing [[KeyPgMultiplication operator *]] and [[KeyPgCombineMulti operator *=]]:

%%(qbasic)
type Rational
	'' ... Rational as is before ...

	declare operator *= (byref rhs as Rational)
	declare static function Rational.multiply (byref lhs as Rational, byref rhs as Rational) as Rational
private:
	as integer num, den
end type

'' ... Rational member procedure definitions as before ...

operator Rational.*= (byref rhs as Rational)
	this = Rational.multiply(lhs, rhs)
end operator

function Rational.multiply (byref lhs as Rational, byref rhs as Rational) as Rational
	return Rational(lhs.num * rhs.num, lhs.den * rhs.den)
end function

operator * (byref lhs as Rational, byref rhs as Rational) as Rational
	return Rational.multiply(lhs, rhs)
end operator
%%

While this may look fine, it suffers from some problems, notably the assignment in Rational.operator *= - why assign, why not directly alter Rational's data members, shouldn't we be trying to minimize the temporary Rationals if at all possible? The problem is, if Rational.operator *= directly modified Rational's data members it's essentially doing the same thing as Rational.multiply (for a trivial procedure like this, the code duplication seems negligible, but keep in mind that any changes to Rational.multiply would need to be made in Rational.operator *= as well, which could get hairy with more complicated procedures).

There is a quite elegant solution to this mishappen situation, and that is to implement [[KeyPgMultiplication operator *]] //in terms of// [[KeyPgCombineMulti operator *=]]. This eliminates the temporary Rational and costly assignment in Rational.operator *=, and it also solves our code duplication problem: any changes made to the implementation of the multiplication algorithm only need to be made to one part of the code, Rational.operator *=. Observe:

%%(qbasic)
type Rational
	'' ... Rational as is before, minus static member procedure ...

	declare operator *= (byref rhs as Rational)
private:
	as integer num, den
end type

'' ... Rational member procedure definitions as before, minus static member procedure ...

'' Rational.operator *= directly modifies it's instance:
operator Rational.*= (byref rhs as Rational)
	num *= rhs.num
	den *= rhs.den
end operator

'' global operator * is protected from changes to Rational.operator *=:
operator * (byref lhs as Rational, byref rhs as Rational) as Rational
	dim result as Rational = lhs
	result *= rhs
	return result
end operator
%%

Implementing a mathematical or logical operator in terms of it's combination assignment member operator is a common and healthy technique to utilise. When appropriate, please do.

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item7"}}==={{color c="blue" text="[item 7] What's special about the assignment operator?"}}===
!!!WRITEME!!!

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----
~&{{anchor name="item8"}}==={{color c="blue" text="[item 8] item"}}===
!!!WRITEME!!!

[ {{anchor name="top|Top"}} | {{anchor name="bottom|Bottom"}} | [[KeyPgPreviousSection Previous]] | [[KeyPgNextSection Next]] ]
----

{{anchor name="bottom"}}
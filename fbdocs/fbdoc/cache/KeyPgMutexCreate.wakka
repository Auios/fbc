{{fbdoc item="title" value="MUTEXCREATE"}}
----
Creates a Mutex used for synchronizing the execution of threads.

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Mutexcreate** ( ) [[KeyPgAs as]] [[KeyPgInteger integer]]
##
{{fbdoc item="usage"}}##
	//result// = **Mutexcreate**
##
{{fbdoc item="ret"}}
	The ##[[KeyPgInteger integer]]## handle of the mutex created.

{{fbdoc item="desc"}}
	Mutexes, short for "Mutually Exclusive", are a way of synchronizing shared data within threads.  If there is a global variable used by multiple threads (or a local variable used by a single thread, called multiple times), it should be "locked" during its use with a mutex.  This halts all threads using ##[[KeyPgMutexUnlock Mutexunlock]]## with that mutex, until it is unlocked with ##[[KeyPgMutexLock Mutexlock]]##.

	**Mutexcreate** creates a mutex, returning a handle which is to be referred to when locking, unlocking, or destroying the mutex.  Mutexes created with **Mutexcreate** should be destroyed when no longer needed or before the end of the program with ##[[KeyPgMutexDestroy Mutexdestroy]]##.
	
	A  mutex is a lock that guarantees three things:
	1. Atomicity - Locking a mutex is an atomic operation, meaning that the operating system (or threads library) assures you that if you locked a mutex, no other thread succeeded in locking this mutex at the same time.
	2. Singularity - If a thread managed to lock a mutex, it is assured that no other thread will be able to lock the thread until the original thread releases the lock.
	3. Non-Busy Wait - If a thread attempts to lock a thread that was locked by a second thread, the first thread will be suspended (and will not consume any CPU resources) until the lock is freed by the second thread. At this time, the first thread will wake up and continue execution, having the mutex locked by it. 

{{fbdoc item="ex"}}
%%(qbasic)
'' Threading syncronyzation using Mutexes
'' If you comment out the lines containing "MutexLock" and "MutexUnlock",
'' the threads will not be in sync and some of the data may be printed
'' out of place.

DECLARE SUB thread1
DECLARE SUB thread2
DECLARE SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

DIM SHARED threadsync AS INTEGER
DIM SHARED thread1handle AS INTEGER
DIM SHARED thread2handle AS INTEGER

'' Create a mutex to syncronize the threads
threadsync = MUTEXCREATE

'' Call thread 1
thread1handle = THREADCREATE(@thread1)
IF thread1handle = 0 THEN
	PRINT "Error creating thread1"
END IF

'' Call thread 2
thread2handle = THREADCREATE(@thread2)
IF thread2handle = 0 THEN
	PRINT "Error creating thread1"
END IF

'' Wait until both threads are finished
THREADWAIT(thread1handle)
THREADWAIT(thread2handle)

teletype "Testing.................", 1, 1
teletype "Testing again...........", 10, 1

'' Discard the mutex when we are through using teletype
MUTEXDESTROY threadsync

SLEEP
END

'' Thread 1 calls a simple "teletype" routine
SUB thread1
	teletype "This is a test...", 4, 1
END SUB

'' ...As does thread 2
SUB thread2
	teletype "This is another test...", 7, 1
END SUB

'' Teletype unfurls some text across the screen at a given location
SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)
	DIM i AS INTEGER
	DIM text_length AS INTEGER

	text_length = LEN(text)
	FOR a = 0 TO text_length
	    '' MutexLock prevents the two simultaniously running
	    '' threads from sharing "x", "y", and "a"
	    MUTEXLOCK threadsync

	    LOCATE x,(y+a)
	    PRINT CHR(text[a])

	    '' MutexUnlock releases these variables for other use
	    MUTEXUNLOCK threadsync

	    SLEEP 25
   NEXT a
END SUB
%%

{{fbdoc item="diff"}}
	- This function is new to FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgThreadCreate Threadcreate]]##
	- ##[[KeyPgThreadWait Threadwait]]##

{{fbdoc item="back" value="CatPgThreading|THREADING"}}{{fbdoc item="back" value="CatPgFullIndex|Alphabetical Keywords List"}}
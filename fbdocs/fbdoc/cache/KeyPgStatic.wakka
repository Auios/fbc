{{fbdoc item="title" value="STATIC"}}----
Declares variables and object having static storage

{{fbdoc item="syntax"}}##
	**Static** //symbol//[( //subscripts// )] [ [[KeyPgAs as]] [[DataType DataType]]] [, ...]
//or//
	[[KeyPgSub sub]] //proc_header// **Static**
//or//
	[[KeyPgType Type]] //typename//
		[[KeyPgDeclare declare]] **Static** //membertype// //membername// ...
	End Type

	**Static** //membertype// //typename//.//membername// ...
##
{{fbdoc item="param"}}
	##//symbol//##
		variable or array symbol name
	##//proc_header//##
		procedure header for a procedure body.
	##//typename//##
		name of a user defined data type			
	##//membertype//##
		##[[KeyPgSub Sub]]##, ##[[KeyPgFunction Function]]##, ##[[KeyPgOperator Operator]]##, or ##[[KeyPgProperty Property]]##.
	##//membername// ...##
		Name of the member to declare or define with parameter list or return value following.

{{fbdoc item="desc"}}
	Specifies static storage for variables and objects; they are allocated at program startup and deallocated upon exit. Objects are only constructed when execution reaches their defintion however, and destructed upon program exit.

	In iterative blocks, like looping [[CatPgControlFlow control flow statements]] or non-recursive procedures, static variables and objects are guaranteed to occupy the same storage throughout multiple instantiations of the block. For example, it's safe for a procedure to return the address of one of its static variables or objects, as it will always occupy the same storage, and will not be destroyed until the program ends.

	In recursive blocks, where multiple instantiations of the block occur, static variables and objects are guaranteed to occupy the same storage across all of the blocks. For example, procedures that call themselves - either directly or indirectly - share the same instances of their static variables or objects. 

	When modifying a module-level procedure declaration, ##**STATIC**## specifies all variables and objects declared in the procedure to have static storage.

	When modifying a member procedure declaration, ##**STATIC**## specifies that the member procedure not have an implicit instance argument passed to it, and thus can only access other static members.

{{fbdoc item="ex"}}
%%(qbasic)sub f
	'' static variables are initialized to 0 by default
	static i as integer
	i += 1
	Print "Number of times called: " & i
end sub

'' the static variable in f() retains its value between
'' multiple procedure calls.
f()
f()
%%
	Will output:

%%
Number of times called: 1
Number of times called: 2
%%

{{fbdoc item="diff"}}
	- ##STATIC## can declare arrays, too.

{{fbdoc item="see"}}
	- ##[[KeyPgMetaStatic Option Static]]##
	- ##[[KeyPgDeclare Declare]]##
	- ##[[KeyPgDim Dim]]##
	- ##[[KeyPgSub Sub]]##
	- ##[[KeyPgType Type]]##
	- ##[[KeyPgVar Var]]##

{{fbdoc item="back" value="CatPgFullIndex|Alphabetical Keyword List"}}
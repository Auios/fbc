{{fbdoc item="title" value="Types as Objects"}}----

!!! WRITEME !!!

{{fbdoc item="desc"}}

%%(qbasic)
'' Sample Type showing available methods and operators
'' Practically this is a pointless example, as the only
'' data member is an Integer.  It serves only as a
'' demonstration and guide.
''
'' There are many other combinations that can be
'' used in pass parameters.  For simplicity
'' This example only uses byref and type T
'' where ever possible.

type T
  value as integer

  '' let, cast, combined assignment operators,
  '' constructors, and the destructor, must be
  '' declared inside the type.
  ''
  '' Parameters can be passed Byval or Byref
  '' in most (All? - verify this).
  ''
  '' All procs can be overloaded with different
  '' types as parameters.  In many cases this is not
  '' necessary as the TYPE can be coerced and
  '' converted depending on the CAST methods
  '' it exposes.  The compiler will to its best
  '' to evaluate statements and expressions if
  '' there is enough information to complete
  '' the operation.
  ''
  '' For example,
  '' Even though operator += may not be overloaded
  '' but operator let and operator + are, the
  '' compiler will convert the T += datatype
  '' to T = T + datatype.

  '' Static members must be declared inside the
  '' type.
  ''
  '' All static members are implicitly
  '' passed a hidden **this** parameter having
  '' the same type as the TYPE in which they are
  '' declared.
  ''
  '' Static member overloaded operators do not
  '' return a type.  All operation is done on the
  '' hidden this parameter.



  '' Static Member Declarations:

  '' Assignment

  declare operator let ( byref rhs as T )
  declare operator let ( byref rhs as integer )

  '' Cast can be overloaded to return multiple types

  declare operator cast () as string
  declare operator cast () as integer

  '' Combined assignment

  declare operator += ( byref rhs as T )
  declare operator += ( byref rhs as integer )

  declare operator -= ( byref rhs as T )
  declare operator *= ( byref rhs as T )
  declare operator /= ( byref rhs as T )
  declare operator \= ( byref rhs as T )
  declare operator mod= ( byref rhs as T )
  declare operator shl= ( byref rhs as T )
  declare operator shr= ( byref rhs as T )
  declare operator and= ( byref rhs as T )
  declare operator or= ( byref rhs as T )
  declare operator xor= ( byref rhs as T )
  declare operator imp= ( byref rhs as T )
  declare operator eqv= ( byref rhs as T )
  declare operator ^= ( byref rhs as T )

  '' Constructors can be overloaded

  declare constructor()
  declare constructor( byref rhs as T )
  declare constructor( byref rhs as integer )

  '' There can be only one destructor

  declare destructor()

  '' Static member functions and subs
  '' overloaded procs must have different parameters

  declare function f( ) as T
  declare function f( byref arg1 as T ) as integer

  declare sub s( )
  declare sub s( byref arg1 as T )
  declare sub s( byref arg1 as integer )

end type

'' These must be global procedures
'' Globals are not prefixed with the the TYPE name

declare operator - ( byref rhs as T ) as T
declare operator not ( byref rhs as T ) as T
declare operator + ( byref lhs as T , byref rhs as T ) as T 
declare operator - ( byref lhs as T , byref rhs as T ) as T 
declare operator * ( byref lhs as T, byref rhs as T ) as T
declare operator / ( byref lhs as T, byref rhs as T ) as T
declare operator \ ( byref lhs as T, byref rhs as T ) as T
declare operator mod ( byref lhs as T, byref rhs as T ) as T
declare operator shl ( byref lhs as T, byref rhs as T ) as T
declare operator shr ( byref lhs as T, byref rhs as T ) as T
declare operator and ( byref lhs as T, byref rhs as T ) as T
declare operator or ( byref lhs as T, byref rhs as T ) as T
declare operator xor ( byref lhs as T, byref rhs as T ) as T
declare operator imp ( byref lhs as T, byref rhs as T ) as T
declare operator eqv ( byref lhs as T, byref rhs as T ) as T
declare operator ^ ( byref lhs as T, byref rhs as T ) as T
declare operator = ( byref lhs as T, byref rhs as T ) as integer
declare operator <> ( byref lhs as T, byref rhs as T ) as integer
declare operator < ( byref lhs as T, byref rhs as T ) as integer
declare operator > ( byref lhs as T, byref rhs as T ) as integer
declare operator <= ( byref lhs as T, byref rhs as T ) as integer
declare operator >= ( byref lhs as T, byref rhs as T ) as integer

'' Global procedures (subs and funcs) can also accept the TYPE
'' as a parameter or return it as a value, as could be done
'' in previous versions of FreeBASIC.

  '' No example given.
  '' See function or sub in the manual.



'' All TYPE members are defined outside the TYPE

'' Static members must be prefixed with type name
'' in this case 'T'

'' Name resolution in a NAMESPACE is same as other
'' subs/funcs.  Use USING or prefix the namespace name

operator T.let ( byref rhs as T )
  value = rhs.value  
end operator

operator T.let ( byref rhs as integer )
  value = rhs  
end operator

operator T.cast ( ) as string
  return str( value )
end operator

operator T.cast ( ) as integer
  return value
end operator

operator T.+= ( byref rhs as T )
  value += rhs.value
end operator

operator T.+= ( byref rhs as integer )
  value += rhs
end operator

operator T.-= ( byref rhs as T )
  value -= rhs.value
end operator

operator T.*= ( byref rhs as T )
  value *= rhs.value
end operator

operator T./= ( byref rhs as T )
  value /= rhs.value
end operator

operator T.\= ( byref rhs as T )
  value \= rhs.value
end operator

operator T.mod= ( byref rhs as T )
  value mod= rhs.value
end operator

operator T.shl= ( byref rhs as T )
  value shl= rhs.value
end operator

operator T.shr= ( byref rhs as T )
  value shr= rhs.value
end operator

operator T.and= ( byref rhs as T )
  value and= rhs.value
end operator

operator T.or= ( byref rhs as T )
  value or= rhs.value
end operator

operator T.xor= ( byref rhs as T )
  value xor= rhs.value
end operator

operator T.imp= ( byref rhs as T )
  value imp= rhs.value
end operator

operator T.eqv= ( byref rhs as T )
  value eqv= rhs.value
end operator

operator T.^= ( byref rhs as T )
  value ^= rhs.value
end operator


'' Constructors:

constructor T()
  value = 0
end constructor

constructor T( byref rhs as T )
  value = rhs.value
end constructor

constructor T( byref rhs as integer )
  value = rhs
end constructor

'' There can be only one destructor

destructor T()
  '' clean-up, none in this example
end destructor



'' Globals must specify all arguments and return type

operator - ( byref rhs as T ) as T
  return type<T>(-rhs.value)
end operator

operator not ( byref rhs as T ) as T
  return type<T>(not rhs.value)
end operator

operator + ( byref lhs as T , byref rhs as T ) as T 
  return type<T>(lhs.value + rhs.value)
end operator

operator - ( byref lhs as T , byref rhs as T ) as T 
  return type<T>(lhs.value - rhs.value)
end operator

operator * ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value * rhs.value)
end operator

operator / ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value / rhs.value)
end operator

operator \ ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value \ rhs.value)
end operator

operator mod ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value mod rhs.value)
end operator

operator shl ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value shl rhs.value)
end operator

operator shr ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value shr rhs.value)
end operator

operator and ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value and rhs.value)
end operator

operator or ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value or rhs.value)
end operator

operator xor ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value xor rhs.value)
end operator

operator imp ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value imp rhs.value)
end operator

operator eqv ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value eqv rhs.value)
end operator

operator ^ ( byref lhs as T, byref rhs as T ) as T
  return type<T>(lhs.value ^ rhs.value)
end operator

operator = ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value = rhs.value
end operator

operator <> ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value <> rhs.value
end operator

operator < ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value < rhs.value
end operator

operator > ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value > rhs.value
end operator

operator <= ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value <= rhs.value
end operator

operator >= ( byref lhs as T, byref rhs as T ) as integer
  return lhs.value >= rhs.value
end operator


'' Static member methods

function T.f( ) as T
  dim x as T = this
  '' Just return a copy
  return x
end function

function T.f( byref arg1 as T ) as integer
  arg1.value = this.value
  return value
end function

sub T.s( )
  '' refer to the type using
  
  '' with block
  with this
	.value = 1
  end with
  
  '' field access
  this.value = 2
  
  '' directly
  value = 3

end sub

sub T.s( byref arg1 as T )
  value = arg1.value
end sub

sub T.s( byref arg1 as integer )
  value = arg1
end sub

%%

{{fbdoc item="see"}}
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}
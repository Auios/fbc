/*
 *  By Sterling Christensen (sterling@engineer.com)
 *  Based on code Copyright (C) 2004 by Marzec
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "QB_gfx_main.h"

/* Sets what type of events Inkey/InkeyEx removes from the queue
   Default is SDL_ALLEVENTS
   Takes an int in the same format as SDL_PeepEvents */
FBCALL void fb_GfxSetEventMask (int mask)
{
    fb_GfxInfo.eventMask = mask;
}

/*------------------------------------------------------------------------------
    fb_GfxInkey()
    desc: returns the first key within the keyqueue or "" if no key is in there
------------------------------------------------------------------------------*/
FBSTRING* fb_GfxInkey (void)
{
	FBSTRING *ret;
    int ikey;

    ikey = fb_GfxInkeyEx();

    if (ikey == 0) return &fb_strNullDesc;

    if ((ikey & 0xFF00) != 0xFF00) return fb_CHR(ikey);

    if (ikey == -1)
    {
        ret = (FBSTRING *)fb_hStrAllocTmpDesc();
        fb_hStrAllocTemp(ret, 4);
        ret->data[0] = 'Q';
        ret->data[1] = 'U';
        ret->data[2] = 'I';
        ret->data[3] = 'T';
        ret->data[4] = '\0';
        return ret;
    }

//    if ((ikey & 0xFF00) == 0xFF00)
//    {
//        return fb_MKI(0xFF + ((unsigned char)ikey << 8));
        ret = (FBSTRING *)fb_hStrAllocTmpDesc();
        fb_hStrAllocTemp(ret, 2);
        ret->data[0] = 0xFF;
        ret->data[1] = (char)ikey;
        ret->data[2] = '\0';
        return ret;
//    }

}

int fb_GfxInkeyEx(void)
{
    int n;
    SDL_Event event;

    SDL_PumpEvents();

    do
    {
        n = SDL_PeepEvents(&event, 1, SDL_GETEVENT, fb_GfxInfo.eventMask);
        if (n < 1) return 0;

        if (event.key.type == SDL_QUIT) return -1;
    }
    while (event.key.type != SDL_KEYDOWN);

    n = event.key.keysym.sym;

    if ( (!(event.key.keysym.mod & KMOD_CAPS) + !(event.key.keysym.mod & KMOD_SHIFT) == 1) &&
         (n >= 'a' && n <= 'z')
       )
    {
        return n - 32;
    }

    /* A lookup table might actually be smaller than the opcodes generated by
       this (and possibly faster too): */
    if (event.key.keysym.mod & KMOD_SHIFT)
    {
        if (n == ',' || n == '.' || n == '/') {
            return n + 16;
        } else if (n == ';') {
            return ':';
        } else if (n == '\'') {
            return '"';
        } else if (n >= '[' && n <= ']') {
            return n + 32;
        } else if (n == '-') {
            return '_';
        } else if (n == '=') {
            return '+';
        } else if (n == '`') {
            return '~';
        } else if (n == '1') {
            return '!';
        } else if (n == '2') {
            return '@';
        } else if (n >= '3' && n <= '5') {
            return n - 16;
        } else if (n == '6') {
            return '^';
        } else if (n == '7') {
            return '&';
        } else if (n == '8') {
            return '*';
        } else if (n == '9') {
            return '(';
        } else if (n == '0') {
            return ')';
        }
    }

    if (n == ' ' ||
        n == SDLK_BACKSPACE ||
        n == SDLK_RETURN ||
        n == SDLK_TAB ||
        (n >= SDLK_ESCAPE && n <= 'z') )
    {
        return n;
    }
    else if (n >= SDLK_NUMLOCK && n <= SDLK_COMPOSE)
    {
        return 0;
    }
    else
    {
        return 0xFF00 + event.key.keysym.scancode;
    }
}


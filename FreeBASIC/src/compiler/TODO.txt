
[ ] rewrite the emit module, using pseudo-opcode lists (as in IR), never emit any text
    - keep track of functions
    - the main module can be "updated" between functions, as that is allowed
    - handle inline asm
    - handle sections
    - handle DATA's -- data, not code??
    - handle static initializers - can include strings -- data, not code??
    - handle jump-tables - emited by SELECT AS CONST -- code.. move to .const??
    - handle debug info - can include strings
    - handle labels - strings, can't use the symbol as it can be deleted
    - handle variables - strings, offsets, but can't include the registers!
    - handle comments - strings
    - handle index registers, so pipelining optimizations would be possible
    - optimize load after store
    - check if ebx, esi and edi are trashed to preserve them - inlined asm can't be predicated
    - re-ordering optimization if target cpu is +586

[ ] full debug support
    - GDB is getting nuts with the "main" function overlapping the real ones, so the main module can't be
      emited until all real functions are. Emit will have to use a buffer or such. Include files CAN'T
      be part of the main module either
    - add include files - module level code won't be supported, only sub-routines, it's bad practic anyways..
    - add dynamic arrays - can't get GDB to use Fortran-like arrays
    - add enums (sym tb must link the elements with the parent enum)

[ ] add the concatenation operator (&) as in VB/... - any type must be implicitly converted to string

[ ] add fix-len and zstring * support to arrays args passed by descriptor

[ ] function overloading:
    - check arglist with optionals with different types at the same arg num (?)
    - check different modes and types if they are working
    - check optional args, this can be tricky

[ ] check for references to self on TYPE fields (field AS parent)

[ ] make the emiter modules modular (duh), so multiple cpu targets could be supported.. some day

*** *** *** *** ***
[ ] parser should never call IR directly, or no inline functions can be added (or never-called
    private functions eliminated). For that be done, all labels must be handled by AST, ASM,
    var initializers and jump tbs too (DATA can't be defined inside procs), all IR/AST flush
    calls must be changed to astLink or such, that will add the new node to a list of nodes,
    that will be flushed only whem a new function is started or when the end of file is reached --
    should it be better to be done as a CFG-like than handled at AST that is becoming more and
    more complex (don't make the AST a parser tree!)?

[ ] inline functions -- better than macros as they can be "turned off" when debugged (AST will need some kind of "link"
                        node to glue all nodes parsed, and they can't be flushed by any part of the parser -- everything
                        must be done at the AST then, no IR calls at the parser.. quite hard to do due the var
                        initializers, etc)

[ ] pointer type casting

[ ] classes  -- single inheritance, plus interfaces -- Java/Php5-ish: CLASS EXTENDS IMPLEMENTS THROWS

*** yet another optimizations ***
[ ] reuse temp vars (or just strings), so less mem is used
[ ] use CMOV when possible on 686 (maybe at IR, but probably requires peephole at EMIT)
[ ] unreachable code removal

*** future ***
[ ] AndAlso and OrElse, short-circuit versions of And and Or

[ ] use a DAG for common sub-expr opt (don't mess up w/ FPU??)


	a = b + c
	b = a - d
	c = b + c
	d = a - d


    v2() = v1(_B) + v0(_C)
 v3(_A) := v2()
    v6() = v5(_A) - v4(_D)
 v7(_B) := v6()
   v10() = v9(_B) + v8(_C)
v11(_C) := v10()
   v14() = v13(_A) - v12(_D)
v15(_D) := v14()

	mov 	eax, b
	Add 	eax, c
	mov 	a, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	b, eax
	mov 	eax, b
	Add 	eax, c
	mov 	c, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	d, eax

|v1|v0|op:2-->|v2
|op:1-->|v3
|v5|op:3-->|v6|v14
|op:1-->|v7|v15
|op:2-->|v10
|op:1-->|v11

	mov		eax, b
	Add		eax, c
	mov		a, eax
	Sub		eax, d
	mov		b, eax
	mov		d, eax
	Add		eax, c
	mov		c, eax

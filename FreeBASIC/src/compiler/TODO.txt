[ ] allow structs to be returned (must follow gcc's abi) -- how to handle foo = bar() if bar()
    actually returns a ptr to the hidden argument passed? and worst.. GCC will return ANY struct
    <= 8 bytes in EAX:EDX (and with an unique FP field in ST(0)!), what means things will become
    weird when asssigning them to real UDT's, as UDT's have no data class to AST/IR/EMIT deal with

[ ] make the runtime lib thread safe

[ ] OPTION's should be preserved when changed inside include files

[ ] rewrite the IR module using pointers instead of indexes, to be able to make fast links between
    a vreg and a TAC node later, so no MaxDistance will be needed

*** *** *** *** ***
[ ] parser should never call IR directly, or no inline functions can be added (or never-called
    private functions eliminated). For that be done, all labels must be handled by AST, ASM,
    var initializers and jump tbs too (DATA can't be defined inside procs), all IR/AST flush
    calls must be changed to astLink or such, that will add the new node to a list of nodes,
    that will be flushed only whem a new function is started or when the end of file is reached --
    should it be better to be done as a CFG-like than handled at AST that is becoming more and
    more complex (don't make the AST a parser tree!)?

[ ] inline functions -- better than macros as they can be "turned off" when debugged (AST will need some kind of "link"
                        node to glue all nodes parsed, and they can't be flushed by any part of the parser -- everything
                        must be done at the AST then, no IR calls at the parser.. quite hard to do due the var
                        initializers, etc)

[ ] pointer type casting

[ ] full debug support

[ ] var ini  -- dim myvar as sometype = { initialvalue } -- has to support arrays and types too

[ ] classes  -- single inheritance, plus interfaces -- Java/Php5-ish: CLASS EXTENDS IMPLEMENTS THROWS

*** yet another optimizations ***
[ ] reuse temp vars (or just strings), so less mem is used and less strDel's are needed inside procs
[ ] get hide of double fxch's (needs peephole optimization at EMIT)
[ ] load after store elimination (at IR?)
[ ] use CMOV when possible on 686 (maybe at IR, but probably requires peephole at EMIT)
[ ] unreachable code removal

*** future ***
[ ] AndAlso and OrElse, short-circuit versions of And and Or

[ ] use a DAG for common sub-expr opt (don't mess up w/ FPU??)


	a = b + c
	b = a - d
	c = b + c
	d = a - d


    v2() = v1(_B) + v0(_C)
 v3(_A) := v2()
    v6() = v5(_A) - v4(_D)
 v7(_B) := v6()
   v10() = v9(_B) + v8(_C)
v11(_C) := v10()
   v14() = v13(_A) - v12(_D)
v15(_D) := v14()

	mov 	eax, b
	Add 	eax, c
	mov 	a, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	b, eax
	mov 	eax, b
	Add 	eax, c
	mov 	c, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	d, eax

|v1|v0|op:2-->|v2
|op:1-->|v3
|v5|op:3-->|v6|v14
|op:1-->|v7|v15
|op:2-->|v10
|op:1-->|v11

	mov		eax, b
	Add		eax, c
	mov		a, eax
	Sub		eax, d
	mov		b, eax
	mov		d, eax
	Add		eax, c
	mov		c, eax

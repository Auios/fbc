
[ ] optimize "a = b + c + d" to "a = b: a += c: a += d" to speedup multiple string assignaments
    (but only if the l-side var isn't in the right-size, course), then clean up emit.bas, that
    looks like a mess right now -- problem: some kind of high level link will be needed, as
    assignaments aren't linked

[ ] add fix-len and zstring * support to arrays args passed by descriptor

[ ] full debug support

[ ] function overloading:
-- check arglist with optionals with different types at the same arg num (?)
-- check different modes and types if they are working
-- check optional args, this can be tricky

[ ] check for references to self on TYPE fields (field AS parent)

[ ] make the emiter modules modular (duh), so multiple cpu targets could be supported.. some day

*** *** *** *** ***
[ ] parser should never call IR directly, or no inline functions can be added (or never-called
    private functions eliminated). For that be done, all labels must be handled by AST, ASM,
    var initializers and jump tbs too (DATA can't be defined inside procs), all IR/AST flush
    calls must be changed to astLink or such, that will add the new node to a list of nodes,
    that will be flushed only whem a new function is started or when the end of file is reached --
    should it be better to be done as a CFG-like than handled at AST that is becoming more and
    more complex (don't make the AST a parser tree!)?

[ ] inline functions -- better than macros as they can be "turned off" when debugged (AST will need some kind of "link"
                        node to glue all nodes parsed, and they can't be flushed by any part of the parser -- everything
                        must be done at the AST then, no IR calls at the parser.. quite hard to do due the var
                        initializers, etc)

[ ] pointer type casting

[ ] classes  -- single inheritance, plus interfaces -- Java/Php5-ish: CLASS EXTENDS IMPLEMENTS THROWS

*** yet another optimizations ***
[ ] reuse temp vars (or just strings), so less mem is used and less strDel's are needed inside procs
[ ] get hide of double fxch's (needs peephole optimization at EMIT)
[ ] load after store elimination (at IR?)
[ ] use CMOV when possible on 686 (maybe at IR, but probably requires peephole at EMIT)
[ ] unreachable code removal

*** future ***
[ ] AndAlso and OrElse, short-circuit versions of And and Or

[ ] use a DAG for common sub-expr opt (don't mess up w/ FPU??)


	a = b + c
	b = a - d
	c = b + c
	d = a - d


    v2() = v1(_B) + v0(_C)
 v3(_A) := v2()
    v6() = v5(_A) - v4(_D)
 v7(_B) := v6()
   v10() = v9(_B) + v8(_C)
v11(_C) := v10()
   v14() = v13(_A) - v12(_D)
v15(_D) := v14()

	mov 	eax, b
	Add 	eax, c
	mov 	a, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	b, eax
	mov 	eax, b
	Add 	eax, c
	mov 	c, eax
	mov 	eax, a
	Sub 	eax, d
	mov 	d, eax

|v1|v0|op:2-->|v2
|op:1-->|v3
|v5|op:3-->|v6|v14
|op:1-->|v7|v15
|op:2-->|v10
|op:1-->|v11

	mov		eax, b
	Add		eax, c
	mov		a, eax
	Sub		eax, d
	mov		b, eax
	mov		d, eax
	Add		eax, c
	mov		c, eax

[ ] STATIC
    - NEW and DELETE must be static methods (an explict STATIC shouldn't be needed),
      but added to parent's NEW_|DEL_SELF
    - allow all global operators to be declared as static methods?
    - add static data members, they must be initialized outside the TYPE|CLASS

[ ] remove the internal profiler and use gprof instead, the former won't work with
    destructors

    [X] mingw
    [ ] cygwin - not tested yet
    [X] dos
    [X] linux
    [ ] xbox - does openxdk even support profiling with gmon?
               If not, then it shouldn't be an allowable option.

    [ ] remove libfb_ctor.c - replaced by fbrt0.c

[ ] operator overloading:
      - add support for functions returning references (reuse "BYREF") or the
        '->' operator will be useless for UDT's with copy-ctors or dtors
        as returning byval will make a deep copy
      - OPERATOR foo.() ( lb1, lb2, ..... ) AS TYPE -- array indexing, not functor

[ ] ctor/dtor
	- foo().bar().baz(0,1,3).int where baz is returned byval and has dtor
	  must be handled right after the .int is used, not only when the current
	  scope if finished
	  - how to handle: if( foo().bar().baz(0,1,3).int = 0 ) then ...

	- ArrayClear will be used instead of a dtor call looping to destroy
	  local non-dynamic arrays
	  - callVarDtor will have to use astAddAfter then with scope blocks..

	- add SWAP for structs with copy-ctors and/or destructors

	- add NEW and DELETE as operator
	  - use the nothrow version only for now
	    - exception handling is different in all platforms,
	      the sjlj (setjmp and longjmp) method isn't used in ELF (it seems)
	    - no way to define "byref param2 as std::nothrow_t" in rtl-mem.bas
	      - namespace mangling will have to check for STD and add just "St"
	        without the # prefix

[ ] data/function members:
      - add virtual (functions only)
          - the vtable must be compatible with G++ 3.x (ie: compatible with
            COM interfaces in Windows)

[ ] quirks:
    [ ] OPEN ... FOR is not checking for mode
    	- does QB allow that? CONS won't work without INPUT or OUTPUT
    [ ] GET and PUT shouldn't allow strings when the number of items is passed
    [ ] -exx is giving suspicious ptr assignment when module/name are been restored inside ns'

[ ] add the -lang (qb|fb) cmd-line option:
    - "qb":
      [x] OPEN should be compatible with QB (ie: OPEN "DEVICE:"), the bloat doesn't
          matter in -lang qb mode, just implement a fb_OpenDev or so in the rtlib doing
          the parsing that will call any supported fb_hFileOpen###'s (COM, LPT, CONS, etc)
      [ ] add the FIELD #expr statement - threads are not allowed in -lang qb anywywas
      [ ] CALL: support undefined functions as in QB, all params BYREF as ANY
      [ ] SHARED at subs (non-shared vars at mod-level will have to be allocated
          statically, as before)
      [ ] DEF - convert to a macro? doesn't it make any symbol called Fn... invalid
          because it allows forward refs?
      [ ] arrays with same name as scalars
      [ ] labels with the same name as procs:
          declare sub foo \n foo: \n goto foo \n call foo
      [ ] symbols with same name but different sufixes than keywords
      [x] move all variables to function-level, implicit or explict (see no SCOPE)
          [ ] check if its done correctly, if they are being cleared right after the
              stack frame setup
      [x] GOSUB and RETURN in subroutines (so RETURN can't be used as a shortcut to EXIT FUNCTION)
      	  [ ] implement it using setjmp/longjmp later in the rtlib
      [x] periods in symbol names
      [x] numeric labels
      [x] params passed by reference by default
      [x] DEF### (ie: explicit types required)
      [x] implicit variables
      [x] suffixes % & ! # $
      [x] '$dynamic, '$static, '$include
      [x] LET
      [x] ON .. GOTO|GOSUB
      [ ] ON ERROR, RESUME
      [x] OPTION's
      [x] DEFSNG

      [x] no SCOPE
      [x] no NAMESPACE
      [x] no CLASS (and exception handling)
      [x] no op and function overloading
      [x] no EXTERN (periods and suffixes screw mangling)
      [x] no multi-threading - not thread*, mutex*, cond*

    - "fb" - the inverse of "qb", but show deprecated messages by now for:
      [ ] without ON ERROR, all stmts returning rt errors should be allowed to
          be used as functions too

[ ] add a C backend
	- the va_* macros/quirk-func must be passed to AST, each ABI has different way to
	  access varargs
	- how to acccess fields?
	  	foo.bar.baz would become:
	  	*((typeof(bar.baz) *)((char *)&foo + offsetof(foo, bar) + offsetof(bar, baz))
	  	but offsetof() is resolved at FBC compile-time, making the access ABI-dependent
	  	even if structs are fully emitted
	  	- (not so simple) solution: let the AST do it
	- shared/module-level vars must be emitted before any proc
	- type-cast's must be preserved, but astNewCONV() won't create a new node
	  if converting from pointer types or if data sizes and classes are the same
	- scopes must be preserved or local vars won't work
	- if()'s must be translated to
	  if(vreg op vreg) goto label
	  { -- scope
	  } -- end scope
	  label:
        - function calls must be passed complete to IR, with params
        - stdcall names shouldn't be mangled, but anything else should - at least
          the g++ mangling uses no special characters
	- how to handle VARINI###? pass it as a tree plus a callback?
	- DATA arrays must be emitted in the inverse order because the forward ref links
	- structs must be fully translated
        - only accept inline asm in GCC format, pass as-is
	- use GCC as a high-level assembler, no headers, nothing
	- linking should still be done by us
	- if everything is solved, it would become much simpler to add a LLVM back-end as
	  it's essentially a high-level ASM with virtual-regs

[ ] ParamArray, but with this syntax: foo(...) as bar
	- array must be built at compile-time and destroyed after the call
	- take care with objects..

[ ] namespace:
    - add support for importing single symbols (mostly because classes, as nested ns'
      are already supported)

[ ] proc call:
    - add named parameters (foo := expr)
      - can be hard to be added because they don't have to come in order
      - := must be a new token because the "foo bar : baz" ambiguity

[ ] add #pragma cmdline="-foo bar -baz"
	- painful to add
	- don't allow it if any line was parsed already

[ ] PP:
    - [macro expansion: won't work for inner macros
    - add varargs support, like foo(arg1, ...) ...
    - support default arguments?

[ ] SCOPE..END SCOPE:
    - can't optimize multiple MEM_CLEAR's if there's any branch to
      one of them
    - error handlers should be restored too (or not allowed at all)

[ ] EXTERN ... END EXTERN
    - C++ mangling needs CONST's to be handled in param attributes:
      - refs and ptrs to constants can't be added unless _POINTER is added
        as a new symbol like with BITFIELD? that will need *a lot* of changes..

[ ] disallow (in -lang qb mode):
	dim foo as foo
	.. and later ..
	const|dim|function|etc foo.bar

[ ] when creating static libraries, emit a LD script file with the #inclib's found,
    when linking, check for the scripts (libfoo_a.libs.x or such) and include the files
    listed (will have to check the same dirs as LD does, including LD_LIBRARY_PATH and
    the ones defined in the .x scripts)
    - can't modify LD because adding new libraries found on .drectiv or such sections
      would put them outside the GROUP, causing circular reference errors
    - for the same reason, the list file can't be a LD script to be passed directly,
      the libs must be passed in the cmd-line, between -( and -)
    - libbfd could be used to load add our own sections to object files
      - but then the libraries would have to be opened twice (by fbc and later by LD),
      slowing down linking
      - libbfd is over 600k, fbc will become twice as big just to add an ordinary feature
    - that won't work with object files or when passing more than a single bas file if
      the other ones #include different libraries
      - a foo.o.liblist or such will be needed then, should be created only when
        #inclib's are found
    - a libfoo.a.liblist for libraries
    - #libpath's must be added to .liblist too and checked also

[ ] fbmain - explicit main function
    - must check if anything but the init/end labels were defined already inside
      the implicit main() or the mod-level constructor
    - must delete proto and all ast nodes
    - must create as CDECL but it doesn't have to be obligatory
    - must support RETURN or FUNCTION = to set the result
    - must check the params if passed byval and if they have the right types

[ ] add the ... subscript when initializing array so
    "dim array(0 to ...) = {1, 2, 3, 4}" could be allowed

[ ] forward type defs used in byval parms of function ptr type defs shouldn't be an error
    - the prototype mangling must be updated when that occurs, but how to do that fast
      enough? the args would have to be linked to parent (the prototype), but updating
      the mangled alias on every argument can be slow..

[ ] add the wstring type:
    - fb_ConsoleInput() won't call fb_DevScrnInit_ReadWstr( ), so an input to a
      wstring won't work.. to not add more bloat, the compiler should have to
      call fb_ConsoleInput(there_is_any_wstr_argument), not so simple..
    - auto-convert literal strings to w- or z- on assignments, depending on the l-hand
      side type
    - fix the !!!FIXME!!!'s and write the !!!WRITEME!!!'s in the rtlib

[ ] swap of zstring's and var-len string's is not working?? or that's the behaviour..

[ ] passing a temporary string to a zstring ptr should not make yet-another temporary
    assignment in hStrParamToPtrArg(), just a pointer copy that later should be
    strDelete()'d

*** *** *** *** ***
[ ] all functions returning STRING should actually return the FBSTRING
    object, but we can't code the it in g++, or in Linux we will need to
    link (and include) the stdc++ lib, that's over 2.5MB big, so it must
    be done in pure C, using the G++ ABI (ie: FBSTRING has a dtor, so it's
    never returned or passed by value):
    - compiler has to allocate the descriptor as it does now following the gcc ABI
    - any function in the run-time library returning strings will have to be
      modified (chicken-egg problem)
    - no more run-time allocation of temp descriptors (better with threads)
    - no more STR_LOCK's (ditto)
    - str_delete won't check for temp descriptors anymore

[ ] fixed-len strings compatible with QB:
    - no null-term, temporaries always created when passing to functions
    - probably will need their own assign and concat functions

[ ] "byval as string" arguments should make a temp copy (including descriptor)
    of the param passed:
    - must pass (?) the address of the temp descriptor, not the string data, what
      will break *all* functions assuming the latter - they would have to be
      declared as zstring ptr, what will need more changes in users' code, because
      the non-implicit pointer deref

*** *** *** *** ***
[ ] proc def:
    - when checking the prototype, the access modifiers must be checked too: PUBLIC, PRIVATE
    - to support params > 64k, "ret" can't be used

[ ] .stabn can't have args > 65535 (ie: line numbers)
    - only switching to DWARF2 (ie: too complex) would fix that, let GCC do it..

[ ] arrays will fail in quirk gfx funcs if multi-dimensional and have <> 0 lBounds

[ ] add "fix-len|w|z|string * expr" support to array args passed by descriptor

[ ] named field initializers: ( foo => bar, udt => ( 1, { 2, 3 }, 4 ) )
    - all fields initialized must be named as a special parser routine will have to be used,
      that will keep track of what wasn't initialized to fill 'em with 0's - static only,
      locals are already cleared

[ ] full debug support
    - add dynamic arrays - couldn't get GDB to use Fortran-like arrays
    - each overloaded function will show the locals of *ALL* functions

[ ] AndAlso and OrElse, short-circuit versions of And and Or
    - pay attention to register spills if functions or complex expressions are
      used in left or right sides

[ ] inline functions
    - better than macros as they can be "turned off" when debugged
    - too hard to be added now due the register spills, IR must handle inter blocks and
      keep track of live vregs

[ ] classes
    - *MUST* follow the GCC 3.x ABI to make it easier to reuse C++ libs compiled by GCC
    - Java/Php5-ish syntax: CLASS INTERFACE EXTENDS IMPLEMENTS THROWS ABSTRACT
    - must support forward references for any kind of symbol, so classes can't be stored
      directly to AST
      - how to deal with "foo(expr)"? it could be an array or a function call..
      - keeping everything in a parser/token tree will allow templates to be added later
      - class shouldn't be emitted unless referenced
        - function bodies defined outside classes follow the private/public proc rules
    - single inheritance, plus interfaces
    - exceptions - with stack unwind support
    - pure virtual methods
    - down casting
    - some support for RTTI



//
// Regular Right Part (aka ECF) grammar for FreeBASIC programming language
// copyright (c) 2004 by v1ctor (av1ctor@yahoo.com.br)
//


//:::::
Program         =   Line* EOF .

//:::::
Line            =   Label? Statement? Comment? EOL .

//:::::
SimpleLine      =   Label? SimpleStatement? Comment? EOL .

//:::::
Label           =   NUM_LIT
                |   ID ':' .

//:::::
Comment         =   (COMMENT_CHAR | REM) ((DIRECTIVE_CHAR Directive)
		|   (any_char_but_EOL*)) .

//:::::
Directive       =   INCLUDE ':' '\ STR_LIT '\
		|   DYNAMIC
		|   STATIC .

//:::::
Statement       =   (Declaration | ProcCall | CompoundStmt | cProcStatement | QuirkStmt | Assignment)
                    (STT_SEPARATOR Statement)* .

//:::::
SimpleStatement =   (ConstDecl | SymbolDecl | ProcCall | CompoundStmt | QuirkStmt | Assignment)
                    (STT_SEPARATOR SimpleStatement)* .

:::
SttSeparator    =   (STT_SEPARATOR | EOL)+ .

//:::::
Declaration     =   ConstDecl | TypeDecl | SymbolDecl | ProcDecl | DefDecl | OptDecl.

//:::::
ConstDecl       =   CONST ConstAssign (DECL_SEPARATOR ConstAssign)* .

:::
ConstAssign     =   ID (AS SymbolType)? ASSIGN (ConstExpression | STR_LITERAL) .

//:::::
ElementDecl     =   ID ArrayDecl? AS SymbolType

//:::::
TypeDecl        =   (TYPE|UNION) ID (FIELD '=' Expression)? Comment? SttSeparator
		    	(UNION Comment? SttSeparator
				(ElementDecl? Comment? SttSeparator)+
			END UNION)
                	| (ElementDecl? Comment? SttSeparator)+
		    END (TYPE|UNION) .

:::
EnumConstDecl   =   ID (ASSIGN ConstExpression)? .

//:::::
EnumDecl        =   ENUM ID Comment? SttSeparator
                    	(EnumDecl? Comment? SttSeparator)+
		    END ENUM .
//:::::
SymbolDecl      =   (REDIM PRESERVE?|DIM|COMMON) SHARED? SymbolDef
                |   STATIC SymbolDef .

//:::::
SymbolDef       =   ID ArrayDecl? (AS SymbolType)?
                       (DECL_SEPARATOR SymbolDef)* .

//:::::
ArrayDecl       =   IDX_OPEN Expression (TO Expression)?
                             (DECL_SEPARATOR Expression (TO Expression)?)*
		    IDX_CLOSE .

//:::::
SymbolType      =   UNSIGNED? (
		    ANY
		|   CHAR|BYTE
		|   SHORT|USHORT
		|   INTEGER|LONG|UINTEGER
		|   SINGLE
		|   DOUBLE
                |   STRING ('*' NUM_LIT)?
                |   USERDEFTYPE
		|   (FUNCTION|SUB) ('(' args ')') (AS SymbolType)?
		    (PTR|POINTER)? .

//:::::
ProcDecl        =   DECLARE (SUB SubDecl) |
                            (FUNCTION FuncDecl) .

//:::::
CallingConvent	=   CDECL | STDCALL | PASCAL .

//:::::
SubOrFuncDecl   =   ID CallingConvent? (ALIAS STR_LIT)? (LIB STR_LIT)? ('(' Arguments? ')')?
		|   ID CallingConvent? (ALIAS STR_LIT)? (LIB STR_LIT)? ('(' Arguments? ')')? (AS SymbolType)? .

//:::::
Arguments       =   ArgDecl (DECL_SEPARATOR ArgDecl)* .

//:::::
ArgDecl         =   (BYVAL|BYREF|SEG)? ID (('(' ')')? (AS SymbolType)?)? ('=" NUM_LIT)? .

//:::::
DefDecl         =   (DEFINT|DEFLNG|DEFSNG|DEFDBL|DEFSTR) (CHAR '-' CHAR ','?)* .

//:::::
OptDecl         =   OPTION (EXPLICIT|BASE NUM_LIT|BYVAL|PRIVATE)

//:::::
ProcParam       =   (BYREF|BYVAL|SEG)? (ID(('(' ')')? | Expression) .

//:::::
ProcParamList   =   ProcParam (DECL_SEPARATOR ProcParam)* .

//:::::
ProcCallOrAssign=   (CALL|CALLS) ID ('(' ProcParamList ')')?
                |   ID ProcParamList?
		|   ID '=' Expression .

//:::::
Assignment      =   LET? Variable '=' Expression
		|   *Variable{function ptr} ProcParamList .

//:::::
AsmBlock        =   ASM Comment? SttSeparator
                        (AsmCode Comment? Newline)+
		    END ASM .
//:::::
AsmCode         =   (Text !(Comment|NEWLINE))*


//:::::
Expression      =   LogExpression .

//:::::
LogExpression   =   NOT? RelExpression ( (AND | OR | XOR | EQV | IMP) NOT? RelExpression )* .

//:::::
RelExpression   =   AddExpression ( (EQ | GT | LT | NE | LE | GE) AddExpression )* .

//:::::
AddExpression   =   ShiftExpression ( ('+' | '-') ShiftExpression )* .

//:::::
ShiftExpression =   ModExpression ( (SHL | SHR) ModExpression )* .

//:::::
ModExpression   =   IntDivExpression ( MOD IntDivExpression )* .

//:::::
IntDivExpression=   MultExpression ( '\' MultExpression )* .

//:::::
MultExpression  =   ExpExpression ( ('*' | '/') ExpExpression )* .

//:::::
ExpExpression   =   NegExpression ( '^' NegExpression )* .

//:::::
NegExpression   =   ('-'|'+') ExpExpression
                |   AddrOfExpression .

//:::::
AddrOfExpression =  VARPTR '(' Variable ')'
		|   PROCPTR '(' Proc ('()')? ')'
 		|   '@' (Proc ('()')? | Variable)
		|   SADD '(' Variable{str}|Const{str}|Literal{str} ')'
                |   TypeConvExpr .

//:::::
TypeConvExpr	=   (C### '(' expression ')')
		|   ParentExpression

//:::::
ParentExpression=   '(' Expression ')'
                |   Atom .

//:::::
Atom            =   Constant | Function | QuirkFunction | Variable | Literal .

//:::::
Constant        =   ID .

//:::::
Literal		=   NUM_LITERAL | STR_LITERAL .

//:::::
FuncParam       =   (BYVAL|BYREF|SEG)? (ID(('(' ')')? | Expression) .

//:::::
FuncParamList   =    FuncParam (DECL_SEPARATOR FuncParam)* .

//:::::
Function        =   ID ('(' ProcParamList ')')? .


//:::::
TypeField       =   ArrayIdx? ('.' ID ArrayIdx?)*

//:::::
DerefFields	=   (FIELDDEREF DREF* TypeField)* .

//:::::
ArrayIdx        =   '(' Expression (DECL_SEPARATOR Expression)* ')' .

//:::::
Variable        =   DREF* ID ArrayIdx? Params? ((TypeField|DerefField) FieldIdx? Params?)*


//:::::
CompoundStmt	=   IfStatement
		|   ForStatement
	        |   DoStatement
		|   WhileStatement
		|   SelectStatement
		|   ExitStatement
		|   ContinueStatement
		|   EndStatement
		|   CompoundStmtElm .

//:::::
SingleIfStatement=  !(COMMENT|NEWLINE) SimpleStatement*)
                    (ELSE SimpleStatement*)?

//:::::
BlockIfStatement=   (COMMENT|NEWLINE)
			SimpleLine*
		    (ELSEIF Expression THEN Comment? SttSeparator
			SimpleLine*)?
                    (ELSE Comment? SttSeparator
			SimpleLine*)?
		    END IF.

//:::::
IfStatement	=   IF Expression THEN (BlockIfStatement | SingleIfStatement) .

//:::::
ForStatement    =   FOR ID '=' Expression TO Expression (STEP Expression)? Comment? SttSeparator
			SimpleLine*
		    NEXT ID? .

//:::::
DoStatement     =   DO ((WHILE | UNTIL) Expression)? Comment? SttSeparator
		    	SimpleLine*
		    LOOP ((WHILE | UNTIL) Expression)? .

//:::::
WhileStatement  =   WHILE Expression Comment? SttSeparator
		    	SimpleLine*
		    WEND .

//:::::
SelectStatement =   SELECT CASE Expression Comment? SttSeparator
					   cComment? cSttSeparator? CaseStatement*
				      END SELECT .

//:::::
CaseStatement   =   CASE (ELSE | (CaseExpression (COMMA CaseExpression)*)) Comment? SttSeparator
			SimpleLine*.

//:::::
CaseExpression  =   (Expression (TO Expression)?)?
				  |   (IS REL_OP Expression)? .

//:::::
ExitStatement	=   EXIT (FOR | DO | WHILE | SUB | FUNCTION)

//:::::
ContinueStatement=  CONTINUE (FOR | DO | WHILE)

//:::::
EndStatement	=   END (Expression | Keyword | ) .

//:::::
CompoundStmtElm =   WEND | LOOP | NEXT | CASE | ELSE | ELSEIF .


//:::::
SubOrFuncHeader =   ID (STDCALL|CDECL|PASCAL) ('(' Arguments? ')')? (AS SymbolType)? STATIC?

//:::::
ProcStatement	=   (PRIVATE|PUBLIC)? ((SUB SubDecl) | (FUNCTION FuncDecl)) Comment? SttSeparator
		    	SimpleLine*
		    END (SUB | FUNCTION)


//:::::
GotoStmt   	=   GOTO LABEL
		|   GOSUB LABEL
		|   RETURN LABEL? .

//:::::
ArrayStmt   	=   ERASE ID
		|   SWAP Variable, Variable .

//:::::
MidStmt   	=   MID '(' Expression{str}, Expression{int} (',' Expression{int}) ')' '=' Expression{str} .

//:::::
DataStmt   	=   RESTORE LABEL?
		|   READ Variable{int|flt|str} (',' Variable{int|flt|str})*
		|   DATA literal|constant (',' literal|constant)*

//:::::
PrintStmt	=   (PRINT|'?') ('#' Expression)? USING Expression{str}? (Expression? ';'|"," )*

//:::::
WriteStmt	=   WRITE ('#' Expression)? (Expression? "," )*

//:::::
LineInputStmt	=   LINE INPUT ';'? ('#' Expression| Expression{str}) (','|';') Variable .

//:::::
InputStmt	=   INPUT ';'? (('#' Expression| STRING_LIT) (','|';'))? Variable (',' Variable)*

//:::::
ViewStmt	=   VIEW (PRINT (Expression TO Expression)?)
		|   (SCREEN Expression...) .

//:::::
PokeStmt 	=   (POKE|POKES|POKEI) Expression, Expression .

//:::::
FileStmt	=   OPEN Expression{str} (FOR (INPUT|OUTPUT|BINARY|RANDOM|APPEND))? (ACCESS Expression)?
		    	(SHARED|LOCK (READ|WRITE|READ WRITE))? AS '#'? Expression (LEN '=' Expression)?
		|   CLOSE '#'? Expression
		|   SEEK '#'? Expression ',' Expression
		|   PUT '#' Expression ',' Expression? ',' Expression{str|int|float}
		|   GET '#' Expression ',' Expression? ',' Expression{str|int|float}
		|   (LOCK|UNLOCK) '#'? Expression, Expression (TO Expression)? .

//:::::
OnStmt 		=   ON (Keyword | Expression) (GOTO|GOSUB) Label .

//:::::
ErrorStmt 	=   ERROR Expression .

//:::::
QuirkStmt   	=   GotoStmt
		|   ArrayStmt
		|   PrintStmt
		|   MidStmt
		|   DataStmt
		|   etc .


//:::::
ArrayFunct 	=   (LBOUND|UBOUND) '(' ID (',' Expression)? ')' .

//:::::
StringFunct	=   STR$ '(' Expression{int|float|double} ')'
		|   INSTR '(' ((Expression{int} ',' Expression ',' Expression)|
			      (Expression{str} ',' Expression)) ')'
		|   MID$ '(' Expression ',' Expression (',' Expression)? ')'
 		|   STRING$ '(' Expression ',' Expression{int|str} ')' .

//:::::
MathFunct	=   ABS '(' Expression ')'
 		|   SGN '(' Expression ')'
		|   FIX '(' Expression ')'
		|   INT '(' Expression ')'
		|   LEN '(' Expression | data type ')' .

//:::::
PeekFunct 	=   (PEEK|PEEKS|PEEKI) '(' Expression ')' .

FileFunct 	=   SEEK '(' Expression ')'
		|   INPUT '(' Expr, (',' '#'? Expr)? ')'.

//:::::
QuirkFunction   =   ArrayFunct
		|   StringFunct
		|   etc.

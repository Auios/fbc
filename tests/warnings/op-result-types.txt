
----------------------------------------------------------------------
integers/floats:
----------------------------------------------------------------------


-----b -----------------------------------------------------


math ops (b, b):

b + b =max =
INTEGER
b -b =max =
INTEGER
b * b =max =
INTEGER
b / b =float =
DOUBLE
b ^ b =float =
DOUBLE
b \ b =non-float =
INTEGER
b mod b =non-float =
INTEGER

bitops (b, b):

b shl b =non-float =
INTEGER
b shr b =non-float =
INTEGER
b and b =non-float =
INTEGER
b or b =non-float =
INTEGER
b xor b =non-float =
INTEGER
b eqv b =non-float =
INTEGER
b imp b =non-float =
INTEGER

relational ops (b, b):

b =b =integer =
INTEGER
b >b =integer =
INTEGER
b <b =integer =
INTEGER
b <> b =integer =
INTEGER
b <= b =integer =
INTEGER
b >= b =integer =
INTEGER
b andalso b =integer =
INTEGER
b orelse b =integer =
INTEGER

math ops (b, ub):

b + ub =max =
INTEGER
b -ub =max =
INTEGER
b * ub =max =
INTEGER
b / ub =float =
DOUBLE
b ^ ub =float =
DOUBLE
b \ ub =non-float =
INTEGER
b mod ub =non-float =
INTEGER

bitops (b, ub):

b shl ub =non-float =
INTEGER
b shr ub =non-float =
INTEGER
b and ub =non-float =
INTEGER
b or ub =non-float =
INTEGER
b xor ub =non-float =
INTEGER
b eqv ub =non-float =
INTEGER
b imp ub =non-float =
INTEGER

relational ops (b, ub):

b =ub =integer =
INTEGER
b >ub =integer =
INTEGER
b <ub =integer =
INTEGER
b <> ub =integer =
INTEGER
b <= ub =integer =
INTEGER
b >= ub =integer =
INTEGER
b andalso ub =integer =
INTEGER
b orelse ub =integer =
INTEGER

math ops (b, sh):

b + sh =max =
INTEGER
b -sh =max =
INTEGER
b * sh =max =
INTEGER
b / sh =float =
DOUBLE
b ^ sh =float =
DOUBLE
b \ sh =non-float =
INTEGER
b mod sh =non-float =
INTEGER

bitops (b, sh):

b shl sh =non-float =
INTEGER
b shr sh =non-float =
INTEGER
b and sh =non-float =
INTEGER
b or sh =non-float =
INTEGER
b xor sh =non-float =
INTEGER
b eqv sh =non-float =
INTEGER
b imp sh =non-float =
INTEGER

relational ops (b, sh):

b =sh =integer =
INTEGER
b >sh =integer =
INTEGER
b <sh =integer =
INTEGER
b <> sh =integer =
INTEGER
b <= sh =integer =
INTEGER
b >= sh =integer =
INTEGER
b andalso sh =integer =
INTEGER
b orelse sh =integer =
INTEGER

math ops (b, ush):

b + ush =max =
INTEGER
b -ush =max =
INTEGER
b * ush =max =
INTEGER
b / ush =float =
DOUBLE
b ^ ush =float =
DOUBLE
b \ ush =non-float =
INTEGER
b mod ush =non-float =
INTEGER

bitops (b, ush):

b shl ush =non-float =
INTEGER
b shr ush =non-float =
INTEGER
b and ush =non-float =
INTEGER
b or ush =non-float =
INTEGER
b xor ush =non-float =
INTEGER
b eqv ush =non-float =
INTEGER
b imp ush =non-float =
INTEGER

relational ops (b, ush):

b =ush =integer =
INTEGER
b >ush =integer =
INTEGER
b <ush =integer =
INTEGER
b <> ush =integer =
INTEGER
b <= ush =integer =
INTEGER
b >= ush =integer =
INTEGER
b andalso ush =integer =
INTEGER
b orelse ush =integer =
INTEGER

math ops (b, i):

b + i =max =
INTEGER
b -i =max =
INTEGER
b * i =max =
INTEGER
b / i =float =
DOUBLE
b ^ i =float =
DOUBLE
b \ i =non-float =
INTEGER
b mod i =non-float =
INTEGER

bitops (b, i):

b shl i =non-float =
INTEGER
b shr i =non-float =
INTEGER
b and i =non-float =
INTEGER
b or i =non-float =
INTEGER
b xor i =non-float =
INTEGER
b eqv i =non-float =
INTEGER
b imp i =non-float =
INTEGER

relational ops (b, i):

b =i =integer =
INTEGER
b >i =integer =
INTEGER
b <i =integer =
INTEGER
b <> i =integer =
INTEGER
b <= i =integer =
INTEGER
b >= i =integer =
INTEGER
b andalso i =integer =
INTEGER
b orelse i =integer =
INTEGER

math ops (b, ui):

b + ui =max =
INTEGER
b -ui =max =
INTEGER
b * ui =max =
INTEGER
b / ui =float =
DOUBLE
b ^ ui =float =
DOUBLE
b \ ui =non-float =
INTEGER
b mod ui =non-float =
INTEGER

bitops (b, ui):

b shl ui =non-float =
INTEGER
b shr ui =non-float =
INTEGER
b and ui =non-float =
INTEGER
b or ui =non-float =
INTEGER
b xor ui =non-float =
INTEGER
b eqv ui =non-float =
INTEGER
b imp ui =non-float =
INTEGER

relational ops (b, ui):

b =ui =integer =
INTEGER
b >ui =integer =
INTEGER
b <ui =integer =
INTEGER
b <> ui =integer =
INTEGER
b <= ui =integer =
INTEGER
b >= ui =integer =
INTEGER
b andalso ui =integer =
INTEGER
b orelse ui =integer =
INTEGER

math ops (b, l):

b + l =max =
INTEGER
b -l =max =
INTEGER
b * l =max =
INTEGER
b / l =float =
DOUBLE
b ^ l =float =
DOUBLE
b \ l =non-float =
INTEGER
b mod l =non-float =
INTEGER

bitops (b, l):

b shl l =non-float =
INTEGER
b shr l =non-float =
INTEGER
b and l =non-float =
INTEGER
b or l =non-float =
INTEGER
b xor l =non-float =
INTEGER
b eqv l =non-float =
INTEGER
b imp l =non-float =
INTEGER

relational ops (b, l):

b =l =integer =
INTEGER
b >l =integer =
INTEGER
b <l =integer =
INTEGER
b <> l =integer =
INTEGER
b <= l =integer =
INTEGER
b >= l =integer =
INTEGER
b andalso l =integer =
INTEGER
b orelse l =integer =
INTEGER

math ops (b, ul):

b + ul =max =
INTEGER
b -ul =max =
INTEGER
b * ul =max =
INTEGER
b / ul =float =
DOUBLE
b ^ ul =float =
DOUBLE
b \ ul =non-float =
INTEGER
b mod ul =non-float =
INTEGER

bitops (b, ul):

b shl ul =non-float =
INTEGER
b shr ul =non-float =
INTEGER
b and ul =non-float =
INTEGER
b or ul =non-float =
INTEGER
b xor ul =non-float =
INTEGER
b eqv ul =non-float =
INTEGER
b imp ul =non-float =
INTEGER

relational ops (b, ul):

b =ul =integer =
INTEGER
b >ul =integer =
INTEGER
b <ul =integer =
INTEGER
b <> ul =integer =
INTEGER
b <= ul =integer =
INTEGER
b >= ul =integer =
INTEGER
b andalso ul =integer =
INTEGER
b orelse ul =integer =
INTEGER

math ops (b, ll):

b + ll =max =
LONGINT
b -ll =max =
LONGINT
b * ll =max =
LONGINT
b / ll =float =
DOUBLE
b ^ ll =float =
DOUBLE
b \ ll =non-float =
LONGINT
b mod ll =non-float =
LONGINT

bitops (b, ll):

b shl ll =non-float =
LONGINT
b shr ll =non-float =
LONGINT
b and ll =non-float =
LONGINT
b or ll =non-float =
LONGINT
b xor ll =non-float =
LONGINT
b eqv ll =non-float =
LONGINT
b imp ll =non-float =
LONGINT

relational ops (b, ll):

b =ll =integer =
INTEGER
b >ll =integer =
INTEGER
b <ll =integer =
INTEGER
b <> ll =integer =
INTEGER
b <= ll =integer =
INTEGER
b >= ll =integer =
INTEGER
b andalso ll =integer =
INTEGER
b orelse ll =integer =
INTEGER

math ops (b, ull):

b + ull =max =
ULONGINT
b -ull =max =
ULONGINT
b * ull =max =
ULONGINT
b / ull =float =
DOUBLE
b ^ ull =float =
DOUBLE
b \ ull =non-float =
ULONGINT
b mod ull =non-float =
ULONGINT

bitops (b, ull):

b shl ull =non-float =
ULONGINT
b shr ull =non-float =
ULONGINT
b and ull =non-float =
ULONGINT
b or ull =non-float =
ULONGINT
b xor ull =non-float =
ULONGINT
b eqv ull =non-float =
ULONGINT
b imp ull =non-float =
ULONGINT

relational ops (b, ull):

b =ull =integer =
INTEGER
b >ull =integer =
INTEGER
b <ull =integer =
INTEGER
b <> ull =integer =
INTEGER
b <= ull =integer =
INTEGER
b >= ull =integer =
INTEGER
b andalso ull =integer =
INTEGER
b orelse ull =integer =
INTEGER

math ops (b, enum1a):

b + enum1a =max =
ENUM1
b -enum1a =max =
ENUM1
b * enum1a =max =
ENUM1
b / enum1a =float =
DOUBLE
b ^ enum1a =float =
DOUBLE
b \ enum1a =non-float =
ENUM1
b mod enum1a =non-float =
ENUM1

bitops (b, enum1a):

b shl enum1a =non-float =
ENUM1
b shr enum1a =non-float =
ENUM1
b and enum1a =non-float =
ENUM1
b or enum1a =non-float =
ENUM1
b xor enum1a =non-float =
ENUM1
b eqv enum1a =non-float =
ENUM1
b imp enum1a =non-float =
ENUM1

relational ops (b, enum1a):

b =enum1a =integer =
INTEGER
b >enum1a =integer =
INTEGER
b <enum1a =integer =
INTEGER
b <> enum1a =integer =
INTEGER
b <= enum1a =integer =
INTEGER
b >= enum1a =integer =
INTEGER
b andalso enum1a =integer =
INTEGER
b orelse enum1a =integer =
INTEGER

math ops (b, b):

b + b =max =
INTEGER
b -b =max =
INTEGER
b * b =max =
INTEGER
b / b =float =
DOUBLE
b ^ b =float =
DOUBLE
b \ b =non-float =
INTEGER
b mod b =non-float =
INTEGER

bitops (b, b):

b shl b =non-float =
INTEGER
b shr b =non-float =
INTEGER
b and b =non-float =
INTEGER
b or b =non-float =
INTEGER
b xor b =non-float =
INTEGER
b eqv b =non-float =
INTEGER
b imp b =non-float =
INTEGER

relational ops (b, b):

b =b =integer =
INTEGER
b >b =integer =
INTEGER
b <b =integer =
INTEGER
b <> b =integer =
INTEGER
b <= b =integer =
INTEGER
b >= b =integer =
INTEGER
b andalso b =integer =
INTEGER
b orelse b =integer =
INTEGER

math ops (ub, b):

ub + b =max =
UINTEGER
ub -b =max =
UINTEGER
ub * b =max =
UINTEGER
ub / b =float =
DOUBLE
ub ^ b =float =
DOUBLE
ub \ b =non-float =
UINTEGER
ub mod b =non-float =
UINTEGER

bitops (ub, b):

ub shl b =non-float =
UINTEGER
ub shr b =non-float =
UINTEGER
ub and b =non-float =
UINTEGER
ub or b =non-float =
UINTEGER
ub xor b =non-float =
UINTEGER
ub eqv b =non-float =
UINTEGER
ub imp b =non-float =
UINTEGER

relational ops (ub, b):

ub =b =integer =
INTEGER
ub >b =integer =
INTEGER
ub <b =integer =
INTEGER
ub <> b =integer =
INTEGER
ub <= b =integer =
INTEGER
ub >= b =integer =
INTEGER
ub andalso b =integer =
INTEGER
ub orelse b =integer =
INTEGER

math ops (sh, b):

sh + b =max =
INTEGER
sh -b =max =
INTEGER
sh * b =max =
INTEGER
sh / b =float =
DOUBLE
sh ^ b =float =
DOUBLE
sh \ b =non-float =
INTEGER
sh mod b =non-float =
INTEGER

bitops (sh, b):

sh shl b =non-float =
INTEGER
sh shr b =non-float =
INTEGER
sh and b =non-float =
INTEGER
sh or b =non-float =
INTEGER
sh xor b =non-float =
INTEGER
sh eqv b =non-float =
INTEGER
sh imp b =non-float =
INTEGER

relational ops (sh, b):

sh =b =integer =
INTEGER
sh >b =integer =
INTEGER
sh <b =integer =
INTEGER
sh <> b =integer =
INTEGER
sh <= b =integer =
INTEGER
sh >= b =integer =
INTEGER
sh andalso b =integer =
INTEGER
sh orelse b =integer =
INTEGER

math ops (ush, b):

ush + b =max =
INTEGER
ush -b =max =
INTEGER
ush * b =max =
INTEGER
ush / b =float =
DOUBLE
ush ^ b =float =
DOUBLE
ush \ b =non-float =
INTEGER
ush mod b =non-float =
INTEGER

bitops (ush, b):

ush shl b =non-float =
INTEGER
ush shr b =non-float =
INTEGER
ush and b =non-float =
INTEGER
ush or b =non-float =
INTEGER
ush xor b =non-float =
INTEGER
ush eqv b =non-float =
INTEGER
ush imp b =non-float =
INTEGER

relational ops (ush, b):

ush =b =integer =
INTEGER
ush >b =integer =
INTEGER
ush <b =integer =
INTEGER
ush <> b =integer =
INTEGER
ush <= b =integer =
INTEGER
ush >= b =integer =
INTEGER
ush andalso b =integer =
INTEGER
ush orelse b =integer =
INTEGER

math ops (i, b):

i + b =max =
INTEGER
i -b =max =
INTEGER
i * b =max =
INTEGER
i / b =float =
DOUBLE
i ^ b =float =
DOUBLE
i \ b =non-float =
INTEGER
i mod b =non-float =
INTEGER

bitops (i, b):

i shl b =non-float =
INTEGER
i shr b =non-float =
INTEGER
i and b =non-float =
INTEGER
i or b =non-float =
INTEGER
i xor b =non-float =
INTEGER
i eqv b =non-float =
INTEGER
i imp b =non-float =
INTEGER

relational ops (i, b):

i =b =integer =
INTEGER
i >b =integer =
INTEGER
i <b =integer =
INTEGER
i <> b =integer =
INTEGER
i <= b =integer =
INTEGER
i >= b =integer =
INTEGER
i andalso b =integer =
INTEGER
i orelse b =integer =
INTEGER

math ops (ui, b):

ui + b =max =
UINTEGER
ui -b =max =
UINTEGER
ui * b =max =
UINTEGER
ui / b =float =
DOUBLE
ui ^ b =float =
DOUBLE
ui \ b =non-float =
UINTEGER
ui mod b =non-float =
UINTEGER

bitops (ui, b):

ui shl b =non-float =
UINTEGER
ui shr b =non-float =
UINTEGER
ui and b =non-float =
UINTEGER
ui or b =non-float =
UINTEGER
ui xor b =non-float =
UINTEGER
ui eqv b =non-float =
UINTEGER
ui imp b =non-float =
UINTEGER

relational ops (ui, b):

ui =b =integer =
INTEGER
ui >b =integer =
INTEGER
ui <b =integer =
INTEGER
ui <> b =integer =
INTEGER
ui <= b =integer =
INTEGER
ui >= b =integer =
INTEGER
ui andalso b =integer =
INTEGER
ui orelse b =integer =
INTEGER

math ops (l, b):

l + b =max =
LONG
l -b =max =
LONG
l * b =max =
LONG
l / b =float =
DOUBLE
l ^ b =float =
DOUBLE
l \ b =non-float =
LONG
l mod b =non-float =
LONG

bitops (l, b):

l shl b =non-float =
LONG
l shr b =non-float =
LONG
l and b =non-float =
LONG
l or b =non-float =
LONG
l xor b =non-float =
LONG
l eqv b =non-float =
LONG
l imp b =non-float =
LONG

relational ops (l, b):

l =b =integer =
INTEGER
l >b =integer =
INTEGER
l <b =integer =
INTEGER
l <> b =integer =
INTEGER
l <= b =integer =
INTEGER
l >= b =integer =
INTEGER
l andalso b =integer =
INTEGER
l orelse b =integer =
INTEGER

math ops (ul, b):

ul + b =max =
ULONG
ul -b =max =
ULONG
ul * b =max =
ULONG
ul / b =float =
DOUBLE
ul ^ b =float =
DOUBLE
ul \ b =non-float =
ULONG
ul mod b =non-float =
ULONG

bitops (ul, b):

ul shl b =non-float =
ULONG
ul shr b =non-float =
ULONG
ul and b =non-float =
ULONG
ul or b =non-float =
ULONG
ul xor b =non-float =
ULONG
ul eqv b =non-float =
ULONG
ul imp b =non-float =
ULONG

relational ops (ul, b):

ul =b =integer =
INTEGER
ul >b =integer =
INTEGER
ul <b =integer =
INTEGER
ul <> b =integer =
INTEGER
ul <= b =integer =
INTEGER
ul >= b =integer =
INTEGER
ul andalso b =integer =
INTEGER
ul orelse b =integer =
INTEGER

math ops (ll, b):

ll + b =max =
LONGINT
ll -b =max =
LONGINT
ll * b =max =
LONGINT
ll / b =float =
DOUBLE
ll ^ b =float =
DOUBLE
ll \ b =non-float =
LONGINT
ll mod b =non-float =
LONGINT

bitops (ll, b):

ll shl b =non-float =
LONGINT
ll shr b =non-float =
LONGINT
ll and b =non-float =
LONGINT
ll or b =non-float =
LONGINT
ll xor b =non-float =
LONGINT
ll eqv b =non-float =
LONGINT
ll imp b =non-float =
LONGINT

relational ops (ll, b):

ll =b =integer =
INTEGER
ll >b =integer =
INTEGER
ll <b =integer =
INTEGER
ll <> b =integer =
INTEGER
ll <= b =integer =
INTEGER
ll >= b =integer =
INTEGER
ll andalso b =integer =
INTEGER
ll orelse b =integer =
INTEGER

math ops (ull, b):

ull + b =max =
ULONGINT
ull -b =max =
ULONGINT
ull * b =max =
ULONGINT
ull / b =float =
DOUBLE
ull ^ b =float =
DOUBLE
ull \ b =non-float =
ULONGINT
ull mod b =non-float =
ULONGINT

bitops (ull, b):

ull shl b =non-float =
ULONGINT
ull shr b =non-float =
ULONGINT
ull and b =non-float =
ULONGINT
ull or b =non-float =
ULONGINT
ull xor b =non-float =
ULONGINT
ull eqv b =non-float =
ULONGINT
ull imp b =non-float =
ULONGINT

relational ops (ull, b):

ull =b =integer =
INTEGER
ull >b =integer =
INTEGER
ull <b =integer =
INTEGER
ull <> b =integer =
INTEGER
ull <= b =integer =
INTEGER
ull >= b =integer =
INTEGER
ull andalso b =integer =
INTEGER
ull orelse b =integer =
INTEGER

math ops (enum1a, b):

enum1a + b =max =
ENUM1
enum1a -b =max =
ENUM1
enum1a * b =max =
ENUM1
enum1a / b =float =
DOUBLE
enum1a ^ b =float =
DOUBLE
enum1a \ b =non-float =
ENUM1
enum1a mod b =non-float =
ENUM1

bitops (enum1a, b):

enum1a shl b =non-float =
ENUM1
enum1a shr b =non-float =
ENUM1
enum1a and b =non-float =
ENUM1
enum1a or b =non-float =
ENUM1
enum1a xor b =non-float =
ENUM1
enum1a eqv b =non-float =
ENUM1
enum1a imp b =non-float =
ENUM1

relational ops (enum1a, b):

enum1a =b =integer =
INTEGER
enum1a >b =integer =
INTEGER
enum1a <b =integer =
INTEGER
enum1a <> b =integer =
INTEGER
enum1a <= b =integer =
INTEGER
enum1a >= b =integer =
INTEGER
enum1a andalso b =integer =
INTEGER
enum1a orelse b =integer =
INTEGER

math ops (b, f):

b + f =max =
SINGLE
b -f =max =
SINGLE
b * f =max =
SINGLE
b / f =float =
DOUBLE
b ^ f =float =
DOUBLE
b \ f =non-float =
INTEGER
b mod f =non-float =
INTEGER

bitops (b, f):

b shl f =non-float =
INTEGER
b shr f =non-float =
INTEGER
b and f =non-float =
INTEGER
b or f =non-float =
INTEGER
b xor f =non-float =
INTEGER
b eqv f =non-float =
INTEGER
b imp f =non-float =
INTEGER

relational ops (b, f):

b =f =integer =
INTEGER
b >f =integer =
INTEGER
b <f =integer =
INTEGER
b <> f =integer =
INTEGER
b <= f =integer =
INTEGER
b >= f =integer =
INTEGER
b andalso f =integer =
INTEGER
b orelse f =integer =
INTEGER

math ops (b, d):

b + d =max =
DOUBLE
b -d =max =
DOUBLE
b * d =max =
DOUBLE
b / d =float =
DOUBLE
b ^ d =float =
DOUBLE
b \ d =non-float =
INTEGER
b mod d =non-float =
INTEGER

bitops (b, d):

b shl d =non-float =
INTEGER
b shr d =non-float =
INTEGER
b and d =non-float =
INTEGER
b or d =non-float =
INTEGER
b xor d =non-float =
INTEGER
b eqv d =non-float =
INTEGER
b imp d =non-float =
INTEGER

relational ops (b, d):

b =d =integer =
INTEGER
b >d =integer =
INTEGER
b <d =integer =
INTEGER
b <> d =integer =
INTEGER
b <= d =integer =
INTEGER
b >= d =integer =
INTEGER
b andalso d =integer =
INTEGER
b orelse d =integer =
INTEGER

math ops (f, b):

f + b =max =
SINGLE
f -b =max =
SINGLE
f * b =max =
SINGLE
f / b =float =
DOUBLE
f ^ b =float =
DOUBLE
f \ b =non-float =
INTEGER
f mod b =non-float =
INTEGER

bitops (f, b):

f shl b =non-float =
INTEGER
f shr b =non-float =
INTEGER
f and b =non-float =
INTEGER
f or b =non-float =
INTEGER
f xor b =non-float =
INTEGER
f eqv b =non-float =
INTEGER
f imp b =non-float =
INTEGER

relational ops (f, b):

f =b =integer =
INTEGER
f >b =integer =
INTEGER
f <b =integer =
INTEGER
f <> b =integer =
INTEGER
f <= b =integer =
INTEGER
f >= b =integer =
INTEGER
f andalso b =integer =
INTEGER
f orelse b =integer =
INTEGER

math ops (d, b):

d + b =max =
DOUBLE
d -b =max =
DOUBLE
d * b =max =
DOUBLE
d / b =float =
DOUBLE
d ^ b =float =
DOUBLE
d \ b =non-float =
INTEGER
d mod b =non-float =
INTEGER

bitops (d, b):

d shl b =non-float =
INTEGER
d shr b =non-float =
INTEGER
d and b =non-float =
INTEGER
d or b =non-float =
INTEGER
d xor b =non-float =
INTEGER
d eqv b =non-float =
INTEGER
d imp b =non-float =
INTEGER

relational ops (d, b):

d =b =integer =
INTEGER
d >b =integer =
INTEGER
d <b =integer =
INTEGER
d <> b =integer =
INTEGER
d <= b =integer =
INTEGER
d >= b =integer =
INTEGER
d andalso b =integer =
INTEGER
d orelse b =integer =
INTEGER

-----ub -----------------------------------------------------


math ops (ub, b):

ub + b =max =
UINTEGER
ub -b =max =
UINTEGER
ub * b =max =
UINTEGER
ub / b =float =
DOUBLE
ub ^ b =float =
DOUBLE
ub \ b =non-float =
UINTEGER
ub mod b =non-float =
UINTEGER

bitops (ub, b):

ub shl b =non-float =
UINTEGER
ub shr b =non-float =
UINTEGER
ub and b =non-float =
UINTEGER
ub or b =non-float =
UINTEGER
ub xor b =non-float =
UINTEGER
ub eqv b =non-float =
UINTEGER
ub imp b =non-float =
UINTEGER

relational ops (ub, b):

ub =b =integer =
INTEGER
ub >b =integer =
INTEGER
ub <b =integer =
INTEGER
ub <> b =integer =
INTEGER
ub <= b =integer =
INTEGER
ub >= b =integer =
INTEGER
ub andalso b =integer =
INTEGER
ub orelse b =integer =
INTEGER

math ops (ub, ub):

ub + ub =max =
UINTEGER
ub -ub =max =
UINTEGER
ub * ub =max =
UINTEGER
ub / ub =float =
DOUBLE
ub ^ ub =float =
DOUBLE
ub \ ub =non-float =
UINTEGER
ub mod ub =non-float =
UINTEGER

bitops (ub, ub):

ub shl ub =non-float =
UINTEGER
ub shr ub =non-float =
UINTEGER
ub and ub =non-float =
UINTEGER
ub or ub =non-float =
UINTEGER
ub xor ub =non-float =
UINTEGER
ub eqv ub =non-float =
UINTEGER
ub imp ub =non-float =
UINTEGER

relational ops (ub, ub):

ub =ub =integer =
INTEGER
ub >ub =integer =
INTEGER
ub <ub =integer =
INTEGER
ub <> ub =integer =
INTEGER
ub <= ub =integer =
INTEGER
ub >= ub =integer =
INTEGER
ub andalso ub =integer =
INTEGER
ub orelse ub =integer =
INTEGER

math ops (ub, sh):

ub + sh =max =
UINTEGER
ub -sh =max =
UINTEGER
ub * sh =max =
UINTEGER
ub / sh =float =
DOUBLE
ub ^ sh =float =
DOUBLE
ub \ sh =non-float =
UINTEGER
ub mod sh =non-float =
UINTEGER

bitops (ub, sh):

ub shl sh =non-float =
UINTEGER
ub shr sh =non-float =
UINTEGER
ub and sh =non-float =
UINTEGER
ub or sh =non-float =
UINTEGER
ub xor sh =non-float =
UINTEGER
ub eqv sh =non-float =
UINTEGER
ub imp sh =non-float =
UINTEGER

relational ops (ub, sh):

ub =sh =integer =
INTEGER
ub >sh =integer =
INTEGER
ub <sh =integer =
INTEGER
ub <> sh =integer =
INTEGER
ub <= sh =integer =
INTEGER
ub >= sh =integer =
INTEGER
ub andalso sh =integer =
INTEGER
ub orelse sh =integer =
INTEGER

math ops (ub, ush):

ub + ush =max =
UINTEGER
ub -ush =max =
UINTEGER
ub * ush =max =
UINTEGER
ub / ush =float =
DOUBLE
ub ^ ush =float =
DOUBLE
ub \ ush =non-float =
UINTEGER
ub mod ush =non-float =
UINTEGER

bitops (ub, ush):

ub shl ush =non-float =
UINTEGER
ub shr ush =non-float =
UINTEGER
ub and ush =non-float =
UINTEGER
ub or ush =non-float =
UINTEGER
ub xor ush =non-float =
UINTEGER
ub eqv ush =non-float =
UINTEGER
ub imp ush =non-float =
UINTEGER

relational ops (ub, ush):

ub =ush =integer =
INTEGER
ub >ush =integer =
INTEGER
ub <ush =integer =
INTEGER
ub <> ush =integer =
INTEGER
ub <= ush =integer =
INTEGER
ub >= ush =integer =
INTEGER
ub andalso ush =integer =
INTEGER
ub orelse ush =integer =
INTEGER

math ops (ub, i):

ub + i =max =
UINTEGER
ub -i =max =
UINTEGER
ub * i =max =
UINTEGER
ub / i =float =
DOUBLE
ub ^ i =float =
DOUBLE
ub \ i =non-float =
UINTEGER
ub mod i =non-float =
UINTEGER

bitops (ub, i):

ub shl i =non-float =
UINTEGER
ub shr i =non-float =
UINTEGER
ub and i =non-float =
UINTEGER
ub or i =non-float =
UINTEGER
ub xor i =non-float =
UINTEGER
ub eqv i =non-float =
UINTEGER
ub imp i =non-float =
UINTEGER

relational ops (ub, i):

ub =i =integer =
INTEGER
ub >i =integer =
INTEGER
ub <i =integer =
INTEGER
ub <> i =integer =
INTEGER
ub <= i =integer =
INTEGER
ub >= i =integer =
INTEGER
ub andalso i =integer =
INTEGER
ub orelse i =integer =
INTEGER

math ops (ub, ui):

ub + ui =max =
UINTEGER
ub -ui =max =
UINTEGER
ub * ui =max =
UINTEGER
ub / ui =float =
DOUBLE
ub ^ ui =float =
DOUBLE
ub \ ui =non-float =
UINTEGER
ub mod ui =non-float =
UINTEGER

bitops (ub, ui):

ub shl ui =non-float =
UINTEGER
ub shr ui =non-float =
UINTEGER
ub and ui =non-float =
UINTEGER
ub or ui =non-float =
UINTEGER
ub xor ui =non-float =
UINTEGER
ub eqv ui =non-float =
UINTEGER
ub imp ui =non-float =
UINTEGER

relational ops (ub, ui):

ub =ui =integer =
INTEGER
ub >ui =integer =
INTEGER
ub <ui =integer =
INTEGER
ub <> ui =integer =
INTEGER
ub <= ui =integer =
INTEGER
ub >= ui =integer =
INTEGER
ub andalso ui =integer =
INTEGER
ub orelse ui =integer =
INTEGER

math ops (ub, l):

ub + l =max =
UINTEGER
ub -l =max =
UINTEGER
ub * l =max =
UINTEGER
ub / l =float =
DOUBLE
ub ^ l =float =
DOUBLE
ub \ l =non-float =
UINTEGER
ub mod l =non-float =
UINTEGER

bitops (ub, l):

ub shl l =non-float =
UINTEGER
ub shr l =non-float =
UINTEGER
ub and l =non-float =
UINTEGER
ub or l =non-float =
UINTEGER
ub xor l =non-float =
UINTEGER
ub eqv l =non-float =
UINTEGER
ub imp l =non-float =
UINTEGER

relational ops (ub, l):

ub =l =integer =
INTEGER
ub >l =integer =
INTEGER
ub <l =integer =
INTEGER
ub <> l =integer =
INTEGER
ub <= l =integer =
INTEGER
ub >= l =integer =
INTEGER
ub andalso l =integer =
INTEGER
ub orelse l =integer =
INTEGER

math ops (ub, ul):

ub + ul =max =
UINTEGER
ub -ul =max =
UINTEGER
ub * ul =max =
UINTEGER
ub / ul =float =
DOUBLE
ub ^ ul =float =
DOUBLE
ub \ ul =non-float =
UINTEGER
ub mod ul =non-float =
UINTEGER

bitops (ub, ul):

ub shl ul =non-float =
UINTEGER
ub shr ul =non-float =
UINTEGER
ub and ul =non-float =
UINTEGER
ub or ul =non-float =
UINTEGER
ub xor ul =non-float =
UINTEGER
ub eqv ul =non-float =
UINTEGER
ub imp ul =non-float =
UINTEGER

relational ops (ub, ul):

ub =ul =integer =
INTEGER
ub >ul =integer =
INTEGER
ub <ul =integer =
INTEGER
ub <> ul =integer =
INTEGER
ub <= ul =integer =
INTEGER
ub >= ul =integer =
INTEGER
ub andalso ul =integer =
INTEGER
ub orelse ul =integer =
INTEGER

math ops (ub, ll):

ub + ll =max =
LONGINT
ub -ll =max =
LONGINT
ub * ll =max =
LONGINT
ub / ll =float =
DOUBLE
ub ^ ll =float =
DOUBLE
ub \ ll =non-float =
LONGINT
ub mod ll =non-float =
LONGINT

bitops (ub, ll):

ub shl ll =non-float =
LONGINT
ub shr ll =non-float =
LONGINT
ub and ll =non-float =
LONGINT
ub or ll =non-float =
LONGINT
ub xor ll =non-float =
LONGINT
ub eqv ll =non-float =
LONGINT
ub imp ll =non-float =
LONGINT

relational ops (ub, ll):

ub =ll =integer =
INTEGER
ub >ll =integer =
INTEGER
ub <ll =integer =
INTEGER
ub <> ll =integer =
INTEGER
ub <= ll =integer =
INTEGER
ub >= ll =integer =
INTEGER
ub andalso ll =integer =
INTEGER
ub orelse ll =integer =
INTEGER

math ops (ub, ull):

ub + ull =max =
ULONGINT
ub -ull =max =
ULONGINT
ub * ull =max =
ULONGINT
ub / ull =float =
DOUBLE
ub ^ ull =float =
DOUBLE
ub \ ull =non-float =
ULONGINT
ub mod ull =non-float =
ULONGINT

bitops (ub, ull):

ub shl ull =non-float =
ULONGINT
ub shr ull =non-float =
ULONGINT
ub and ull =non-float =
ULONGINT
ub or ull =non-float =
ULONGINT
ub xor ull =non-float =
ULONGINT
ub eqv ull =non-float =
ULONGINT
ub imp ull =non-float =
ULONGINT

relational ops (ub, ull):

ub =ull =integer =
INTEGER
ub >ull =integer =
INTEGER
ub <ull =integer =
INTEGER
ub <> ull =integer =
INTEGER
ub <= ull =integer =
INTEGER
ub >= ull =integer =
INTEGER
ub andalso ull =integer =
INTEGER
ub orelse ull =integer =
INTEGER

math ops (ub, enum1a):

ub + enum1a =max =
ENUM1
ub -enum1a =max =
ENUM1
ub * enum1a =max =
ENUM1
ub / enum1a =float =
DOUBLE
ub ^ enum1a =float =
DOUBLE
ub \ enum1a =non-float =
ENUM1
ub mod enum1a =non-float =
ENUM1

bitops (ub, enum1a):

ub shl enum1a =non-float =
ENUM1
ub shr enum1a =non-float =
ENUM1
ub and enum1a =non-float =
ENUM1
ub or enum1a =non-float =
ENUM1
ub xor enum1a =non-float =
ENUM1
ub eqv enum1a =non-float =
ENUM1
ub imp enum1a =non-float =
ENUM1

relational ops (ub, enum1a):

ub =enum1a =integer =
INTEGER
ub >enum1a =integer =
INTEGER
ub <enum1a =integer =
INTEGER
ub <> enum1a =integer =
INTEGER
ub <= enum1a =integer =
INTEGER
ub >= enum1a =integer =
INTEGER
ub andalso enum1a =integer =
INTEGER
ub orelse enum1a =integer =
INTEGER

math ops (b, ub):

b + ub =max =
INTEGER
b -ub =max =
INTEGER
b * ub =max =
INTEGER
b / ub =float =
DOUBLE
b ^ ub =float =
DOUBLE
b \ ub =non-float =
INTEGER
b mod ub =non-float =
INTEGER

bitops (b, ub):

b shl ub =non-float =
INTEGER
b shr ub =non-float =
INTEGER
b and ub =non-float =
INTEGER
b or ub =non-float =
INTEGER
b xor ub =non-float =
INTEGER
b eqv ub =non-float =
INTEGER
b imp ub =non-float =
INTEGER

relational ops (b, ub):

b =ub =integer =
INTEGER
b >ub =integer =
INTEGER
b <ub =integer =
INTEGER
b <> ub =integer =
INTEGER
b <= ub =integer =
INTEGER
b >= ub =integer =
INTEGER
b andalso ub =integer =
INTEGER
b orelse ub =integer =
INTEGER

math ops (ub, ub):

ub + ub =max =
UINTEGER
ub -ub =max =
UINTEGER
ub * ub =max =
UINTEGER
ub / ub =float =
DOUBLE
ub ^ ub =float =
DOUBLE
ub \ ub =non-float =
UINTEGER
ub mod ub =non-float =
UINTEGER

bitops (ub, ub):

ub shl ub =non-float =
UINTEGER
ub shr ub =non-float =
UINTEGER
ub and ub =non-float =
UINTEGER
ub or ub =non-float =
UINTEGER
ub xor ub =non-float =
UINTEGER
ub eqv ub =non-float =
UINTEGER
ub imp ub =non-float =
UINTEGER

relational ops (ub, ub):

ub =ub =integer =
INTEGER
ub >ub =integer =
INTEGER
ub <ub =integer =
INTEGER
ub <> ub =integer =
INTEGER
ub <= ub =integer =
INTEGER
ub >= ub =integer =
INTEGER
ub andalso ub =integer =
INTEGER
ub orelse ub =integer =
INTEGER

math ops (sh, ub):

sh + ub =max =
UINTEGER
sh -ub =max =
UINTEGER
sh * ub =max =
UINTEGER
sh / ub =float =
DOUBLE
sh ^ ub =float =
DOUBLE
sh \ ub =non-float =
UINTEGER
sh mod ub =non-float =
UINTEGER

bitops (sh, ub):

sh shl ub =non-float =
UINTEGER
sh shr ub =non-float =
UINTEGER
sh and ub =non-float =
UINTEGER
sh or ub =non-float =
UINTEGER
sh xor ub =non-float =
UINTEGER
sh eqv ub =non-float =
UINTEGER
sh imp ub =non-float =
UINTEGER

relational ops (sh, ub):

sh =ub =integer =
INTEGER
sh >ub =integer =
INTEGER
sh <ub =integer =
INTEGER
sh <> ub =integer =
INTEGER
sh <= ub =integer =
INTEGER
sh >= ub =integer =
INTEGER
sh andalso ub =integer =
INTEGER
sh orelse ub =integer =
INTEGER

math ops (ush, ub):

ush + ub =max =
UINTEGER
ush -ub =max =
UINTEGER
ush * ub =max =
UINTEGER
ush / ub =float =
DOUBLE
ush ^ ub =float =
DOUBLE
ush \ ub =non-float =
UINTEGER
ush mod ub =non-float =
UINTEGER

bitops (ush, ub):

ush shl ub =non-float =
UINTEGER
ush shr ub =non-float =
UINTEGER
ush and ub =non-float =
UINTEGER
ush or ub =non-float =
UINTEGER
ush xor ub =non-float =
UINTEGER
ush eqv ub =non-float =
UINTEGER
ush imp ub =non-float =
UINTEGER

relational ops (ush, ub):

ush =ub =integer =
INTEGER
ush >ub =integer =
INTEGER
ush <ub =integer =
INTEGER
ush <> ub =integer =
INTEGER
ush <= ub =integer =
INTEGER
ush >= ub =integer =
INTEGER
ush andalso ub =integer =
INTEGER
ush orelse ub =integer =
INTEGER

math ops (i, ub):

i + ub =max =
INTEGER
i -ub =max =
INTEGER
i * ub =max =
INTEGER
i / ub =float =
DOUBLE
i ^ ub =float =
DOUBLE
i \ ub =non-float =
INTEGER
i mod ub =non-float =
INTEGER

bitops (i, ub):

i shl ub =non-float =
INTEGER
i shr ub =non-float =
INTEGER
i and ub =non-float =
INTEGER
i or ub =non-float =
INTEGER
i xor ub =non-float =
INTEGER
i eqv ub =non-float =
INTEGER
i imp ub =non-float =
INTEGER

relational ops (i, ub):

i =ub =integer =
INTEGER
i >ub =integer =
INTEGER
i <ub =integer =
INTEGER
i <> ub =integer =
INTEGER
i <= ub =integer =
INTEGER
i >= ub =integer =
INTEGER
i andalso ub =integer =
INTEGER
i orelse ub =integer =
INTEGER

math ops (ui, ub):

ui + ub =max =
UINTEGER
ui -ub =max =
UINTEGER
ui * ub =max =
UINTEGER
ui / ub =float =
DOUBLE
ui ^ ub =float =
DOUBLE
ui \ ub =non-float =
UINTEGER
ui mod ub =non-float =
UINTEGER

bitops (ui, ub):

ui shl ub =non-float =
UINTEGER
ui shr ub =non-float =
UINTEGER
ui and ub =non-float =
UINTEGER
ui or ub =non-float =
UINTEGER
ui xor ub =non-float =
UINTEGER
ui eqv ub =non-float =
UINTEGER
ui imp ub =non-float =
UINTEGER

relational ops (ui, ub):

ui =ub =integer =
INTEGER
ui >ub =integer =
INTEGER
ui <ub =integer =
INTEGER
ui <> ub =integer =
INTEGER
ui <= ub =integer =
INTEGER
ui >= ub =integer =
INTEGER
ui andalso ub =integer =
INTEGER
ui orelse ub =integer =
INTEGER

math ops (l, ub):

l + ub =max =
LONG
l -ub =max =
LONG
l * ub =max =
LONG
l / ub =float =
DOUBLE
l ^ ub =float =
DOUBLE
l \ ub =non-float =
LONG
l mod ub =non-float =
LONG

bitops (l, ub):

l shl ub =non-float =
LONG
l shr ub =non-float =
LONG
l and ub =non-float =
LONG
l or ub =non-float =
LONG
l xor ub =non-float =
LONG
l eqv ub =non-float =
LONG
l imp ub =non-float =
LONG

relational ops (l, ub):

l =ub =integer =
INTEGER
l >ub =integer =
INTEGER
l <ub =integer =
INTEGER
l <> ub =integer =
INTEGER
l <= ub =integer =
INTEGER
l >= ub =integer =
INTEGER
l andalso ub =integer =
INTEGER
l orelse ub =integer =
INTEGER

math ops (ul, ub):

ul + ub =max =
ULONG
ul -ub =max =
ULONG
ul * ub =max =
ULONG
ul / ub =float =
DOUBLE
ul ^ ub =float =
DOUBLE
ul \ ub =non-float =
ULONG
ul mod ub =non-float =
ULONG

bitops (ul, ub):

ul shl ub =non-float =
ULONG
ul shr ub =non-float =
ULONG
ul and ub =non-float =
ULONG
ul or ub =non-float =
ULONG
ul xor ub =non-float =
ULONG
ul eqv ub =non-float =
ULONG
ul imp ub =non-float =
ULONG

relational ops (ul, ub):

ul =ub =integer =
INTEGER
ul >ub =integer =
INTEGER
ul <ub =integer =
INTEGER
ul <> ub =integer =
INTEGER
ul <= ub =integer =
INTEGER
ul >= ub =integer =
INTEGER
ul andalso ub =integer =
INTEGER
ul orelse ub =integer =
INTEGER

math ops (ll, ub):

ll + ub =max =
LONGINT
ll -ub =max =
LONGINT
ll * ub =max =
LONGINT
ll / ub =float =
DOUBLE
ll ^ ub =float =
DOUBLE
ll \ ub =non-float =
LONGINT
ll mod ub =non-float =
LONGINT

bitops (ll, ub):

ll shl ub =non-float =
LONGINT
ll shr ub =non-float =
LONGINT
ll and ub =non-float =
LONGINT
ll or ub =non-float =
LONGINT
ll xor ub =non-float =
LONGINT
ll eqv ub =non-float =
LONGINT
ll imp ub =non-float =
LONGINT

relational ops (ll, ub):

ll =ub =integer =
INTEGER
ll >ub =integer =
INTEGER
ll <ub =integer =
INTEGER
ll <> ub =integer =
INTEGER
ll <= ub =integer =
INTEGER
ll >= ub =integer =
INTEGER
ll andalso ub =integer =
INTEGER
ll orelse ub =integer =
INTEGER

math ops (ull, ub):

ull + ub =max =
ULONGINT
ull -ub =max =
ULONGINT
ull * ub =max =
ULONGINT
ull / ub =float =
DOUBLE
ull ^ ub =float =
DOUBLE
ull \ ub =non-float =
ULONGINT
ull mod ub =non-float =
ULONGINT

bitops (ull, ub):

ull shl ub =non-float =
ULONGINT
ull shr ub =non-float =
ULONGINT
ull and ub =non-float =
ULONGINT
ull or ub =non-float =
ULONGINT
ull xor ub =non-float =
ULONGINT
ull eqv ub =non-float =
ULONGINT
ull imp ub =non-float =
ULONGINT

relational ops (ull, ub):

ull =ub =integer =
INTEGER
ull >ub =integer =
INTEGER
ull <ub =integer =
INTEGER
ull <> ub =integer =
INTEGER
ull <= ub =integer =
INTEGER
ull >= ub =integer =
INTEGER
ull andalso ub =integer =
INTEGER
ull orelse ub =integer =
INTEGER

math ops (enum1a, ub):

enum1a + ub =max =
ENUM1
enum1a -ub =max =
ENUM1
enum1a * ub =max =
ENUM1
enum1a / ub =float =
DOUBLE
enum1a ^ ub =float =
DOUBLE
enum1a \ ub =non-float =
ENUM1
enum1a mod ub =non-float =
ENUM1

bitops (enum1a, ub):

enum1a shl ub =non-float =
ENUM1
enum1a shr ub =non-float =
ENUM1
enum1a and ub =non-float =
ENUM1
enum1a or ub =non-float =
ENUM1
enum1a xor ub =non-float =
ENUM1
enum1a eqv ub =non-float =
ENUM1
enum1a imp ub =non-float =
ENUM1

relational ops (enum1a, ub):

enum1a =ub =integer =
INTEGER
enum1a >ub =integer =
INTEGER
enum1a <ub =integer =
INTEGER
enum1a <> ub =integer =
INTEGER
enum1a <= ub =integer =
INTEGER
enum1a >= ub =integer =
INTEGER
enum1a andalso ub =integer =
INTEGER
enum1a orelse ub =integer =
INTEGER

math ops (ub, f):

ub + f =max =
SINGLE
ub -f =max =
SINGLE
ub * f =max =
SINGLE
ub / f =float =
DOUBLE
ub ^ f =float =
DOUBLE
ub \ f =non-float =
UINTEGER
ub mod f =non-float =
UINTEGER

bitops (ub, f):

ub shl f =non-float =
UINTEGER
ub shr f =non-float =
UINTEGER
ub and f =non-float =
UINTEGER
ub or f =non-float =
UINTEGER
ub xor f =non-float =
UINTEGER
ub eqv f =non-float =
UINTEGER
ub imp f =non-float =
UINTEGER

relational ops (ub, f):

ub =f =integer =
INTEGER
ub >f =integer =
INTEGER
ub <f =integer =
INTEGER
ub <> f =integer =
INTEGER
ub <= f =integer =
INTEGER
ub >= f =integer =
INTEGER
ub andalso f =integer =
INTEGER
ub orelse f =integer =
INTEGER

math ops (ub, d):

ub + d =max =
DOUBLE
ub -d =max =
DOUBLE
ub * d =max =
DOUBLE
ub / d =float =
DOUBLE
ub ^ d =float =
DOUBLE
ub \ d =non-float =
UINTEGER
ub mod d =non-float =
UINTEGER

bitops (ub, d):

ub shl d =non-float =
UINTEGER
ub shr d =non-float =
UINTEGER
ub and d =non-float =
UINTEGER
ub or d =non-float =
UINTEGER
ub xor d =non-float =
UINTEGER
ub eqv d =non-float =
UINTEGER
ub imp d =non-float =
UINTEGER

relational ops (ub, d):

ub =d =integer =
INTEGER
ub >d =integer =
INTEGER
ub <d =integer =
INTEGER
ub <> d =integer =
INTEGER
ub <= d =integer =
INTEGER
ub >= d =integer =
INTEGER
ub andalso d =integer =
INTEGER
ub orelse d =integer =
INTEGER

math ops (f, ub):

f + ub =max =
SINGLE
f -ub =max =
SINGLE
f * ub =max =
SINGLE
f / ub =float =
DOUBLE
f ^ ub =float =
DOUBLE
f \ ub =non-float =
INTEGER
f mod ub =non-float =
INTEGER

bitops (f, ub):

f shl ub =non-float =
INTEGER
f shr ub =non-float =
INTEGER
f and ub =non-float =
INTEGER
f or ub =non-float =
INTEGER
f xor ub =non-float =
INTEGER
f eqv ub =non-float =
INTEGER
f imp ub =non-float =
INTEGER

relational ops (f, ub):

f =ub =integer =
INTEGER
f >ub =integer =
INTEGER
f <ub =integer =
INTEGER
f <> ub =integer =
INTEGER
f <= ub =integer =
INTEGER
f >= ub =integer =
INTEGER
f andalso ub =integer =
INTEGER
f orelse ub =integer =
INTEGER

math ops (d, ub):

d + ub =max =
DOUBLE
d -ub =max =
DOUBLE
d * ub =max =
DOUBLE
d / ub =float =
DOUBLE
d ^ ub =float =
DOUBLE
d \ ub =non-float =
INTEGER
d mod ub =non-float =
INTEGER

bitops (d, ub):

d shl ub =non-float =
INTEGER
d shr ub =non-float =
INTEGER
d and ub =non-float =
INTEGER
d or ub =non-float =
INTEGER
d xor ub =non-float =
INTEGER
d eqv ub =non-float =
INTEGER
d imp ub =non-float =
INTEGER

relational ops (d, ub):

d =ub =integer =
INTEGER
d >ub =integer =
INTEGER
d <ub =integer =
INTEGER
d <> ub =integer =
INTEGER
d <= ub =integer =
INTEGER
d >= ub =integer =
INTEGER
d andalso ub =integer =
INTEGER
d orelse ub =integer =
INTEGER

-----sh -----------------------------------------------------


math ops (sh, b):

sh + b =max =
INTEGER
sh -b =max =
INTEGER
sh * b =max =
INTEGER
sh / b =float =
DOUBLE
sh ^ b =float =
DOUBLE
sh \ b =non-float =
INTEGER
sh mod b =non-float =
INTEGER

bitops (sh, b):

sh shl b =non-float =
INTEGER
sh shr b =non-float =
INTEGER
sh and b =non-float =
INTEGER
sh or b =non-float =
INTEGER
sh xor b =non-float =
INTEGER
sh eqv b =non-float =
INTEGER
sh imp b =non-float =
INTEGER

relational ops (sh, b):

sh =b =integer =
INTEGER
sh >b =integer =
INTEGER
sh <b =integer =
INTEGER
sh <> b =integer =
INTEGER
sh <= b =integer =
INTEGER
sh >= b =integer =
INTEGER
sh andalso b =integer =
INTEGER
sh orelse b =integer =
INTEGER

math ops (sh, ub):

sh + ub =max =
UINTEGER
sh -ub =max =
UINTEGER
sh * ub =max =
UINTEGER
sh / ub =float =
DOUBLE
sh ^ ub =float =
DOUBLE
sh \ ub =non-float =
UINTEGER
sh mod ub =non-float =
UINTEGER

bitops (sh, ub):

sh shl ub =non-float =
UINTEGER
sh shr ub =non-float =
UINTEGER
sh and ub =non-float =
UINTEGER
sh or ub =non-float =
UINTEGER
sh xor ub =non-float =
UINTEGER
sh eqv ub =non-float =
UINTEGER
sh imp ub =non-float =
UINTEGER

relational ops (sh, ub):

sh =ub =integer =
INTEGER
sh >ub =integer =
INTEGER
sh <ub =integer =
INTEGER
sh <> ub =integer =
INTEGER
sh <= ub =integer =
INTEGER
sh >= ub =integer =
INTEGER
sh andalso ub =integer =
INTEGER
sh orelse ub =integer =
INTEGER

math ops (sh, sh):

sh + sh =max =
SHORT
sh -sh =max =
SHORT
sh * sh =max =
SHORT
sh / sh =float =
DOUBLE
sh ^ sh =float =
DOUBLE
sh \ sh =non-float =
SHORT
sh mod sh =non-float =
SHORT

bitops (sh, sh):

sh shl sh =non-float =
SHORT
sh shr sh =non-float =
SHORT
sh and sh =non-float =
SHORT
sh or sh =non-float =
SHORT
sh xor sh =non-float =
SHORT
sh eqv sh =non-float =
SHORT
sh imp sh =non-float =
SHORT

relational ops (sh, sh):

sh =sh =integer =
INTEGER
sh >sh =integer =
INTEGER
sh <sh =integer =
INTEGER
sh <> sh =integer =
INTEGER
sh <= sh =integer =
INTEGER
sh >= sh =integer =
INTEGER
sh andalso sh =integer =
INTEGER
sh orelse sh =integer =
INTEGER

math ops (sh, ush):

sh + ush =max =
SHORT
sh -ush =max =
SHORT
sh * ush =max =
SHORT
sh / ush =float =
DOUBLE
sh ^ ush =float =
DOUBLE
sh \ ush =non-float =
SHORT
sh mod ush =non-float =
SHORT

bitops (sh, ush):

sh shl ush =non-float =
SHORT
sh shr ush =non-float =
SHORT
sh and ush =non-float =
SHORT
sh or ush =non-float =
SHORT
sh xor ush =non-float =
SHORT
sh eqv ush =non-float =
SHORT
sh imp ush =non-float =
SHORT

relational ops (sh, ush):

sh =ush =integer =
INTEGER
sh >ush =integer =
INTEGER
sh <ush =integer =
INTEGER
sh <> ush =integer =
INTEGER
sh <= ush =integer =
INTEGER
sh >= ush =integer =
INTEGER
sh andalso ush =integer =
INTEGER
sh orelse ush =integer =
INTEGER

math ops (sh, i):

sh + i =max =
INTEGER
sh -i =max =
INTEGER
sh * i =max =
INTEGER
sh / i =float =
DOUBLE
sh ^ i =float =
DOUBLE
sh \ i =non-float =
INTEGER
sh mod i =non-float =
INTEGER

bitops (sh, i):

sh shl i =non-float =
INTEGER
sh shr i =non-float =
INTEGER
sh and i =non-float =
INTEGER
sh or i =non-float =
INTEGER
sh xor i =non-float =
INTEGER
sh eqv i =non-float =
INTEGER
sh imp i =non-float =
INTEGER

relational ops (sh, i):

sh =i =integer =
INTEGER
sh >i =integer =
INTEGER
sh <i =integer =
INTEGER
sh <> i =integer =
INTEGER
sh <= i =integer =
INTEGER
sh >= i =integer =
INTEGER
sh andalso i =integer =
INTEGER
sh orelse i =integer =
INTEGER

math ops (sh, ui):

sh + ui =max =
UINTEGER
sh -ui =max =
UINTEGER
sh * ui =max =
UINTEGER
sh / ui =float =
DOUBLE
sh ^ ui =float =
DOUBLE
sh \ ui =non-float =
UINTEGER
sh mod ui =non-float =
UINTEGER

bitops (sh, ui):

sh shl ui =non-float =
UINTEGER
sh shr ui =non-float =
UINTEGER
sh and ui =non-float =
UINTEGER
sh or ui =non-float =
UINTEGER
sh xor ui =non-float =
UINTEGER
sh eqv ui =non-float =
UINTEGER
sh imp ui =non-float =
UINTEGER

relational ops (sh, ui):

sh =ui =integer =
INTEGER
sh >ui =integer =
INTEGER
sh <ui =integer =
INTEGER
sh <> ui =integer =
INTEGER
sh <= ui =integer =
INTEGER
sh >= ui =integer =
INTEGER
sh andalso ui =integer =
INTEGER
sh orelse ui =integer =
INTEGER

math ops (sh, l):

sh + l =max =
LONG
sh -l =max =
LONG
sh * l =max =
LONG
sh / l =float =
DOUBLE
sh ^ l =float =
DOUBLE
sh \ l =non-float =
LONG
sh mod l =non-float =
LONG

bitops (sh, l):

sh shl l =non-float =
LONG
sh shr l =non-float =
LONG
sh and l =non-float =
LONG
sh or l =non-float =
LONG
sh xor l =non-float =
LONG
sh eqv l =non-float =
LONG
sh imp l =non-float =
LONG

relational ops (sh, l):

sh =l =integer =
INTEGER
sh >l =integer =
INTEGER
sh <l =integer =
INTEGER
sh <> l =integer =
INTEGER
sh <= l =integer =
INTEGER
sh >= l =integer =
INTEGER
sh andalso l =integer =
INTEGER
sh orelse l =integer =
INTEGER

math ops (sh, ul):

sh + ul =max =
ULONG
sh -ul =max =
ULONG
sh * ul =max =
ULONG
sh / ul =float =
DOUBLE
sh ^ ul =float =
DOUBLE
sh \ ul =non-float =
ULONG
sh mod ul =non-float =
ULONG

bitops (sh, ul):

sh shl ul =non-float =
ULONG
sh shr ul =non-float =
ULONG
sh and ul =non-float =
ULONG
sh or ul =non-float =
ULONG
sh xor ul =non-float =
ULONG
sh eqv ul =non-float =
ULONG
sh imp ul =non-float =
ULONG

relational ops (sh, ul):

sh =ul =integer =
INTEGER
sh >ul =integer =
INTEGER
sh <ul =integer =
INTEGER
sh <> ul =integer =
INTEGER
sh <= ul =integer =
INTEGER
sh >= ul =integer =
INTEGER
sh andalso ul =integer =
INTEGER
sh orelse ul =integer =
INTEGER

math ops (sh, ll):

sh + ll =max =
LONGINT
sh -ll =max =
LONGINT
sh * ll =max =
LONGINT
sh / ll =float =
DOUBLE
sh ^ ll =float =
DOUBLE
sh \ ll =non-float =
LONGINT
sh mod ll =non-float =
LONGINT

bitops (sh, ll):

sh shl ll =non-float =
LONGINT
sh shr ll =non-float =
LONGINT
sh and ll =non-float =
LONGINT
sh or ll =non-float =
LONGINT
sh xor ll =non-float =
LONGINT
sh eqv ll =non-float =
LONGINT
sh imp ll =non-float =
LONGINT

relational ops (sh, ll):

sh =ll =integer =
INTEGER
sh >ll =integer =
INTEGER
sh <ll =integer =
INTEGER
sh <> ll =integer =
INTEGER
sh <= ll =integer =
INTEGER
sh >= ll =integer =
INTEGER
sh andalso ll =integer =
INTEGER
sh orelse ll =integer =
INTEGER

math ops (sh, ull):

sh + ull =max =
ULONGINT
sh -ull =max =
ULONGINT
sh * ull =max =
ULONGINT
sh / ull =float =
DOUBLE
sh ^ ull =float =
DOUBLE
sh \ ull =non-float =
ULONGINT
sh mod ull =non-float =
ULONGINT

bitops (sh, ull):

sh shl ull =non-float =
ULONGINT
sh shr ull =non-float =
ULONGINT
sh and ull =non-float =
ULONGINT
sh or ull =non-float =
ULONGINT
sh xor ull =non-float =
ULONGINT
sh eqv ull =non-float =
ULONGINT
sh imp ull =non-float =
ULONGINT

relational ops (sh, ull):

sh =ull =integer =
INTEGER
sh >ull =integer =
INTEGER
sh <ull =integer =
INTEGER
sh <> ull =integer =
INTEGER
sh <= ull =integer =
INTEGER
sh >= ull =integer =
INTEGER
sh andalso ull =integer =
INTEGER
sh orelse ull =integer =
INTEGER

math ops (sh, enum1a):

sh + enum1a =max =
ENUM1
sh -enum1a =max =
ENUM1
sh * enum1a =max =
ENUM1
sh / enum1a =float =
DOUBLE
sh ^ enum1a =float =
DOUBLE
sh \ enum1a =non-float =
ENUM1
sh mod enum1a =non-float =
ENUM1

bitops (sh, enum1a):

sh shl enum1a =non-float =
ENUM1
sh shr enum1a =non-float =
ENUM1
sh and enum1a =non-float =
ENUM1
sh or enum1a =non-float =
ENUM1
sh xor enum1a =non-float =
ENUM1
sh eqv enum1a =non-float =
ENUM1
sh imp enum1a =non-float =
ENUM1

relational ops (sh, enum1a):

sh =enum1a =integer =
INTEGER
sh >enum1a =integer =
INTEGER
sh <enum1a =integer =
INTEGER
sh <> enum1a =integer =
INTEGER
sh <= enum1a =integer =
INTEGER
sh >= enum1a =integer =
INTEGER
sh andalso enum1a =integer =
INTEGER
sh orelse enum1a =integer =
INTEGER

math ops (b, sh):

b + sh =max =
INTEGER
b -sh =max =
INTEGER
b * sh =max =
INTEGER
b / sh =float =
DOUBLE
b ^ sh =float =
DOUBLE
b \ sh =non-float =
INTEGER
b mod sh =non-float =
INTEGER

bitops (b, sh):

b shl sh =non-float =
INTEGER
b shr sh =non-float =
INTEGER
b and sh =non-float =
INTEGER
b or sh =non-float =
INTEGER
b xor sh =non-float =
INTEGER
b eqv sh =non-float =
INTEGER
b imp sh =non-float =
INTEGER

relational ops (b, sh):

b =sh =integer =
INTEGER
b >sh =integer =
INTEGER
b <sh =integer =
INTEGER
b <> sh =integer =
INTEGER
b <= sh =integer =
INTEGER
b >= sh =integer =
INTEGER
b andalso sh =integer =
INTEGER
b orelse sh =integer =
INTEGER

math ops (ub, sh):

ub + sh =max =
UINTEGER
ub -sh =max =
UINTEGER
ub * sh =max =
UINTEGER
ub / sh =float =
DOUBLE
ub ^ sh =float =
DOUBLE
ub \ sh =non-float =
UINTEGER
ub mod sh =non-float =
UINTEGER

bitops (ub, sh):

ub shl sh =non-float =
UINTEGER
ub shr sh =non-float =
UINTEGER
ub and sh =non-float =
UINTEGER
ub or sh =non-float =
UINTEGER
ub xor sh =non-float =
UINTEGER
ub eqv sh =non-float =
UINTEGER
ub imp sh =non-float =
UINTEGER

relational ops (ub, sh):

ub =sh =integer =
INTEGER
ub >sh =integer =
INTEGER
ub <sh =integer =
INTEGER
ub <> sh =integer =
INTEGER
ub <= sh =integer =
INTEGER
ub >= sh =integer =
INTEGER
ub andalso sh =integer =
INTEGER
ub orelse sh =integer =
INTEGER

math ops (sh, sh):

sh + sh =max =
SHORT
sh -sh =max =
SHORT
sh * sh =max =
SHORT
sh / sh =float =
DOUBLE
sh ^ sh =float =
DOUBLE
sh \ sh =non-float =
SHORT
sh mod sh =non-float =
SHORT

bitops (sh, sh):

sh shl sh =non-float =
SHORT
sh shr sh =non-float =
SHORT
sh and sh =non-float =
SHORT
sh or sh =non-float =
SHORT
sh xor sh =non-float =
SHORT
sh eqv sh =non-float =
SHORT
sh imp sh =non-float =
SHORT

relational ops (sh, sh):

sh =sh =integer =
INTEGER
sh >sh =integer =
INTEGER
sh <sh =integer =
INTEGER
sh <> sh =integer =
INTEGER
sh <= sh =integer =
INTEGER
sh >= sh =integer =
INTEGER
sh andalso sh =integer =
INTEGER
sh orelse sh =integer =
INTEGER

math ops (ush, sh):

ush + sh =max =
USHORT
ush -sh =max =
USHORT
ush * sh =max =
USHORT
ush / sh =float =
DOUBLE
ush ^ sh =float =
DOUBLE
ush \ sh =non-float =
USHORT
ush mod sh =non-float =
USHORT

bitops (ush, sh):

ush shl sh =non-float =
USHORT
ush shr sh =non-float =
USHORT
ush and sh =non-float =
USHORT
ush or sh =non-float =
USHORT
ush xor sh =non-float =
USHORT
ush eqv sh =non-float =
USHORT
ush imp sh =non-float =
USHORT

relational ops (ush, sh):

ush =sh =integer =
INTEGER
ush >sh =integer =
INTEGER
ush <sh =integer =
INTEGER
ush <> sh =integer =
INTEGER
ush <= sh =integer =
INTEGER
ush >= sh =integer =
INTEGER
ush andalso sh =integer =
INTEGER
ush orelse sh =integer =
INTEGER

math ops (i, sh):

i + sh =max =
INTEGER
i -sh =max =
INTEGER
i * sh =max =
INTEGER
i / sh =float =
DOUBLE
i ^ sh =float =
DOUBLE
i \ sh =non-float =
INTEGER
i mod sh =non-float =
INTEGER

bitops (i, sh):

i shl sh =non-float =
INTEGER
i shr sh =non-float =
INTEGER
i and sh =non-float =
INTEGER
i or sh =non-float =
INTEGER
i xor sh =non-float =
INTEGER
i eqv sh =non-float =
INTEGER
i imp sh =non-float =
INTEGER

relational ops (i, sh):

i =sh =integer =
INTEGER
i >sh =integer =
INTEGER
i <sh =integer =
INTEGER
i <> sh =integer =
INTEGER
i <= sh =integer =
INTEGER
i >= sh =integer =
INTEGER
i andalso sh =integer =
INTEGER
i orelse sh =integer =
INTEGER

math ops (ui, sh):

ui + sh =max =
UINTEGER
ui -sh =max =
UINTEGER
ui * sh =max =
UINTEGER
ui / sh =float =
DOUBLE
ui ^ sh =float =
DOUBLE
ui \ sh =non-float =
UINTEGER
ui mod sh =non-float =
UINTEGER

bitops (ui, sh):

ui shl sh =non-float =
UINTEGER
ui shr sh =non-float =
UINTEGER
ui and sh =non-float =
UINTEGER
ui or sh =non-float =
UINTEGER
ui xor sh =non-float =
UINTEGER
ui eqv sh =non-float =
UINTEGER
ui imp sh =non-float =
UINTEGER

relational ops (ui, sh):

ui =sh =integer =
INTEGER
ui >sh =integer =
INTEGER
ui <sh =integer =
INTEGER
ui <> sh =integer =
INTEGER
ui <= sh =integer =
INTEGER
ui >= sh =integer =
INTEGER
ui andalso sh =integer =
INTEGER
ui orelse sh =integer =
INTEGER

math ops (l, sh):

l + sh =max =
LONG
l -sh =max =
LONG
l * sh =max =
LONG
l / sh =float =
DOUBLE
l ^ sh =float =
DOUBLE
l \ sh =non-float =
LONG
l mod sh =non-float =
LONG

bitops (l, sh):

l shl sh =non-float =
LONG
l shr sh =non-float =
LONG
l and sh =non-float =
LONG
l or sh =non-float =
LONG
l xor sh =non-float =
LONG
l eqv sh =non-float =
LONG
l imp sh =non-float =
LONG

relational ops (l, sh):

l =sh =integer =
INTEGER
l >sh =integer =
INTEGER
l <sh =integer =
INTEGER
l <> sh =integer =
INTEGER
l <= sh =integer =
INTEGER
l >= sh =integer =
INTEGER
l andalso sh =integer =
INTEGER
l orelse sh =integer =
INTEGER

math ops (ul, sh):

ul + sh =max =
ULONG
ul -sh =max =
ULONG
ul * sh =max =
ULONG
ul / sh =float =
DOUBLE
ul ^ sh =float =
DOUBLE
ul \ sh =non-float =
ULONG
ul mod sh =non-float =
ULONG

bitops (ul, sh):

ul shl sh =non-float =
ULONG
ul shr sh =non-float =
ULONG
ul and sh =non-float =
ULONG
ul or sh =non-float =
ULONG
ul xor sh =non-float =
ULONG
ul eqv sh =non-float =
ULONG
ul imp sh =non-float =
ULONG

relational ops (ul, sh):

ul =sh =integer =
INTEGER
ul >sh =integer =
INTEGER
ul <sh =integer =
INTEGER
ul <> sh =integer =
INTEGER
ul <= sh =integer =
INTEGER
ul >= sh =integer =
INTEGER
ul andalso sh =integer =
INTEGER
ul orelse sh =integer =
INTEGER

math ops (ll, sh):

ll + sh =max =
LONGINT
ll -sh =max =
LONGINT
ll * sh =max =
LONGINT
ll / sh =float =
DOUBLE
ll ^ sh =float =
DOUBLE
ll \ sh =non-float =
LONGINT
ll mod sh =non-float =
LONGINT

bitops (ll, sh):

ll shl sh =non-float =
LONGINT
ll shr sh =non-float =
LONGINT
ll and sh =non-float =
LONGINT
ll or sh =non-float =
LONGINT
ll xor sh =non-float =
LONGINT
ll eqv sh =non-float =
LONGINT
ll imp sh =non-float =
LONGINT

relational ops (ll, sh):

ll =sh =integer =
INTEGER
ll >sh =integer =
INTEGER
ll <sh =integer =
INTEGER
ll <> sh =integer =
INTEGER
ll <= sh =integer =
INTEGER
ll >= sh =integer =
INTEGER
ll andalso sh =integer =
INTEGER
ll orelse sh =integer =
INTEGER

math ops (ull, sh):

ull + sh =max =
ULONGINT
ull -sh =max =
ULONGINT
ull * sh =max =
ULONGINT
ull / sh =float =
DOUBLE
ull ^ sh =float =
DOUBLE
ull \ sh =non-float =
ULONGINT
ull mod sh =non-float =
ULONGINT

bitops (ull, sh):

ull shl sh =non-float =
ULONGINT
ull shr sh =non-float =
ULONGINT
ull and sh =non-float =
ULONGINT
ull or sh =non-float =
ULONGINT
ull xor sh =non-float =
ULONGINT
ull eqv sh =non-float =
ULONGINT
ull imp sh =non-float =
ULONGINT

relational ops (ull, sh):

ull =sh =integer =
INTEGER
ull >sh =integer =
INTEGER
ull <sh =integer =
INTEGER
ull <> sh =integer =
INTEGER
ull <= sh =integer =
INTEGER
ull >= sh =integer =
INTEGER
ull andalso sh =integer =
INTEGER
ull orelse sh =integer =
INTEGER

math ops (enum1a, sh):

enum1a + sh =max =
ENUM1
enum1a -sh =max =
ENUM1
enum1a * sh =max =
ENUM1
enum1a / sh =float =
DOUBLE
enum1a ^ sh =float =
DOUBLE
enum1a \ sh =non-float =
ENUM1
enum1a mod sh =non-float =
ENUM1

bitops (enum1a, sh):

enum1a shl sh =non-float =
ENUM1
enum1a shr sh =non-float =
ENUM1
enum1a and sh =non-float =
ENUM1
enum1a or sh =non-float =
ENUM1
enum1a xor sh =non-float =
ENUM1
enum1a eqv sh =non-float =
ENUM1
enum1a imp sh =non-float =
ENUM1

relational ops (enum1a, sh):

enum1a =sh =integer =
INTEGER
enum1a >sh =integer =
INTEGER
enum1a <sh =integer =
INTEGER
enum1a <> sh =integer =
INTEGER
enum1a <= sh =integer =
INTEGER
enum1a >= sh =integer =
INTEGER
enum1a andalso sh =integer =
INTEGER
enum1a orelse sh =integer =
INTEGER

math ops (sh, f):

sh + f =max =
SINGLE
sh -f =max =
SINGLE
sh * f =max =
SINGLE
sh / f =float =
DOUBLE
sh ^ f =float =
DOUBLE
sh \ f =non-float =
INTEGER
sh mod f =non-float =
INTEGER

bitops (sh, f):

sh shl f =non-float =
INTEGER
sh shr f =non-float =
INTEGER
sh and f =non-float =
INTEGER
sh or f =non-float =
INTEGER
sh xor f =non-float =
INTEGER
sh eqv f =non-float =
INTEGER
sh imp f =non-float =
INTEGER

relational ops (sh, f):

sh =f =integer =
INTEGER
sh >f =integer =
INTEGER
sh <f =integer =
INTEGER
sh <> f =integer =
INTEGER
sh <= f =integer =
INTEGER
sh >= f =integer =
INTEGER
sh andalso f =integer =
INTEGER
sh orelse f =integer =
INTEGER

math ops (sh, d):

sh + d =max =
DOUBLE
sh -d =max =
DOUBLE
sh * d =max =
DOUBLE
sh / d =float =
DOUBLE
sh ^ d =float =
DOUBLE
sh \ d =non-float =
INTEGER
sh mod d =non-float =
INTEGER

bitops (sh, d):

sh shl d =non-float =
INTEGER
sh shr d =non-float =
INTEGER
sh and d =non-float =
INTEGER
sh or d =non-float =
INTEGER
sh xor d =non-float =
INTEGER
sh eqv d =non-float =
INTEGER
sh imp d =non-float =
INTEGER

relational ops (sh, d):

sh =d =integer =
INTEGER
sh >d =integer =
INTEGER
sh <d =integer =
INTEGER
sh <> d =integer =
INTEGER
sh <= d =integer =
INTEGER
sh >= d =integer =
INTEGER
sh andalso d =integer =
INTEGER
sh orelse d =integer =
INTEGER

math ops (f, sh):

f + sh =max =
SINGLE
f -sh =max =
SINGLE
f * sh =max =
SINGLE
f / sh =float =
DOUBLE
f ^ sh =float =
DOUBLE
f \ sh =non-float =
INTEGER
f mod sh =non-float =
INTEGER

bitops (f, sh):

f shl sh =non-float =
INTEGER
f shr sh =non-float =
INTEGER
f and sh =non-float =
INTEGER
f or sh =non-float =
INTEGER
f xor sh =non-float =
INTEGER
f eqv sh =non-float =
INTEGER
f imp sh =non-float =
INTEGER

relational ops (f, sh):

f =sh =integer =
INTEGER
f >sh =integer =
INTEGER
f <sh =integer =
INTEGER
f <> sh =integer =
INTEGER
f <= sh =integer =
INTEGER
f >= sh =integer =
INTEGER
f andalso sh =integer =
INTEGER
f orelse sh =integer =
INTEGER

math ops (d, sh):

d + sh =max =
DOUBLE
d -sh =max =
DOUBLE
d * sh =max =
DOUBLE
d / sh =float =
DOUBLE
d ^ sh =float =
DOUBLE
d \ sh =non-float =
INTEGER
d mod sh =non-float =
INTEGER

bitops (d, sh):

d shl sh =non-float =
INTEGER
d shr sh =non-float =
INTEGER
d and sh =non-float =
INTEGER
d or sh =non-float =
INTEGER
d xor sh =non-float =
INTEGER
d eqv sh =non-float =
INTEGER
d imp sh =non-float =
INTEGER

relational ops (d, sh):

d =sh =integer =
INTEGER
d >sh =integer =
INTEGER
d <sh =integer =
INTEGER
d <> sh =integer =
INTEGER
d <= sh =integer =
INTEGER
d >= sh =integer =
INTEGER
d andalso sh =integer =
INTEGER
d orelse sh =integer =
INTEGER

-----ush -----------------------------------------------------


math ops (ush, b):

ush + b =max =
INTEGER
ush -b =max =
INTEGER
ush * b =max =
INTEGER
ush / b =float =
DOUBLE
ush ^ b =float =
DOUBLE
ush \ b =non-float =
INTEGER
ush mod b =non-float =
INTEGER

bitops (ush, b):

ush shl b =non-float =
INTEGER
ush shr b =non-float =
INTEGER
ush and b =non-float =
INTEGER
ush or b =non-float =
INTEGER
ush xor b =non-float =
INTEGER
ush eqv b =non-float =
INTEGER
ush imp b =non-float =
INTEGER

relational ops (ush, b):

ush =b =integer =
INTEGER
ush >b =integer =
INTEGER
ush <b =integer =
INTEGER
ush <> b =integer =
INTEGER
ush <= b =integer =
INTEGER
ush >= b =integer =
INTEGER
ush andalso b =integer =
INTEGER
ush orelse b =integer =
INTEGER

math ops (ush, ub):

ush + ub =max =
UINTEGER
ush -ub =max =
UINTEGER
ush * ub =max =
UINTEGER
ush / ub =float =
DOUBLE
ush ^ ub =float =
DOUBLE
ush \ ub =non-float =
UINTEGER
ush mod ub =non-float =
UINTEGER

bitops (ush, ub):

ush shl ub =non-float =
UINTEGER
ush shr ub =non-float =
UINTEGER
ush and ub =non-float =
UINTEGER
ush or ub =non-float =
UINTEGER
ush xor ub =non-float =
UINTEGER
ush eqv ub =non-float =
UINTEGER
ush imp ub =non-float =
UINTEGER

relational ops (ush, ub):

ush =ub =integer =
INTEGER
ush >ub =integer =
INTEGER
ush <ub =integer =
INTEGER
ush <> ub =integer =
INTEGER
ush <= ub =integer =
INTEGER
ush >= ub =integer =
INTEGER
ush andalso ub =integer =
INTEGER
ush orelse ub =integer =
INTEGER

math ops (ush, sh):

ush + sh =max =
USHORT
ush -sh =max =
USHORT
ush * sh =max =
USHORT
ush / sh =float =
DOUBLE
ush ^ sh =float =
DOUBLE
ush \ sh =non-float =
USHORT
ush mod sh =non-float =
USHORT

bitops (ush, sh):

ush shl sh =non-float =
USHORT
ush shr sh =non-float =
USHORT
ush and sh =non-float =
USHORT
ush or sh =non-float =
USHORT
ush xor sh =non-float =
USHORT
ush eqv sh =non-float =
USHORT
ush imp sh =non-float =
USHORT

relational ops (ush, sh):

ush =sh =integer =
INTEGER
ush >sh =integer =
INTEGER
ush <sh =integer =
INTEGER
ush <> sh =integer =
INTEGER
ush <= sh =integer =
INTEGER
ush >= sh =integer =
INTEGER
ush andalso sh =integer =
INTEGER
ush orelse sh =integer =
INTEGER

math ops (ush, ush):

ush + ush =max =
USHORT
ush -ush =max =
USHORT
ush * ush =max =
USHORT
ush / ush =float =
DOUBLE
ush ^ ush =float =
DOUBLE
ush \ ush =non-float =
USHORT
ush mod ush =non-float =
USHORT

bitops (ush, ush):

ush shl ush =non-float =
USHORT
ush shr ush =non-float =
USHORT
ush and ush =non-float =
USHORT
ush or ush =non-float =
USHORT
ush xor ush =non-float =
USHORT
ush eqv ush =non-float =
USHORT
ush imp ush =non-float =
USHORT

relational ops (ush, ush):

ush =ush =integer =
INTEGER
ush >ush =integer =
INTEGER
ush <ush =integer =
INTEGER
ush <> ush =integer =
INTEGER
ush <= ush =integer =
INTEGER
ush >= ush =integer =
INTEGER
ush andalso ush =integer =
INTEGER
ush orelse ush =integer =
INTEGER

math ops (ush, i):

ush + i =max =
INTEGER
ush -i =max =
INTEGER
ush * i =max =
INTEGER
ush / i =float =
DOUBLE
ush ^ i =float =
DOUBLE
ush \ i =non-float =
INTEGER
ush mod i =non-float =
INTEGER

bitops (ush, i):

ush shl i =non-float =
INTEGER
ush shr i =non-float =
INTEGER
ush and i =non-float =
INTEGER
ush or i =non-float =
INTEGER
ush xor i =non-float =
INTEGER
ush eqv i =non-float =
INTEGER
ush imp i =non-float =
INTEGER

relational ops (ush, i):

ush =i =integer =
INTEGER
ush >i =integer =
INTEGER
ush <i =integer =
INTEGER
ush <> i =integer =
INTEGER
ush <= i =integer =
INTEGER
ush >= i =integer =
INTEGER
ush andalso i =integer =
INTEGER
ush orelse i =integer =
INTEGER

math ops (ush, ui):

ush + ui =max =
UINTEGER
ush -ui =max =
UINTEGER
ush * ui =max =
UINTEGER
ush / ui =float =
DOUBLE
ush ^ ui =float =
DOUBLE
ush \ ui =non-float =
UINTEGER
ush mod ui =non-float =
UINTEGER

bitops (ush, ui):

ush shl ui =non-float =
UINTEGER
ush shr ui =non-float =
UINTEGER
ush and ui =non-float =
UINTEGER
ush or ui =non-float =
UINTEGER
ush xor ui =non-float =
UINTEGER
ush eqv ui =non-float =
UINTEGER
ush imp ui =non-float =
UINTEGER

relational ops (ush, ui):

ush =ui =integer =
INTEGER
ush >ui =integer =
INTEGER
ush <ui =integer =
INTEGER
ush <> ui =integer =
INTEGER
ush <= ui =integer =
INTEGER
ush >= ui =integer =
INTEGER
ush andalso ui =integer =
INTEGER
ush orelse ui =integer =
INTEGER

math ops (ush, l):

ush + l =max =
LONG
ush -l =max =
LONG
ush * l =max =
LONG
ush / l =float =
DOUBLE
ush ^ l =float =
DOUBLE
ush \ l =non-float =
LONG
ush mod l =non-float =
LONG

bitops (ush, l):

ush shl l =non-float =
LONG
ush shr l =non-float =
LONG
ush and l =non-float =
LONG
ush or l =non-float =
LONG
ush xor l =non-float =
LONG
ush eqv l =non-float =
LONG
ush imp l =non-float =
LONG

relational ops (ush, l):

ush =l =integer =
INTEGER
ush >l =integer =
INTEGER
ush <l =integer =
INTEGER
ush <> l =integer =
INTEGER
ush <= l =integer =
INTEGER
ush >= l =integer =
INTEGER
ush andalso l =integer =
INTEGER
ush orelse l =integer =
INTEGER

math ops (ush, ul):

ush + ul =max =
ULONG
ush -ul =max =
ULONG
ush * ul =max =
ULONG
ush / ul =float =
DOUBLE
ush ^ ul =float =
DOUBLE
ush \ ul =non-float =
ULONG
ush mod ul =non-float =
ULONG

bitops (ush, ul):

ush shl ul =non-float =
ULONG
ush shr ul =non-float =
ULONG
ush and ul =non-float =
ULONG
ush or ul =non-float =
ULONG
ush xor ul =non-float =
ULONG
ush eqv ul =non-float =
ULONG
ush imp ul =non-float =
ULONG

relational ops (ush, ul):

ush =ul =integer =
INTEGER
ush >ul =integer =
INTEGER
ush <ul =integer =
INTEGER
ush <> ul =integer =
INTEGER
ush <= ul =integer =
INTEGER
ush >= ul =integer =
INTEGER
ush andalso ul =integer =
INTEGER
ush orelse ul =integer =
INTEGER

math ops (ush, ll):

ush + ll =max =
LONGINT
ush -ll =max =
LONGINT
ush * ll =max =
LONGINT
ush / ll =float =
DOUBLE
ush ^ ll =float =
DOUBLE
ush \ ll =non-float =
LONGINT
ush mod ll =non-float =
LONGINT

bitops (ush, ll):

ush shl ll =non-float =
LONGINT
ush shr ll =non-float =
LONGINT
ush and ll =non-float =
LONGINT
ush or ll =non-float =
LONGINT
ush xor ll =non-float =
LONGINT
ush eqv ll =non-float =
LONGINT
ush imp ll =non-float =
LONGINT

relational ops (ush, ll):

ush =ll =integer =
INTEGER
ush >ll =integer =
INTEGER
ush <ll =integer =
INTEGER
ush <> ll =integer =
INTEGER
ush <= ll =integer =
INTEGER
ush >= ll =integer =
INTEGER
ush andalso ll =integer =
INTEGER
ush orelse ll =integer =
INTEGER

math ops (ush, ull):

ush + ull =max =
ULONGINT
ush -ull =max =
ULONGINT
ush * ull =max =
ULONGINT
ush / ull =float =
DOUBLE
ush ^ ull =float =
DOUBLE
ush \ ull =non-float =
ULONGINT
ush mod ull =non-float =
ULONGINT

bitops (ush, ull):

ush shl ull =non-float =
ULONGINT
ush shr ull =non-float =
ULONGINT
ush and ull =non-float =
ULONGINT
ush or ull =non-float =
ULONGINT
ush xor ull =non-float =
ULONGINT
ush eqv ull =non-float =
ULONGINT
ush imp ull =non-float =
ULONGINT

relational ops (ush, ull):

ush =ull =integer =
INTEGER
ush >ull =integer =
INTEGER
ush <ull =integer =
INTEGER
ush <> ull =integer =
INTEGER
ush <= ull =integer =
INTEGER
ush >= ull =integer =
INTEGER
ush andalso ull =integer =
INTEGER
ush orelse ull =integer =
INTEGER

math ops (ush, enum1a):

ush + enum1a =max =
ENUM1
ush -enum1a =max =
ENUM1
ush * enum1a =max =
ENUM1
ush / enum1a =float =
DOUBLE
ush ^ enum1a =float =
DOUBLE
ush \ enum1a =non-float =
ENUM1
ush mod enum1a =non-float =
ENUM1

bitops (ush, enum1a):

ush shl enum1a =non-float =
ENUM1
ush shr enum1a =non-float =
ENUM1
ush and enum1a =non-float =
ENUM1
ush or enum1a =non-float =
ENUM1
ush xor enum1a =non-float =
ENUM1
ush eqv enum1a =non-float =
ENUM1
ush imp enum1a =non-float =
ENUM1

relational ops (ush, enum1a):

ush =enum1a =integer =
INTEGER
ush >enum1a =integer =
INTEGER
ush <enum1a =integer =
INTEGER
ush <> enum1a =integer =
INTEGER
ush <= enum1a =integer =
INTEGER
ush >= enum1a =integer =
INTEGER
ush andalso enum1a =integer =
INTEGER
ush orelse enum1a =integer =
INTEGER

math ops (b, ush):

b + ush =max =
INTEGER
b -ush =max =
INTEGER
b * ush =max =
INTEGER
b / ush =float =
DOUBLE
b ^ ush =float =
DOUBLE
b \ ush =non-float =
INTEGER
b mod ush =non-float =
INTEGER

bitops (b, ush):

b shl ush =non-float =
INTEGER
b shr ush =non-float =
INTEGER
b and ush =non-float =
INTEGER
b or ush =non-float =
INTEGER
b xor ush =non-float =
INTEGER
b eqv ush =non-float =
INTEGER
b imp ush =non-float =
INTEGER

relational ops (b, ush):

b =ush =integer =
INTEGER
b >ush =integer =
INTEGER
b <ush =integer =
INTEGER
b <> ush =integer =
INTEGER
b <= ush =integer =
INTEGER
b >= ush =integer =
INTEGER
b andalso ush =integer =
INTEGER
b orelse ush =integer =
INTEGER

math ops (ub, ush):

ub + ush =max =
UINTEGER
ub -ush =max =
UINTEGER
ub * ush =max =
UINTEGER
ub / ush =float =
DOUBLE
ub ^ ush =float =
DOUBLE
ub \ ush =non-float =
UINTEGER
ub mod ush =non-float =
UINTEGER

bitops (ub, ush):

ub shl ush =non-float =
UINTEGER
ub shr ush =non-float =
UINTEGER
ub and ush =non-float =
UINTEGER
ub or ush =non-float =
UINTEGER
ub xor ush =non-float =
UINTEGER
ub eqv ush =non-float =
UINTEGER
ub imp ush =non-float =
UINTEGER

relational ops (ub, ush):

ub =ush =integer =
INTEGER
ub >ush =integer =
INTEGER
ub <ush =integer =
INTEGER
ub <> ush =integer =
INTEGER
ub <= ush =integer =
INTEGER
ub >= ush =integer =
INTEGER
ub andalso ush =integer =
INTEGER
ub orelse ush =integer =
INTEGER

math ops (sh, ush):

sh + ush =max =
SHORT
sh -ush =max =
SHORT
sh * ush =max =
SHORT
sh / ush =float =
DOUBLE
sh ^ ush =float =
DOUBLE
sh \ ush =non-float =
SHORT
sh mod ush =non-float =
SHORT

bitops (sh, ush):

sh shl ush =non-float =
SHORT
sh shr ush =non-float =
SHORT
sh and ush =non-float =
SHORT
sh or ush =non-float =
SHORT
sh xor ush =non-float =
SHORT
sh eqv ush =non-float =
SHORT
sh imp ush =non-float =
SHORT

relational ops (sh, ush):

sh =ush =integer =
INTEGER
sh >ush =integer =
INTEGER
sh <ush =integer =
INTEGER
sh <> ush =integer =
INTEGER
sh <= ush =integer =
INTEGER
sh >= ush =integer =
INTEGER
sh andalso ush =integer =
INTEGER
sh orelse ush =integer =
INTEGER

math ops (ush, ush):

ush + ush =max =
USHORT
ush -ush =max =
USHORT
ush * ush =max =
USHORT
ush / ush =float =
DOUBLE
ush ^ ush =float =
DOUBLE
ush \ ush =non-float =
USHORT
ush mod ush =non-float =
USHORT

bitops (ush, ush):

ush shl ush =non-float =
USHORT
ush shr ush =non-float =
USHORT
ush and ush =non-float =
USHORT
ush or ush =non-float =
USHORT
ush xor ush =non-float =
USHORT
ush eqv ush =non-float =
USHORT
ush imp ush =non-float =
USHORT

relational ops (ush, ush):

ush =ush =integer =
INTEGER
ush >ush =integer =
INTEGER
ush <ush =integer =
INTEGER
ush <> ush =integer =
INTEGER
ush <= ush =integer =
INTEGER
ush >= ush =integer =
INTEGER
ush andalso ush =integer =
INTEGER
ush orelse ush =integer =
INTEGER

math ops (i, ush):

i + ush =max =
INTEGER
i -ush =max =
INTEGER
i * ush =max =
INTEGER
i / ush =float =
DOUBLE
i ^ ush =float =
DOUBLE
i \ ush =non-float =
INTEGER
i mod ush =non-float =
INTEGER

bitops (i, ush):

i shl ush =non-float =
INTEGER
i shr ush =non-float =
INTEGER
i and ush =non-float =
INTEGER
i or ush =non-float =
INTEGER
i xor ush =non-float =
INTEGER
i eqv ush =non-float =
INTEGER
i imp ush =non-float =
INTEGER

relational ops (i, ush):

i =ush =integer =
INTEGER
i >ush =integer =
INTEGER
i <ush =integer =
INTEGER
i <> ush =integer =
INTEGER
i <= ush =integer =
INTEGER
i >= ush =integer =
INTEGER
i andalso ush =integer =
INTEGER
i orelse ush =integer =
INTEGER

math ops (ui, ush):

ui + ush =max =
UINTEGER
ui -ush =max =
UINTEGER
ui * ush =max =
UINTEGER
ui / ush =float =
DOUBLE
ui ^ ush =float =
DOUBLE
ui \ ush =non-float =
UINTEGER
ui mod ush =non-float =
UINTEGER

bitops (ui, ush):

ui shl ush =non-float =
UINTEGER
ui shr ush =non-float =
UINTEGER
ui and ush =non-float =
UINTEGER
ui or ush =non-float =
UINTEGER
ui xor ush =non-float =
UINTEGER
ui eqv ush =non-float =
UINTEGER
ui imp ush =non-float =
UINTEGER

relational ops (ui, ush):

ui =ush =integer =
INTEGER
ui >ush =integer =
INTEGER
ui <ush =integer =
INTEGER
ui <> ush =integer =
INTEGER
ui <= ush =integer =
INTEGER
ui >= ush =integer =
INTEGER
ui andalso ush =integer =
INTEGER
ui orelse ush =integer =
INTEGER

math ops (l, ush):

l + ush =max =
LONG
l -ush =max =
LONG
l * ush =max =
LONG
l / ush =float =
DOUBLE
l ^ ush =float =
DOUBLE
l \ ush =non-float =
LONG
l mod ush =non-float =
LONG

bitops (l, ush):

l shl ush =non-float =
LONG
l shr ush =non-float =
LONG
l and ush =non-float =
LONG
l or ush =non-float =
LONG
l xor ush =non-float =
LONG
l eqv ush =non-float =
LONG
l imp ush =non-float =
LONG

relational ops (l, ush):

l =ush =integer =
INTEGER
l >ush =integer =
INTEGER
l <ush =integer =
INTEGER
l <> ush =integer =
INTEGER
l <= ush =integer =
INTEGER
l >= ush =integer =
INTEGER
l andalso ush =integer =
INTEGER
l orelse ush =integer =
INTEGER

math ops (ul, ush):

ul + ush =max =
ULONG
ul -ush =max =
ULONG
ul * ush =max =
ULONG
ul / ush =float =
DOUBLE
ul ^ ush =float =
DOUBLE
ul \ ush =non-float =
ULONG
ul mod ush =non-float =
ULONG

bitops (ul, ush):

ul shl ush =non-float =
ULONG
ul shr ush =non-float =
ULONG
ul and ush =non-float =
ULONG
ul or ush =non-float =
ULONG
ul xor ush =non-float =
ULONG
ul eqv ush =non-float =
ULONG
ul imp ush =non-float =
ULONG

relational ops (ul, ush):

ul =ush =integer =
INTEGER
ul >ush =integer =
INTEGER
ul <ush =integer =
INTEGER
ul <> ush =integer =
INTEGER
ul <= ush =integer =
INTEGER
ul >= ush =integer =
INTEGER
ul andalso ush =integer =
INTEGER
ul orelse ush =integer =
INTEGER

math ops (ll, ush):

ll + ush =max =
LONGINT
ll -ush =max =
LONGINT
ll * ush =max =
LONGINT
ll / ush =float =
DOUBLE
ll ^ ush =float =
DOUBLE
ll \ ush =non-float =
LONGINT
ll mod ush =non-float =
LONGINT

bitops (ll, ush):

ll shl ush =non-float =
LONGINT
ll shr ush =non-float =
LONGINT
ll and ush =non-float =
LONGINT
ll or ush =non-float =
LONGINT
ll xor ush =non-float =
LONGINT
ll eqv ush =non-float =
LONGINT
ll imp ush =non-float =
LONGINT

relational ops (ll, ush):

ll =ush =integer =
INTEGER
ll >ush =integer =
INTEGER
ll <ush =integer =
INTEGER
ll <> ush =integer =
INTEGER
ll <= ush =integer =
INTEGER
ll >= ush =integer =
INTEGER
ll andalso ush =integer =
INTEGER
ll orelse ush =integer =
INTEGER

math ops (ull, ush):

ull + ush =max =
ULONGINT
ull -ush =max =
ULONGINT
ull * ush =max =
ULONGINT
ull / ush =float =
DOUBLE
ull ^ ush =float =
DOUBLE
ull \ ush =non-float =
ULONGINT
ull mod ush =non-float =
ULONGINT

bitops (ull, ush):

ull shl ush =non-float =
ULONGINT
ull shr ush =non-float =
ULONGINT
ull and ush =non-float =
ULONGINT
ull or ush =non-float =
ULONGINT
ull xor ush =non-float =
ULONGINT
ull eqv ush =non-float =
ULONGINT
ull imp ush =non-float =
ULONGINT

relational ops (ull, ush):

ull =ush =integer =
INTEGER
ull >ush =integer =
INTEGER
ull <ush =integer =
INTEGER
ull <> ush =integer =
INTEGER
ull <= ush =integer =
INTEGER
ull >= ush =integer =
INTEGER
ull andalso ush =integer =
INTEGER
ull orelse ush =integer =
INTEGER

math ops (enum1a, ush):

enum1a + ush =max =
ENUM1
enum1a -ush =max =
ENUM1
enum1a * ush =max =
ENUM1
enum1a / ush =float =
DOUBLE
enum1a ^ ush =float =
DOUBLE
enum1a \ ush =non-float =
ENUM1
enum1a mod ush =non-float =
ENUM1

bitops (enum1a, ush):

enum1a shl ush =non-float =
ENUM1
enum1a shr ush =non-float =
ENUM1
enum1a and ush =non-float =
ENUM1
enum1a or ush =non-float =
ENUM1
enum1a xor ush =non-float =
ENUM1
enum1a eqv ush =non-float =
ENUM1
enum1a imp ush =non-float =
ENUM1

relational ops (enum1a, ush):

enum1a =ush =integer =
INTEGER
enum1a >ush =integer =
INTEGER
enum1a <ush =integer =
INTEGER
enum1a <> ush =integer =
INTEGER
enum1a <= ush =integer =
INTEGER
enum1a >= ush =integer =
INTEGER
enum1a andalso ush =integer =
INTEGER
enum1a orelse ush =integer =
INTEGER

math ops (ush, f):

ush + f =max =
SINGLE
ush -f =max =
SINGLE
ush * f =max =
SINGLE
ush / f =float =
DOUBLE
ush ^ f =float =
DOUBLE
ush \ f =non-float =
INTEGER
ush mod f =non-float =
INTEGER

bitops (ush, f):

ush shl f =non-float =
INTEGER
ush shr f =non-float =
INTEGER
ush and f =non-float =
INTEGER
ush or f =non-float =
INTEGER
ush xor f =non-float =
INTEGER
ush eqv f =non-float =
INTEGER
ush imp f =non-float =
INTEGER

relational ops (ush, f):

ush =f =integer =
INTEGER
ush >f =integer =
INTEGER
ush <f =integer =
INTEGER
ush <> f =integer =
INTEGER
ush <= f =integer =
INTEGER
ush >= f =integer =
INTEGER
ush andalso f =integer =
INTEGER
ush orelse f =integer =
INTEGER

math ops (ush, d):

ush + d =max =
DOUBLE
ush -d =max =
DOUBLE
ush * d =max =
DOUBLE
ush / d =float =
DOUBLE
ush ^ d =float =
DOUBLE
ush \ d =non-float =
INTEGER
ush mod d =non-float =
INTEGER

bitops (ush, d):

ush shl d =non-float =
INTEGER
ush shr d =non-float =
INTEGER
ush and d =non-float =
INTEGER
ush or d =non-float =
INTEGER
ush xor d =non-float =
INTEGER
ush eqv d =non-float =
INTEGER
ush imp d =non-float =
INTEGER

relational ops (ush, d):

ush =d =integer =
INTEGER
ush >d =integer =
INTEGER
ush <d =integer =
INTEGER
ush <> d =integer =
INTEGER
ush <= d =integer =
INTEGER
ush >= d =integer =
INTEGER
ush andalso d =integer =
INTEGER
ush orelse d =integer =
INTEGER

math ops (f, ush):

f + ush =max =
SINGLE
f -ush =max =
SINGLE
f * ush =max =
SINGLE
f / ush =float =
DOUBLE
f ^ ush =float =
DOUBLE
f \ ush =non-float =
INTEGER
f mod ush =non-float =
INTEGER

bitops (f, ush):

f shl ush =non-float =
INTEGER
f shr ush =non-float =
INTEGER
f and ush =non-float =
INTEGER
f or ush =non-float =
INTEGER
f xor ush =non-float =
INTEGER
f eqv ush =non-float =
INTEGER
f imp ush =non-float =
INTEGER

relational ops (f, ush):

f =ush =integer =
INTEGER
f >ush =integer =
INTEGER
f <ush =integer =
INTEGER
f <> ush =integer =
INTEGER
f <= ush =integer =
INTEGER
f >= ush =integer =
INTEGER
f andalso ush =integer =
INTEGER
f orelse ush =integer =
INTEGER

math ops (d, ush):

d + ush =max =
DOUBLE
d -ush =max =
DOUBLE
d * ush =max =
DOUBLE
d / ush =float =
DOUBLE
d ^ ush =float =
DOUBLE
d \ ush =non-float =
INTEGER
d mod ush =non-float =
INTEGER

bitops (d, ush):

d shl ush =non-float =
INTEGER
d shr ush =non-float =
INTEGER
d and ush =non-float =
INTEGER
d or ush =non-float =
INTEGER
d xor ush =non-float =
INTEGER
d eqv ush =non-float =
INTEGER
d imp ush =non-float =
INTEGER

relational ops (d, ush):

d =ush =integer =
INTEGER
d >ush =integer =
INTEGER
d <ush =integer =
INTEGER
d <> ush =integer =
INTEGER
d <= ush =integer =
INTEGER
d >= ush =integer =
INTEGER
d andalso ush =integer =
INTEGER
d orelse ush =integer =
INTEGER

-----i -----------------------------------------------------


math ops (i, b):

i + b =max =
INTEGER
i -b =max =
INTEGER
i * b =max =
INTEGER
i / b =float =
DOUBLE
i ^ b =float =
DOUBLE
i \ b =non-float =
INTEGER
i mod b =non-float =
INTEGER

bitops (i, b):

i shl b =non-float =
INTEGER
i shr b =non-float =
INTEGER
i and b =non-float =
INTEGER
i or b =non-float =
INTEGER
i xor b =non-float =
INTEGER
i eqv b =non-float =
INTEGER
i imp b =non-float =
INTEGER

relational ops (i, b):

i =b =integer =
INTEGER
i >b =integer =
INTEGER
i <b =integer =
INTEGER
i <> b =integer =
INTEGER
i <= b =integer =
INTEGER
i >= b =integer =
INTEGER
i andalso b =integer =
INTEGER
i orelse b =integer =
INTEGER

math ops (i, ub):

i + ub =max =
INTEGER
i -ub =max =
INTEGER
i * ub =max =
INTEGER
i / ub =float =
DOUBLE
i ^ ub =float =
DOUBLE
i \ ub =non-float =
INTEGER
i mod ub =non-float =
INTEGER

bitops (i, ub):

i shl ub =non-float =
INTEGER
i shr ub =non-float =
INTEGER
i and ub =non-float =
INTEGER
i or ub =non-float =
INTEGER
i xor ub =non-float =
INTEGER
i eqv ub =non-float =
INTEGER
i imp ub =non-float =
INTEGER

relational ops (i, ub):

i =ub =integer =
INTEGER
i >ub =integer =
INTEGER
i <ub =integer =
INTEGER
i <> ub =integer =
INTEGER
i <= ub =integer =
INTEGER
i >= ub =integer =
INTEGER
i andalso ub =integer =
INTEGER
i orelse ub =integer =
INTEGER

math ops (i, sh):

i + sh =max =
INTEGER
i -sh =max =
INTEGER
i * sh =max =
INTEGER
i / sh =float =
DOUBLE
i ^ sh =float =
DOUBLE
i \ sh =non-float =
INTEGER
i mod sh =non-float =
INTEGER

bitops (i, sh):

i shl sh =non-float =
INTEGER
i shr sh =non-float =
INTEGER
i and sh =non-float =
INTEGER
i or sh =non-float =
INTEGER
i xor sh =non-float =
INTEGER
i eqv sh =non-float =
INTEGER
i imp sh =non-float =
INTEGER

relational ops (i, sh):

i =sh =integer =
INTEGER
i >sh =integer =
INTEGER
i <sh =integer =
INTEGER
i <> sh =integer =
INTEGER
i <= sh =integer =
INTEGER
i >= sh =integer =
INTEGER
i andalso sh =integer =
INTEGER
i orelse sh =integer =
INTEGER

math ops (i, ush):

i + ush =max =
INTEGER
i -ush =max =
INTEGER
i * ush =max =
INTEGER
i / ush =float =
DOUBLE
i ^ ush =float =
DOUBLE
i \ ush =non-float =
INTEGER
i mod ush =non-float =
INTEGER

bitops (i, ush):

i shl ush =non-float =
INTEGER
i shr ush =non-float =
INTEGER
i and ush =non-float =
INTEGER
i or ush =non-float =
INTEGER
i xor ush =non-float =
INTEGER
i eqv ush =non-float =
INTEGER
i imp ush =non-float =
INTEGER

relational ops (i, ush):

i =ush =integer =
INTEGER
i >ush =integer =
INTEGER
i <ush =integer =
INTEGER
i <> ush =integer =
INTEGER
i <= ush =integer =
INTEGER
i >= ush =integer =
INTEGER
i andalso ush =integer =
INTEGER
i orelse ush =integer =
INTEGER

math ops (i, i):

i + i =max =
INTEGER
i -i =max =
INTEGER
i * i =max =
INTEGER
i / i =float =
DOUBLE
i ^ i =float =
DOUBLE
i \ i =non-float =
INTEGER
i mod i =non-float =
INTEGER

bitops (i, i):

i shl i =non-float =
INTEGER
i shr i =non-float =
INTEGER
i and i =non-float =
INTEGER
i or i =non-float =
INTEGER
i xor i =non-float =
INTEGER
i eqv i =non-float =
INTEGER
i imp i =non-float =
INTEGER

relational ops (i, i):

i =i =integer =
INTEGER
i >i =integer =
INTEGER
i <i =integer =
INTEGER
i <> i =integer =
INTEGER
i <= i =integer =
INTEGER
i >= i =integer =
INTEGER
i andalso i =integer =
INTEGER
i orelse i =integer =
INTEGER

math ops (i, ui):

i + ui =max =
INTEGER
i -ui =max =
INTEGER
i * ui =max =
INTEGER
i / ui =float =
DOUBLE
i ^ ui =float =
DOUBLE
i \ ui =non-float =
INTEGER
i mod ui =non-float =
INTEGER

bitops (i, ui):

i shl ui =non-float =
INTEGER
i shr ui =non-float =
INTEGER
i and ui =non-float =
INTEGER
i or ui =non-float =
INTEGER
i xor ui =non-float =
INTEGER
i eqv ui =non-float =
INTEGER
i imp ui =non-float =
INTEGER

relational ops (i, ui):

i =ui =integer =
INTEGER
i >ui =integer =
INTEGER
i <ui =integer =
INTEGER
i <> ui =integer =
INTEGER
i <= ui =integer =
INTEGER
i >= ui =integer =
INTEGER
i andalso ui =integer =
INTEGER
i orelse ui =integer =
INTEGER

math ops (i, l):

i + l =max =
INTEGER
i -l =max =
INTEGER
i * l =max =
INTEGER
i / l =float =
DOUBLE
i ^ l =float =
DOUBLE
i \ l =non-float =
INTEGER
i mod l =non-float =
INTEGER

bitops (i, l):

i shl l =non-float =
INTEGER
i shr l =non-float =
INTEGER
i and l =non-float =
INTEGER
i or l =non-float =
INTEGER
i xor l =non-float =
INTEGER
i eqv l =non-float =
INTEGER
i imp l =non-float =
INTEGER

relational ops (i, l):

i =l =integer =
INTEGER
i >l =integer =
INTEGER
i <l =integer =
INTEGER
i <> l =integer =
INTEGER
i <= l =integer =
INTEGER
i >= l =integer =
INTEGER
i andalso l =integer =
INTEGER
i orelse l =integer =
INTEGER

math ops (i, ul):

i + ul =max =
INTEGER
i -ul =max =
INTEGER
i * ul =max =
INTEGER
i / ul =float =
DOUBLE
i ^ ul =float =
DOUBLE
i \ ul =non-float =
INTEGER
i mod ul =non-float =
INTEGER

bitops (i, ul):

i shl ul =non-float =
INTEGER
i shr ul =non-float =
INTEGER
i and ul =non-float =
INTEGER
i or ul =non-float =
INTEGER
i xor ul =non-float =
INTEGER
i eqv ul =non-float =
INTEGER
i imp ul =non-float =
INTEGER

relational ops (i, ul):

i =ul =integer =
INTEGER
i >ul =integer =
INTEGER
i <ul =integer =
INTEGER
i <> ul =integer =
INTEGER
i <= ul =integer =
INTEGER
i >= ul =integer =
INTEGER
i andalso ul =integer =
INTEGER
i orelse ul =integer =
INTEGER

math ops (i, ll):

i + ll =max =
LONGINT
i -ll =max =
LONGINT
i * ll =max =
LONGINT
i / ll =float =
DOUBLE
i ^ ll =float =
DOUBLE
i \ ll =non-float =
LONGINT
i mod ll =non-float =
LONGINT

bitops (i, ll):

i shl ll =non-float =
LONGINT
i shr ll =non-float =
LONGINT
i and ll =non-float =
LONGINT
i or ll =non-float =
LONGINT
i xor ll =non-float =
LONGINT
i eqv ll =non-float =
LONGINT
i imp ll =non-float =
LONGINT

relational ops (i, ll):

i =ll =integer =
INTEGER
i >ll =integer =
INTEGER
i <ll =integer =
INTEGER
i <> ll =integer =
INTEGER
i <= ll =integer =
INTEGER
i >= ll =integer =
INTEGER
i andalso ll =integer =
INTEGER
i orelse ll =integer =
INTEGER

math ops (i, ull):

i + ull =max =
ULONGINT
i -ull =max =
ULONGINT
i * ull =max =
ULONGINT
i / ull =float =
DOUBLE
i ^ ull =float =
DOUBLE
i \ ull =non-float =
ULONGINT
i mod ull =non-float =
ULONGINT

bitops (i, ull):

i shl ull =non-float =
ULONGINT
i shr ull =non-float =
ULONGINT
i and ull =non-float =
ULONGINT
i or ull =non-float =
ULONGINT
i xor ull =non-float =
ULONGINT
i eqv ull =non-float =
ULONGINT
i imp ull =non-float =
ULONGINT

relational ops (i, ull):

i =ull =integer =
INTEGER
i >ull =integer =
INTEGER
i <ull =integer =
INTEGER
i <> ull =integer =
INTEGER
i <= ull =integer =
INTEGER
i >= ull =integer =
INTEGER
i andalso ull =integer =
INTEGER
i orelse ull =integer =
INTEGER

math ops (i, enum1a):

i + enum1a =max =
ENUM1
i -enum1a =max =
ENUM1
i * enum1a =max =
ENUM1
i / enum1a =float =
DOUBLE
i ^ enum1a =float =
DOUBLE
i \ enum1a =non-float =
ENUM1
i mod enum1a =non-float =
ENUM1

bitops (i, enum1a):

i shl enum1a =non-float =
ENUM1
i shr enum1a =non-float =
ENUM1
i and enum1a =non-float =
ENUM1
i or enum1a =non-float =
ENUM1
i xor enum1a =non-float =
ENUM1
i eqv enum1a =non-float =
ENUM1
i imp enum1a =non-float =
ENUM1

relational ops (i, enum1a):

i =enum1a =integer =
INTEGER
i >enum1a =integer =
INTEGER
i <enum1a =integer =
INTEGER
i <> enum1a =integer =
INTEGER
i <= enum1a =integer =
INTEGER
i >= enum1a =integer =
INTEGER
i andalso enum1a =integer =
INTEGER
i orelse enum1a =integer =
INTEGER

math ops (b, i):

b + i =max =
INTEGER
b -i =max =
INTEGER
b * i =max =
INTEGER
b / i =float =
DOUBLE
b ^ i =float =
DOUBLE
b \ i =non-float =
INTEGER
b mod i =non-float =
INTEGER

bitops (b, i):

b shl i =non-float =
INTEGER
b shr i =non-float =
INTEGER
b and i =non-float =
INTEGER
b or i =non-float =
INTEGER
b xor i =non-float =
INTEGER
b eqv i =non-float =
INTEGER
b imp i =non-float =
INTEGER

relational ops (b, i):

b =i =integer =
INTEGER
b >i =integer =
INTEGER
b <i =integer =
INTEGER
b <> i =integer =
INTEGER
b <= i =integer =
INTEGER
b >= i =integer =
INTEGER
b andalso i =integer =
INTEGER
b orelse i =integer =
INTEGER

math ops (ub, i):

ub + i =max =
UINTEGER
ub -i =max =
UINTEGER
ub * i =max =
UINTEGER
ub / i =float =
DOUBLE
ub ^ i =float =
DOUBLE
ub \ i =non-float =
UINTEGER
ub mod i =non-float =
UINTEGER

bitops (ub, i):

ub shl i =non-float =
UINTEGER
ub shr i =non-float =
UINTEGER
ub and i =non-float =
UINTEGER
ub or i =non-float =
UINTEGER
ub xor i =non-float =
UINTEGER
ub eqv i =non-float =
UINTEGER
ub imp i =non-float =
UINTEGER

relational ops (ub, i):

ub =i =integer =
INTEGER
ub >i =integer =
INTEGER
ub <i =integer =
INTEGER
ub <> i =integer =
INTEGER
ub <= i =integer =
INTEGER
ub >= i =integer =
INTEGER
ub andalso i =integer =
INTEGER
ub orelse i =integer =
INTEGER

math ops (sh, i):

sh + i =max =
INTEGER
sh -i =max =
INTEGER
sh * i =max =
INTEGER
sh / i =float =
DOUBLE
sh ^ i =float =
DOUBLE
sh \ i =non-float =
INTEGER
sh mod i =non-float =
INTEGER

bitops (sh, i):

sh shl i =non-float =
INTEGER
sh shr i =non-float =
INTEGER
sh and i =non-float =
INTEGER
sh or i =non-float =
INTEGER
sh xor i =non-float =
INTEGER
sh eqv i =non-float =
INTEGER
sh imp i =non-float =
INTEGER

relational ops (sh, i):

sh =i =integer =
INTEGER
sh >i =integer =
INTEGER
sh <i =integer =
INTEGER
sh <> i =integer =
INTEGER
sh <= i =integer =
INTEGER
sh >= i =integer =
INTEGER
sh andalso i =integer =
INTEGER
sh orelse i =integer =
INTEGER

math ops (ush, i):

ush + i =max =
INTEGER
ush -i =max =
INTEGER
ush * i =max =
INTEGER
ush / i =float =
DOUBLE
ush ^ i =float =
DOUBLE
ush \ i =non-float =
INTEGER
ush mod i =non-float =
INTEGER

bitops (ush, i):

ush shl i =non-float =
INTEGER
ush shr i =non-float =
INTEGER
ush and i =non-float =
INTEGER
ush or i =non-float =
INTEGER
ush xor i =non-float =
INTEGER
ush eqv i =non-float =
INTEGER
ush imp i =non-float =
INTEGER

relational ops (ush, i):

ush =i =integer =
INTEGER
ush >i =integer =
INTEGER
ush <i =integer =
INTEGER
ush <> i =integer =
INTEGER
ush <= i =integer =
INTEGER
ush >= i =integer =
INTEGER
ush andalso i =integer =
INTEGER
ush orelse i =integer =
INTEGER

math ops (i, i):

i + i =max =
INTEGER
i -i =max =
INTEGER
i * i =max =
INTEGER
i / i =float =
DOUBLE
i ^ i =float =
DOUBLE
i \ i =non-float =
INTEGER
i mod i =non-float =
INTEGER

bitops (i, i):

i shl i =non-float =
INTEGER
i shr i =non-float =
INTEGER
i and i =non-float =
INTEGER
i or i =non-float =
INTEGER
i xor i =non-float =
INTEGER
i eqv i =non-float =
INTEGER
i imp i =non-float =
INTEGER

relational ops (i, i):

i =i =integer =
INTEGER
i >i =integer =
INTEGER
i <i =integer =
INTEGER
i <> i =integer =
INTEGER
i <= i =integer =
INTEGER
i >= i =integer =
INTEGER
i andalso i =integer =
INTEGER
i orelse i =integer =
INTEGER

math ops (ui, i):

ui + i =max =
UINTEGER
ui -i =max =
UINTEGER
ui * i =max =
UINTEGER
ui / i =float =
DOUBLE
ui ^ i =float =
DOUBLE
ui \ i =non-float =
UINTEGER
ui mod i =non-float =
UINTEGER

bitops (ui, i):

ui shl i =non-float =
UINTEGER
ui shr i =non-float =
UINTEGER
ui and i =non-float =
UINTEGER
ui or i =non-float =
UINTEGER
ui xor i =non-float =
UINTEGER
ui eqv i =non-float =
UINTEGER
ui imp i =non-float =
UINTEGER

relational ops (ui, i):

ui =i =integer =
INTEGER
ui >i =integer =
INTEGER
ui <i =integer =
INTEGER
ui <> i =integer =
INTEGER
ui <= i =integer =
INTEGER
ui >= i =integer =
INTEGER
ui andalso i =integer =
INTEGER
ui orelse i =integer =
INTEGER

math ops (l, i):

l + i =max =
LONG
l -i =max =
LONG
l * i =max =
LONG
l / i =float =
DOUBLE
l ^ i =float =
DOUBLE
l \ i =non-float =
LONG
l mod i =non-float =
LONG

bitops (l, i):

l shl i =non-float =
LONG
l shr i =non-float =
LONG
l and i =non-float =
LONG
l or i =non-float =
LONG
l xor i =non-float =
LONG
l eqv i =non-float =
LONG
l imp i =non-float =
LONG

relational ops (l, i):

l =i =integer =
INTEGER
l >i =integer =
INTEGER
l <i =integer =
INTEGER
l <> i =integer =
INTEGER
l <= i =integer =
INTEGER
l >= i =integer =
INTEGER
l andalso i =integer =
INTEGER
l orelse i =integer =
INTEGER

math ops (ul, i):

ul + i =max =
ULONG
ul -i =max =
ULONG
ul * i =max =
ULONG
ul / i =float =
DOUBLE
ul ^ i =float =
DOUBLE
ul \ i =non-float =
ULONG
ul mod i =non-float =
ULONG

bitops (ul, i):

ul shl i =non-float =
ULONG
ul shr i =non-float =
ULONG
ul and i =non-float =
ULONG
ul or i =non-float =
ULONG
ul xor i =non-float =
ULONG
ul eqv i =non-float =
ULONG
ul imp i =non-float =
ULONG

relational ops (ul, i):

ul =i =integer =
INTEGER
ul >i =integer =
INTEGER
ul <i =integer =
INTEGER
ul <> i =integer =
INTEGER
ul <= i =integer =
INTEGER
ul >= i =integer =
INTEGER
ul andalso i =integer =
INTEGER
ul orelse i =integer =
INTEGER

math ops (ll, i):

ll + i =max =
LONGINT
ll -i =max =
LONGINT
ll * i =max =
LONGINT
ll / i =float =
DOUBLE
ll ^ i =float =
DOUBLE
ll \ i =non-float =
LONGINT
ll mod i =non-float =
LONGINT

bitops (ll, i):

ll shl i =non-float =
LONGINT
ll shr i =non-float =
LONGINT
ll and i =non-float =
LONGINT
ll or i =non-float =
LONGINT
ll xor i =non-float =
LONGINT
ll eqv i =non-float =
LONGINT
ll imp i =non-float =
LONGINT

relational ops (ll, i):

ll =i =integer =
INTEGER
ll >i =integer =
INTEGER
ll <i =integer =
INTEGER
ll <> i =integer =
INTEGER
ll <= i =integer =
INTEGER
ll >= i =integer =
INTEGER
ll andalso i =integer =
INTEGER
ll orelse i =integer =
INTEGER

math ops (ull, i):

ull + i =max =
ULONGINT
ull -i =max =
ULONGINT
ull * i =max =
ULONGINT
ull / i =float =
DOUBLE
ull ^ i =float =
DOUBLE
ull \ i =non-float =
ULONGINT
ull mod i =non-float =
ULONGINT

bitops (ull, i):

ull shl i =non-float =
ULONGINT
ull shr i =non-float =
ULONGINT
ull and i =non-float =
ULONGINT
ull or i =non-float =
ULONGINT
ull xor i =non-float =
ULONGINT
ull eqv i =non-float =
ULONGINT
ull imp i =non-float =
ULONGINT

relational ops (ull, i):

ull =i =integer =
INTEGER
ull >i =integer =
INTEGER
ull <i =integer =
INTEGER
ull <> i =integer =
INTEGER
ull <= i =integer =
INTEGER
ull >= i =integer =
INTEGER
ull andalso i =integer =
INTEGER
ull orelse i =integer =
INTEGER

math ops (enum1a, i):

enum1a + i =max =
ENUM1
enum1a -i =max =
ENUM1
enum1a * i =max =
ENUM1
enum1a / i =float =
DOUBLE
enum1a ^ i =float =
DOUBLE
enum1a \ i =non-float =
ENUM1
enum1a mod i =non-float =
ENUM1

bitops (enum1a, i):

enum1a shl i =non-float =
ENUM1
enum1a shr i =non-float =
ENUM1
enum1a and i =non-float =
ENUM1
enum1a or i =non-float =
ENUM1
enum1a xor i =non-float =
ENUM1
enum1a eqv i =non-float =
ENUM1
enum1a imp i =non-float =
ENUM1

relational ops (enum1a, i):

enum1a =i =integer =
INTEGER
enum1a >i =integer =
INTEGER
enum1a <i =integer =
INTEGER
enum1a <> i =integer =
INTEGER
enum1a <= i =integer =
INTEGER
enum1a >= i =integer =
INTEGER
enum1a andalso i =integer =
INTEGER
enum1a orelse i =integer =
INTEGER

math ops (i, f):

i + f =max =
SINGLE
i -f =max =
SINGLE
i * f =max =
SINGLE
i / f =float =
DOUBLE
i ^ f =float =
DOUBLE
i \ f =non-float =
INTEGER
i mod f =non-float =
INTEGER

bitops (i, f):

i shl f =non-float =
INTEGER
i shr f =non-float =
INTEGER
i and f =non-float =
INTEGER
i or f =non-float =
INTEGER
i xor f =non-float =
INTEGER
i eqv f =non-float =
INTEGER
i imp f =non-float =
INTEGER

relational ops (i, f):

i =f =integer =
INTEGER
i >f =integer =
INTEGER
i <f =integer =
INTEGER
i <> f =integer =
INTEGER
i <= f =integer =
INTEGER
i >= f =integer =
INTEGER
i andalso f =integer =
INTEGER
i orelse f =integer =
INTEGER

math ops (i, d):

i + d =max =
DOUBLE
i -d =max =
DOUBLE
i * d =max =
DOUBLE
i / d =float =
DOUBLE
i ^ d =float =
DOUBLE
i \ d =non-float =
INTEGER
i mod d =non-float =
INTEGER

bitops (i, d):

i shl d =non-float =
INTEGER
i shr d =non-float =
INTEGER
i and d =non-float =
INTEGER
i or d =non-float =
INTEGER
i xor d =non-float =
INTEGER
i eqv d =non-float =
INTEGER
i imp d =non-float =
INTEGER

relational ops (i, d):

i =d =integer =
INTEGER
i >d =integer =
INTEGER
i <d =integer =
INTEGER
i <> d =integer =
INTEGER
i <= d =integer =
INTEGER
i >= d =integer =
INTEGER
i andalso d =integer =
INTEGER
i orelse d =integer =
INTEGER

math ops (f, i):

f + i =max =
SINGLE
f -i =max =
SINGLE
f * i =max =
SINGLE
f / i =float =
DOUBLE
f ^ i =float =
DOUBLE
f \ i =non-float =
INTEGER
f mod i =non-float =
INTEGER

bitops (f, i):

f shl i =non-float =
INTEGER
f shr i =non-float =
INTEGER
f and i =non-float =
INTEGER
f or i =non-float =
INTEGER
f xor i =non-float =
INTEGER
f eqv i =non-float =
INTEGER
f imp i =non-float =
INTEGER

relational ops (f, i):

f =i =integer =
INTEGER
f >i =integer =
INTEGER
f <i =integer =
INTEGER
f <> i =integer =
INTEGER
f <= i =integer =
INTEGER
f >= i =integer =
INTEGER
f andalso i =integer =
INTEGER
f orelse i =integer =
INTEGER

math ops (d, i):

d + i =max =
DOUBLE
d -i =max =
DOUBLE
d * i =max =
DOUBLE
d / i =float =
DOUBLE
d ^ i =float =
DOUBLE
d \ i =non-float =
INTEGER
d mod i =non-float =
INTEGER

bitops (d, i):

d shl i =non-float =
INTEGER
d shr i =non-float =
INTEGER
d and i =non-float =
INTEGER
d or i =non-float =
INTEGER
d xor i =non-float =
INTEGER
d eqv i =non-float =
INTEGER
d imp i =non-float =
INTEGER

relational ops (d, i):

d =i =integer =
INTEGER
d >i =integer =
INTEGER
d <i =integer =
INTEGER
d <> i =integer =
INTEGER
d <= i =integer =
INTEGER
d >= i =integer =
INTEGER
d andalso i =integer =
INTEGER
d orelse i =integer =
INTEGER

-----ui -----------------------------------------------------


math ops (ui, b):

ui + b =max =
UINTEGER
ui -b =max =
UINTEGER
ui * b =max =
UINTEGER
ui / b =float =
DOUBLE
ui ^ b =float =
DOUBLE
ui \ b =non-float =
UINTEGER
ui mod b =non-float =
UINTEGER

bitops (ui, b):

ui shl b =non-float =
UINTEGER
ui shr b =non-float =
UINTEGER
ui and b =non-float =
UINTEGER
ui or b =non-float =
UINTEGER
ui xor b =non-float =
UINTEGER
ui eqv b =non-float =
UINTEGER
ui imp b =non-float =
UINTEGER

relational ops (ui, b):

ui =b =integer =
INTEGER
ui >b =integer =
INTEGER
ui <b =integer =
INTEGER
ui <> b =integer =
INTEGER
ui <= b =integer =
INTEGER
ui >= b =integer =
INTEGER
ui andalso b =integer =
INTEGER
ui orelse b =integer =
INTEGER

math ops (ui, ub):

ui + ub =max =
UINTEGER
ui -ub =max =
UINTEGER
ui * ub =max =
UINTEGER
ui / ub =float =
DOUBLE
ui ^ ub =float =
DOUBLE
ui \ ub =non-float =
UINTEGER
ui mod ub =non-float =
UINTEGER

bitops (ui, ub):

ui shl ub =non-float =
UINTEGER
ui shr ub =non-float =
UINTEGER
ui and ub =non-float =
UINTEGER
ui or ub =non-float =
UINTEGER
ui xor ub =non-float =
UINTEGER
ui eqv ub =non-float =
UINTEGER
ui imp ub =non-float =
UINTEGER

relational ops (ui, ub):

ui =ub =integer =
INTEGER
ui >ub =integer =
INTEGER
ui <ub =integer =
INTEGER
ui <> ub =integer =
INTEGER
ui <= ub =integer =
INTEGER
ui >= ub =integer =
INTEGER
ui andalso ub =integer =
INTEGER
ui orelse ub =integer =
INTEGER

math ops (ui, sh):

ui + sh =max =
UINTEGER
ui -sh =max =
UINTEGER
ui * sh =max =
UINTEGER
ui / sh =float =
DOUBLE
ui ^ sh =float =
DOUBLE
ui \ sh =non-float =
UINTEGER
ui mod sh =non-float =
UINTEGER

bitops (ui, sh):

ui shl sh =non-float =
UINTEGER
ui shr sh =non-float =
UINTEGER
ui and sh =non-float =
UINTEGER
ui or sh =non-float =
UINTEGER
ui xor sh =non-float =
UINTEGER
ui eqv sh =non-float =
UINTEGER
ui imp sh =non-float =
UINTEGER

relational ops (ui, sh):

ui =sh =integer =
INTEGER
ui >sh =integer =
INTEGER
ui <sh =integer =
INTEGER
ui <> sh =integer =
INTEGER
ui <= sh =integer =
INTEGER
ui >= sh =integer =
INTEGER
ui andalso sh =integer =
INTEGER
ui orelse sh =integer =
INTEGER

math ops (ui, ush):

ui + ush =max =
UINTEGER
ui -ush =max =
UINTEGER
ui * ush =max =
UINTEGER
ui / ush =float =
DOUBLE
ui ^ ush =float =
DOUBLE
ui \ ush =non-float =
UINTEGER
ui mod ush =non-float =
UINTEGER

bitops (ui, ush):

ui shl ush =non-float =
UINTEGER
ui shr ush =non-float =
UINTEGER
ui and ush =non-float =
UINTEGER
ui or ush =non-float =
UINTEGER
ui xor ush =non-float =
UINTEGER
ui eqv ush =non-float =
UINTEGER
ui imp ush =non-float =
UINTEGER

relational ops (ui, ush):

ui =ush =integer =
INTEGER
ui >ush =integer =
INTEGER
ui <ush =integer =
INTEGER
ui <> ush =integer =
INTEGER
ui <= ush =integer =
INTEGER
ui >= ush =integer =
INTEGER
ui andalso ush =integer =
INTEGER
ui orelse ush =integer =
INTEGER

math ops (ui, i):

ui + i =max =
UINTEGER
ui -i =max =
UINTEGER
ui * i =max =
UINTEGER
ui / i =float =
DOUBLE
ui ^ i =float =
DOUBLE
ui \ i =non-float =
UINTEGER
ui mod i =non-float =
UINTEGER

bitops (ui, i):

ui shl i =non-float =
UINTEGER
ui shr i =non-float =
UINTEGER
ui and i =non-float =
UINTEGER
ui or i =non-float =
UINTEGER
ui xor i =non-float =
UINTEGER
ui eqv i =non-float =
UINTEGER
ui imp i =non-float =
UINTEGER

relational ops (ui, i):

ui =i =integer =
INTEGER
ui >i =integer =
INTEGER
ui <i =integer =
INTEGER
ui <> i =integer =
INTEGER
ui <= i =integer =
INTEGER
ui >= i =integer =
INTEGER
ui andalso i =integer =
INTEGER
ui orelse i =integer =
INTEGER

math ops (ui, ui):

ui + ui =max =
UINTEGER
ui -ui =max =
UINTEGER
ui * ui =max =
UINTEGER
ui / ui =float =
DOUBLE
ui ^ ui =float =
DOUBLE
ui \ ui =non-float =
UINTEGER
ui mod ui =non-float =
UINTEGER

bitops (ui, ui):

ui shl ui =non-float =
UINTEGER
ui shr ui =non-float =
UINTEGER
ui and ui =non-float =
UINTEGER
ui or ui =non-float =
UINTEGER
ui xor ui =non-float =
UINTEGER
ui eqv ui =non-float =
UINTEGER
ui imp ui =non-float =
UINTEGER

relational ops (ui, ui):

ui =ui =integer =
INTEGER
ui >ui =integer =
INTEGER
ui <ui =integer =
INTEGER
ui <> ui =integer =
INTEGER
ui <= ui =integer =
INTEGER
ui >= ui =integer =
INTEGER
ui andalso ui =integer =
INTEGER
ui orelse ui =integer =
INTEGER

math ops (ui, l):

ui + l =max =
UINTEGER
ui -l =max =
UINTEGER
ui * l =max =
UINTEGER
ui / l =float =
DOUBLE
ui ^ l =float =
DOUBLE
ui \ l =non-float =
UINTEGER
ui mod l =non-float =
UINTEGER

bitops (ui, l):

ui shl l =non-float =
UINTEGER
ui shr l =non-float =
UINTEGER
ui and l =non-float =
UINTEGER
ui or l =non-float =
UINTEGER
ui xor l =non-float =
UINTEGER
ui eqv l =non-float =
UINTEGER
ui imp l =non-float =
UINTEGER

relational ops (ui, l):

ui =l =integer =
INTEGER
ui >l =integer =
INTEGER
ui <l =integer =
INTEGER
ui <> l =integer =
INTEGER
ui <= l =integer =
INTEGER
ui >= l =integer =
INTEGER
ui andalso l =integer =
INTEGER
ui orelse l =integer =
INTEGER

math ops (ui, ul):

ui + ul =max =
UINTEGER
ui -ul =max =
UINTEGER
ui * ul =max =
UINTEGER
ui / ul =float =
DOUBLE
ui ^ ul =float =
DOUBLE
ui \ ul =non-float =
UINTEGER
ui mod ul =non-float =
UINTEGER

bitops (ui, ul):

ui shl ul =non-float =
UINTEGER
ui shr ul =non-float =
UINTEGER
ui and ul =non-float =
UINTEGER
ui or ul =non-float =
UINTEGER
ui xor ul =non-float =
UINTEGER
ui eqv ul =non-float =
UINTEGER
ui imp ul =non-float =
UINTEGER

relational ops (ui, ul):

ui =ul =integer =
INTEGER
ui >ul =integer =
INTEGER
ui <ul =integer =
INTEGER
ui <> ul =integer =
INTEGER
ui <= ul =integer =
INTEGER
ui >= ul =integer =
INTEGER
ui andalso ul =integer =
INTEGER
ui orelse ul =integer =
INTEGER

math ops (ui, ll):

ui + ll =max =
LONGINT
ui -ll =max =
LONGINT
ui * ll =max =
LONGINT
ui / ll =float =
DOUBLE
ui ^ ll =float =
DOUBLE
ui \ ll =non-float =
LONGINT
ui mod ll =non-float =
LONGINT

bitops (ui, ll):

ui shl ll =non-float =
LONGINT
ui shr ll =non-float =
LONGINT
ui and ll =non-float =
LONGINT
ui or ll =non-float =
LONGINT
ui xor ll =non-float =
LONGINT
ui eqv ll =non-float =
LONGINT
ui imp ll =non-float =
LONGINT

relational ops (ui, ll):

ui =ll =integer =
INTEGER
ui >ll =integer =
INTEGER
ui <ll =integer =
INTEGER
ui <> ll =integer =
INTEGER
ui <= ll =integer =
INTEGER
ui >= ll =integer =
INTEGER
ui andalso ll =integer =
INTEGER
ui orelse ll =integer =
INTEGER

math ops (ui, ull):

ui + ull =max =
ULONGINT
ui -ull =max =
ULONGINT
ui * ull =max =
ULONGINT
ui / ull =float =
DOUBLE
ui ^ ull =float =
DOUBLE
ui \ ull =non-float =
ULONGINT
ui mod ull =non-float =
ULONGINT

bitops (ui, ull):

ui shl ull =non-float =
ULONGINT
ui shr ull =non-float =
ULONGINT
ui and ull =non-float =
ULONGINT
ui or ull =non-float =
ULONGINT
ui xor ull =non-float =
ULONGINT
ui eqv ull =non-float =
ULONGINT
ui imp ull =non-float =
ULONGINT

relational ops (ui, ull):

ui =ull =integer =
INTEGER
ui >ull =integer =
INTEGER
ui <ull =integer =
INTEGER
ui <> ull =integer =
INTEGER
ui <= ull =integer =
INTEGER
ui >= ull =integer =
INTEGER
ui andalso ull =integer =
INTEGER
ui orelse ull =integer =
INTEGER

math ops (ui, enum1a):

ui + enum1a =max =
ENUM1
ui -enum1a =max =
ENUM1
ui * enum1a =max =
ENUM1
ui / enum1a =float =
DOUBLE
ui ^ enum1a =float =
DOUBLE
ui \ enum1a =non-float =
ENUM1
ui mod enum1a =non-float =
ENUM1

bitops (ui, enum1a):

ui shl enum1a =non-float =
ENUM1
ui shr enum1a =non-float =
ENUM1
ui and enum1a =non-float =
ENUM1
ui or enum1a =non-float =
ENUM1
ui xor enum1a =non-float =
ENUM1
ui eqv enum1a =non-float =
ENUM1
ui imp enum1a =non-float =
ENUM1

relational ops (ui, enum1a):

ui =enum1a =integer =
INTEGER
ui >enum1a =integer =
INTEGER
ui <enum1a =integer =
INTEGER
ui <> enum1a =integer =
INTEGER
ui <= enum1a =integer =
INTEGER
ui >= enum1a =integer =
INTEGER
ui andalso enum1a =integer =
INTEGER
ui orelse enum1a =integer =
INTEGER

math ops (b, ui):

b + ui =max =
INTEGER
b -ui =max =
INTEGER
b * ui =max =
INTEGER
b / ui =float =
DOUBLE
b ^ ui =float =
DOUBLE
b \ ui =non-float =
INTEGER
b mod ui =non-float =
INTEGER

bitops (b, ui):

b shl ui =non-float =
INTEGER
b shr ui =non-float =
INTEGER
b and ui =non-float =
INTEGER
b or ui =non-float =
INTEGER
b xor ui =non-float =
INTEGER
b eqv ui =non-float =
INTEGER
b imp ui =non-float =
INTEGER

relational ops (b, ui):

b =ui =integer =
INTEGER
b >ui =integer =
INTEGER
b <ui =integer =
INTEGER
b <> ui =integer =
INTEGER
b <= ui =integer =
INTEGER
b >= ui =integer =
INTEGER
b andalso ui =integer =
INTEGER
b orelse ui =integer =
INTEGER

math ops (ub, ui):

ub + ui =max =
UINTEGER
ub -ui =max =
UINTEGER
ub * ui =max =
UINTEGER
ub / ui =float =
DOUBLE
ub ^ ui =float =
DOUBLE
ub \ ui =non-float =
UINTEGER
ub mod ui =non-float =
UINTEGER

bitops (ub, ui):

ub shl ui =non-float =
UINTEGER
ub shr ui =non-float =
UINTEGER
ub and ui =non-float =
UINTEGER
ub or ui =non-float =
UINTEGER
ub xor ui =non-float =
UINTEGER
ub eqv ui =non-float =
UINTEGER
ub imp ui =non-float =
UINTEGER

relational ops (ub, ui):

ub =ui =integer =
INTEGER
ub >ui =integer =
INTEGER
ub <ui =integer =
INTEGER
ub <> ui =integer =
INTEGER
ub <= ui =integer =
INTEGER
ub >= ui =integer =
INTEGER
ub andalso ui =integer =
INTEGER
ub orelse ui =integer =
INTEGER

math ops (sh, ui):

sh + ui =max =
UINTEGER
sh -ui =max =
UINTEGER
sh * ui =max =
UINTEGER
sh / ui =float =
DOUBLE
sh ^ ui =float =
DOUBLE
sh \ ui =non-float =
UINTEGER
sh mod ui =non-float =
UINTEGER

bitops (sh, ui):

sh shl ui =non-float =
UINTEGER
sh shr ui =non-float =
UINTEGER
sh and ui =non-float =
UINTEGER
sh or ui =non-float =
UINTEGER
sh xor ui =non-float =
UINTEGER
sh eqv ui =non-float =
UINTEGER
sh imp ui =non-float =
UINTEGER

relational ops (sh, ui):

sh =ui =integer =
INTEGER
sh >ui =integer =
INTEGER
sh <ui =integer =
INTEGER
sh <> ui =integer =
INTEGER
sh <= ui =integer =
INTEGER
sh >= ui =integer =
INTEGER
sh andalso ui =integer =
INTEGER
sh orelse ui =integer =
INTEGER

math ops (ush, ui):

ush + ui =max =
UINTEGER
ush -ui =max =
UINTEGER
ush * ui =max =
UINTEGER
ush / ui =float =
DOUBLE
ush ^ ui =float =
DOUBLE
ush \ ui =non-float =
UINTEGER
ush mod ui =non-float =
UINTEGER

bitops (ush, ui):

ush shl ui =non-float =
UINTEGER
ush shr ui =non-float =
UINTEGER
ush and ui =non-float =
UINTEGER
ush or ui =non-float =
UINTEGER
ush xor ui =non-float =
UINTEGER
ush eqv ui =non-float =
UINTEGER
ush imp ui =non-float =
UINTEGER

relational ops (ush, ui):

ush =ui =integer =
INTEGER
ush >ui =integer =
INTEGER
ush <ui =integer =
INTEGER
ush <> ui =integer =
INTEGER
ush <= ui =integer =
INTEGER
ush >= ui =integer =
INTEGER
ush andalso ui =integer =
INTEGER
ush orelse ui =integer =
INTEGER

math ops (i, ui):

i + ui =max =
INTEGER
i -ui =max =
INTEGER
i * ui =max =
INTEGER
i / ui =float =
DOUBLE
i ^ ui =float =
DOUBLE
i \ ui =non-float =
INTEGER
i mod ui =non-float =
INTEGER

bitops (i, ui):

i shl ui =non-float =
INTEGER
i shr ui =non-float =
INTEGER
i and ui =non-float =
INTEGER
i or ui =non-float =
INTEGER
i xor ui =non-float =
INTEGER
i eqv ui =non-float =
INTEGER
i imp ui =non-float =
INTEGER

relational ops (i, ui):

i =ui =integer =
INTEGER
i >ui =integer =
INTEGER
i <ui =integer =
INTEGER
i <> ui =integer =
INTEGER
i <= ui =integer =
INTEGER
i >= ui =integer =
INTEGER
i andalso ui =integer =
INTEGER
i orelse ui =integer =
INTEGER

math ops (ui, ui):

ui + ui =max =
UINTEGER
ui -ui =max =
UINTEGER
ui * ui =max =
UINTEGER
ui / ui =float =
DOUBLE
ui ^ ui =float =
DOUBLE
ui \ ui =non-float =
UINTEGER
ui mod ui =non-float =
UINTEGER

bitops (ui, ui):

ui shl ui =non-float =
UINTEGER
ui shr ui =non-float =
UINTEGER
ui and ui =non-float =
UINTEGER
ui or ui =non-float =
UINTEGER
ui xor ui =non-float =
UINTEGER
ui eqv ui =non-float =
UINTEGER
ui imp ui =non-float =
UINTEGER

relational ops (ui, ui):

ui =ui =integer =
INTEGER
ui >ui =integer =
INTEGER
ui <ui =integer =
INTEGER
ui <> ui =integer =
INTEGER
ui <= ui =integer =
INTEGER
ui >= ui =integer =
INTEGER
ui andalso ui =integer =
INTEGER
ui orelse ui =integer =
INTEGER

math ops (l, ui):

l + ui =max =
LONG
l -ui =max =
LONG
l * ui =max =
LONG
l / ui =float =
DOUBLE
l ^ ui =float =
DOUBLE
l \ ui =non-float =
LONG
l mod ui =non-float =
LONG

bitops (l, ui):

l shl ui =non-float =
LONG
l shr ui =non-float =
LONG
l and ui =non-float =
LONG
l or ui =non-float =
LONG
l xor ui =non-float =
LONG
l eqv ui =non-float =
LONG
l imp ui =non-float =
LONG

relational ops (l, ui):

l =ui =integer =
INTEGER
l >ui =integer =
INTEGER
l <ui =integer =
INTEGER
l <> ui =integer =
INTEGER
l <= ui =integer =
INTEGER
l >= ui =integer =
INTEGER
l andalso ui =integer =
INTEGER
l orelse ui =integer =
INTEGER

math ops (ul, ui):

ul + ui =max =
ULONG
ul -ui =max =
ULONG
ul * ui =max =
ULONG
ul / ui =float =
DOUBLE
ul ^ ui =float =
DOUBLE
ul \ ui =non-float =
ULONG
ul mod ui =non-float =
ULONG

bitops (ul, ui):

ul shl ui =non-float =
ULONG
ul shr ui =non-float =
ULONG
ul and ui =non-float =
ULONG
ul or ui =non-float =
ULONG
ul xor ui =non-float =
ULONG
ul eqv ui =non-float =
ULONG
ul imp ui =non-float =
ULONG

relational ops (ul, ui):

ul =ui =integer =
INTEGER
ul >ui =integer =
INTEGER
ul <ui =integer =
INTEGER
ul <> ui =integer =
INTEGER
ul <= ui =integer =
INTEGER
ul >= ui =integer =
INTEGER
ul andalso ui =integer =
INTEGER
ul orelse ui =integer =
INTEGER

math ops (ll, ui):

ll + ui =max =
LONGINT
ll -ui =max =
LONGINT
ll * ui =max =
LONGINT
ll / ui =float =
DOUBLE
ll ^ ui =float =
DOUBLE
ll \ ui =non-float =
LONGINT
ll mod ui =non-float =
LONGINT

bitops (ll, ui):

ll shl ui =non-float =
LONGINT
ll shr ui =non-float =
LONGINT
ll and ui =non-float =
LONGINT
ll or ui =non-float =
LONGINT
ll xor ui =non-float =
LONGINT
ll eqv ui =non-float =
LONGINT
ll imp ui =non-float =
LONGINT

relational ops (ll, ui):

ll =ui =integer =
INTEGER
ll >ui =integer =
INTEGER
ll <ui =integer =
INTEGER
ll <> ui =integer =
INTEGER
ll <= ui =integer =
INTEGER
ll >= ui =integer =
INTEGER
ll andalso ui =integer =
INTEGER
ll orelse ui =integer =
INTEGER

math ops (ull, ui):

ull + ui =max =
ULONGINT
ull -ui =max =
ULONGINT
ull * ui =max =
ULONGINT
ull / ui =float =
DOUBLE
ull ^ ui =float =
DOUBLE
ull \ ui =non-float =
ULONGINT
ull mod ui =non-float =
ULONGINT

bitops (ull, ui):

ull shl ui =non-float =
ULONGINT
ull shr ui =non-float =
ULONGINT
ull and ui =non-float =
ULONGINT
ull or ui =non-float =
ULONGINT
ull xor ui =non-float =
ULONGINT
ull eqv ui =non-float =
ULONGINT
ull imp ui =non-float =
ULONGINT

relational ops (ull, ui):

ull =ui =integer =
INTEGER
ull >ui =integer =
INTEGER
ull <ui =integer =
INTEGER
ull <> ui =integer =
INTEGER
ull <= ui =integer =
INTEGER
ull >= ui =integer =
INTEGER
ull andalso ui =integer =
INTEGER
ull orelse ui =integer =
INTEGER

math ops (enum1a, ui):

enum1a + ui =max =
ENUM1
enum1a -ui =max =
ENUM1
enum1a * ui =max =
ENUM1
enum1a / ui =float =
DOUBLE
enum1a ^ ui =float =
DOUBLE
enum1a \ ui =non-float =
ENUM1
enum1a mod ui =non-float =
ENUM1

bitops (enum1a, ui):

enum1a shl ui =non-float =
ENUM1
enum1a shr ui =non-float =
ENUM1
enum1a and ui =non-float =
ENUM1
enum1a or ui =non-float =
ENUM1
enum1a xor ui =non-float =
ENUM1
enum1a eqv ui =non-float =
ENUM1
enum1a imp ui =non-float =
ENUM1

relational ops (enum1a, ui):

enum1a =ui =integer =
INTEGER
enum1a >ui =integer =
INTEGER
enum1a <ui =integer =
INTEGER
enum1a <> ui =integer =
INTEGER
enum1a <= ui =integer =
INTEGER
enum1a >= ui =integer =
INTEGER
enum1a andalso ui =integer =
INTEGER
enum1a orelse ui =integer =
INTEGER

math ops (ui, f):

ui + f =max =
SINGLE
ui -f =max =
SINGLE
ui * f =max =
SINGLE
ui / f =float =
DOUBLE
ui ^ f =float =
DOUBLE
ui \ f =non-float =
UINTEGER
ui mod f =non-float =
UINTEGER

bitops (ui, f):

ui shl f =non-float =
UINTEGER
ui shr f =non-float =
UINTEGER
ui and f =non-float =
UINTEGER
ui or f =non-float =
UINTEGER
ui xor f =non-float =
UINTEGER
ui eqv f =non-float =
UINTEGER
ui imp f =non-float =
UINTEGER

relational ops (ui, f):

ui =f =integer =
INTEGER
ui >f =integer =
INTEGER
ui <f =integer =
INTEGER
ui <> f =integer =
INTEGER
ui <= f =integer =
INTEGER
ui >= f =integer =
INTEGER
ui andalso f =integer =
INTEGER
ui orelse f =integer =
INTEGER

math ops (ui, d):

ui + d =max =
DOUBLE
ui -d =max =
DOUBLE
ui * d =max =
DOUBLE
ui / d =float =
DOUBLE
ui ^ d =float =
DOUBLE
ui \ d =non-float =
UINTEGER
ui mod d =non-float =
UINTEGER

bitops (ui, d):

ui shl d =non-float =
UINTEGER
ui shr d =non-float =
UINTEGER
ui and d =non-float =
UINTEGER
ui or d =non-float =
UINTEGER
ui xor d =non-float =
UINTEGER
ui eqv d =non-float =
UINTEGER
ui imp d =non-float =
UINTEGER

relational ops (ui, d):

ui =d =integer =
INTEGER
ui >d =integer =
INTEGER
ui <d =integer =
INTEGER
ui <> d =integer =
INTEGER
ui <= d =integer =
INTEGER
ui >= d =integer =
INTEGER
ui andalso d =integer =
INTEGER
ui orelse d =integer =
INTEGER

math ops (f, ui):

f + ui =max =
SINGLE
f -ui =max =
SINGLE
f * ui =max =
SINGLE
f / ui =float =
DOUBLE
f ^ ui =float =
DOUBLE
f \ ui =non-float =
INTEGER
f mod ui =non-float =
INTEGER

bitops (f, ui):

f shl ui =non-float =
INTEGER
f shr ui =non-float =
INTEGER
f and ui =non-float =
INTEGER
f or ui =non-float =
INTEGER
f xor ui =non-float =
INTEGER
f eqv ui =non-float =
INTEGER
f imp ui =non-float =
INTEGER

relational ops (f, ui):

f =ui =integer =
INTEGER
f >ui =integer =
INTEGER
f <ui =integer =
INTEGER
f <> ui =integer =
INTEGER
f <= ui =integer =
INTEGER
f >= ui =integer =
INTEGER
f andalso ui =integer =
INTEGER
f orelse ui =integer =
INTEGER

math ops (d, ui):

d + ui =max =
DOUBLE
d -ui =max =
DOUBLE
d * ui =max =
DOUBLE
d / ui =float =
DOUBLE
d ^ ui =float =
DOUBLE
d \ ui =non-float =
INTEGER
d mod ui =non-float =
INTEGER

bitops (d, ui):

d shl ui =non-float =
INTEGER
d shr ui =non-float =
INTEGER
d and ui =non-float =
INTEGER
d or ui =non-float =
INTEGER
d xor ui =non-float =
INTEGER
d eqv ui =non-float =
INTEGER
d imp ui =non-float =
INTEGER

relational ops (d, ui):

d =ui =integer =
INTEGER
d >ui =integer =
INTEGER
d <ui =integer =
INTEGER
d <> ui =integer =
INTEGER
d <= ui =integer =
INTEGER
d >= ui =integer =
INTEGER
d andalso ui =integer =
INTEGER
d orelse ui =integer =
INTEGER

-----l -----------------------------------------------------


math ops (l, b):

l + b =max =
LONG
l -b =max =
LONG
l * b =max =
LONG
l / b =float =
DOUBLE
l ^ b =float =
DOUBLE
l \ b =non-float =
LONG
l mod b =non-float =
LONG

bitops (l, b):

l shl b =non-float =
LONG
l shr b =non-float =
LONG
l and b =non-float =
LONG
l or b =non-float =
LONG
l xor b =non-float =
LONG
l eqv b =non-float =
LONG
l imp b =non-float =
LONG

relational ops (l, b):

l =b =integer =
INTEGER
l >b =integer =
INTEGER
l <b =integer =
INTEGER
l <> b =integer =
INTEGER
l <= b =integer =
INTEGER
l >= b =integer =
INTEGER
l andalso b =integer =
INTEGER
l orelse b =integer =
INTEGER

math ops (l, ub):

l + ub =max =
LONG
l -ub =max =
LONG
l * ub =max =
LONG
l / ub =float =
DOUBLE
l ^ ub =float =
DOUBLE
l \ ub =non-float =
LONG
l mod ub =non-float =
LONG

bitops (l, ub):

l shl ub =non-float =
LONG
l shr ub =non-float =
LONG
l and ub =non-float =
LONG
l or ub =non-float =
LONG
l xor ub =non-float =
LONG
l eqv ub =non-float =
LONG
l imp ub =non-float =
LONG

relational ops (l, ub):

l =ub =integer =
INTEGER
l >ub =integer =
INTEGER
l <ub =integer =
INTEGER
l <> ub =integer =
INTEGER
l <= ub =integer =
INTEGER
l >= ub =integer =
INTEGER
l andalso ub =integer =
INTEGER
l orelse ub =integer =
INTEGER

math ops (l, sh):

l + sh =max =
LONG
l -sh =max =
LONG
l * sh =max =
LONG
l / sh =float =
DOUBLE
l ^ sh =float =
DOUBLE
l \ sh =non-float =
LONG
l mod sh =non-float =
LONG

bitops (l, sh):

l shl sh =non-float =
LONG
l shr sh =non-float =
LONG
l and sh =non-float =
LONG
l or sh =non-float =
LONG
l xor sh =non-float =
LONG
l eqv sh =non-float =
LONG
l imp sh =non-float =
LONG

relational ops (l, sh):

l =sh =integer =
INTEGER
l >sh =integer =
INTEGER
l <sh =integer =
INTEGER
l <> sh =integer =
INTEGER
l <= sh =integer =
INTEGER
l >= sh =integer =
INTEGER
l andalso sh =integer =
INTEGER
l orelse sh =integer =
INTEGER

math ops (l, ush):

l + ush =max =
LONG
l -ush =max =
LONG
l * ush =max =
LONG
l / ush =float =
DOUBLE
l ^ ush =float =
DOUBLE
l \ ush =non-float =
LONG
l mod ush =non-float =
LONG

bitops (l, ush):

l shl ush =non-float =
LONG
l shr ush =non-float =
LONG
l and ush =non-float =
LONG
l or ush =non-float =
LONG
l xor ush =non-float =
LONG
l eqv ush =non-float =
LONG
l imp ush =non-float =
LONG

relational ops (l, ush):

l =ush =integer =
INTEGER
l >ush =integer =
INTEGER
l <ush =integer =
INTEGER
l <> ush =integer =
INTEGER
l <= ush =integer =
INTEGER
l >= ush =integer =
INTEGER
l andalso ush =integer =
INTEGER
l orelse ush =integer =
INTEGER

math ops (l, i):

l + i =max =
LONG
l -i =max =
LONG
l * i =max =
LONG
l / i =float =
DOUBLE
l ^ i =float =
DOUBLE
l \ i =non-float =
LONG
l mod i =non-float =
LONG

bitops (l, i):

l shl i =non-float =
LONG
l shr i =non-float =
LONG
l and i =non-float =
LONG
l or i =non-float =
LONG
l xor i =non-float =
LONG
l eqv i =non-float =
LONG
l imp i =non-float =
LONG

relational ops (l, i):

l =i =integer =
INTEGER
l >i =integer =
INTEGER
l <i =integer =
INTEGER
l <> i =integer =
INTEGER
l <= i =integer =
INTEGER
l >= i =integer =
INTEGER
l andalso i =integer =
INTEGER
l orelse i =integer =
INTEGER

math ops (l, ui):

l + ui =max =
LONG
l -ui =max =
LONG
l * ui =max =
LONG
l / ui =float =
DOUBLE
l ^ ui =float =
DOUBLE
l \ ui =non-float =
LONG
l mod ui =non-float =
LONG

bitops (l, ui):

l shl ui =non-float =
LONG
l shr ui =non-float =
LONG
l and ui =non-float =
LONG
l or ui =non-float =
LONG
l xor ui =non-float =
LONG
l eqv ui =non-float =
LONG
l imp ui =non-float =
LONG

relational ops (l, ui):

l =ui =integer =
INTEGER
l >ui =integer =
INTEGER
l <ui =integer =
INTEGER
l <> ui =integer =
INTEGER
l <= ui =integer =
INTEGER
l >= ui =integer =
INTEGER
l andalso ui =integer =
INTEGER
l orelse ui =integer =
INTEGER

math ops (l, l):

l + l =max =
LONG
l -l =max =
LONG
l * l =max =
LONG
l / l =float =
DOUBLE
l ^ l =float =
DOUBLE
l \ l =non-float =
LONG
l mod l =non-float =
LONG

bitops (l, l):

l shl l =non-float =
LONG
l shr l =non-float =
LONG
l and l =non-float =
LONG
l or l =non-float =
LONG
l xor l =non-float =
LONG
l eqv l =non-float =
LONG
l imp l =non-float =
LONG

relational ops (l, l):

l =l =integer =
INTEGER
l >l =integer =
INTEGER
l <l =integer =
INTEGER
l <> l =integer =
INTEGER
l <= l =integer =
INTEGER
l >= l =integer =
INTEGER
l andalso l =integer =
INTEGER
l orelse l =integer =
INTEGER

math ops (l, ul):

l + ul =max =
LONG
l -ul =max =
LONG
l * ul =max =
LONG
l / ul =float =
DOUBLE
l ^ ul =float =
DOUBLE
l \ ul =non-float =
LONG
l mod ul =non-float =
LONG

bitops (l, ul):

l shl ul =non-float =
LONG
l shr ul =non-float =
LONG
l and ul =non-float =
LONG
l or ul =non-float =
LONG
l xor ul =non-float =
LONG
l eqv ul =non-float =
LONG
l imp ul =non-float =
LONG

relational ops (l, ul):

l =ul =integer =
INTEGER
l >ul =integer =
INTEGER
l <ul =integer =
INTEGER
l <> ul =integer =
INTEGER
l <= ul =integer =
INTEGER
l >= ul =integer =
INTEGER
l andalso ul =integer =
INTEGER
l orelse ul =integer =
INTEGER

math ops (l, ll):

l + ll =max =
LONGINT
l -ll =max =
LONGINT
l * ll =max =
LONGINT
l / ll =float =
DOUBLE
l ^ ll =float =
DOUBLE
l \ ll =non-float =
LONGINT
l mod ll =non-float =
LONGINT

bitops (l, ll):

l shl ll =non-float =
LONGINT
l shr ll =non-float =
LONGINT
l and ll =non-float =
LONGINT
l or ll =non-float =
LONGINT
l xor ll =non-float =
LONGINT
l eqv ll =non-float =
LONGINT
l imp ll =non-float =
LONGINT

relational ops (l, ll):

l =ll =integer =
INTEGER
l >ll =integer =
INTEGER
l <ll =integer =
INTEGER
l <> ll =integer =
INTEGER
l <= ll =integer =
INTEGER
l >= ll =integer =
INTEGER
l andalso ll =integer =
INTEGER
l orelse ll =integer =
INTEGER

math ops (l, ull):

l + ull =max =
ULONGINT
l -ull =max =
ULONGINT
l * ull =max =
ULONGINT
l / ull =float =
DOUBLE
l ^ ull =float =
DOUBLE
l \ ull =non-float =
ULONGINT
l mod ull =non-float =
ULONGINT

bitops (l, ull):

l shl ull =non-float =
ULONGINT
l shr ull =non-float =
ULONGINT
l and ull =non-float =
ULONGINT
l or ull =non-float =
ULONGINT
l xor ull =non-float =
ULONGINT
l eqv ull =non-float =
ULONGINT
l imp ull =non-float =
ULONGINT

relational ops (l, ull):

l =ull =integer =
INTEGER
l >ull =integer =
INTEGER
l <ull =integer =
INTEGER
l <> ull =integer =
INTEGER
l <= ull =integer =
INTEGER
l >= ull =integer =
INTEGER
l andalso ull =integer =
INTEGER
l orelse ull =integer =
INTEGER

math ops (l, enum1a):

l + enum1a =max =
ENUM1
l -enum1a =max =
ENUM1
l * enum1a =max =
ENUM1
l / enum1a =float =
DOUBLE
l ^ enum1a =float =
DOUBLE
l \ enum1a =non-float =
ENUM1
l mod enum1a =non-float =
ENUM1

bitops (l, enum1a):

l shl enum1a =non-float =
ENUM1
l shr enum1a =non-float =
ENUM1
l and enum1a =non-float =
ENUM1
l or enum1a =non-float =
ENUM1
l xor enum1a =non-float =
ENUM1
l eqv enum1a =non-float =
ENUM1
l imp enum1a =non-float =
ENUM1

relational ops (l, enum1a):

l =enum1a =integer =
INTEGER
l >enum1a =integer =
INTEGER
l <enum1a =integer =
INTEGER
l <> enum1a =integer =
INTEGER
l <= enum1a =integer =
INTEGER
l >= enum1a =integer =
INTEGER
l andalso enum1a =integer =
INTEGER
l orelse enum1a =integer =
INTEGER

math ops (b, l):

b + l =max =
INTEGER
b -l =max =
INTEGER
b * l =max =
INTEGER
b / l =float =
DOUBLE
b ^ l =float =
DOUBLE
b \ l =non-float =
INTEGER
b mod l =non-float =
INTEGER

bitops (b, l):

b shl l =non-float =
INTEGER
b shr l =non-float =
INTEGER
b and l =non-float =
INTEGER
b or l =non-float =
INTEGER
b xor l =non-float =
INTEGER
b eqv l =non-float =
INTEGER
b imp l =non-float =
INTEGER

relational ops (b, l):

b =l =integer =
INTEGER
b >l =integer =
INTEGER
b <l =integer =
INTEGER
b <> l =integer =
INTEGER
b <= l =integer =
INTEGER
b >= l =integer =
INTEGER
b andalso l =integer =
INTEGER
b orelse l =integer =
INTEGER

math ops (ub, l):

ub + l =max =
UINTEGER
ub -l =max =
UINTEGER
ub * l =max =
UINTEGER
ub / l =float =
DOUBLE
ub ^ l =float =
DOUBLE
ub \ l =non-float =
UINTEGER
ub mod l =non-float =
UINTEGER

bitops (ub, l):

ub shl l =non-float =
UINTEGER
ub shr l =non-float =
UINTEGER
ub and l =non-float =
UINTEGER
ub or l =non-float =
UINTEGER
ub xor l =non-float =
UINTEGER
ub eqv l =non-float =
UINTEGER
ub imp l =non-float =
UINTEGER

relational ops (ub, l):

ub =l =integer =
INTEGER
ub >l =integer =
INTEGER
ub <l =integer =
INTEGER
ub <> l =integer =
INTEGER
ub <= l =integer =
INTEGER
ub >= l =integer =
INTEGER
ub andalso l =integer =
INTEGER
ub orelse l =integer =
INTEGER

math ops (sh, l):

sh + l =max =
LONG
sh -l =max =
LONG
sh * l =max =
LONG
sh / l =float =
DOUBLE
sh ^ l =float =
DOUBLE
sh \ l =non-float =
LONG
sh mod l =non-float =
LONG

bitops (sh, l):

sh shl l =non-float =
LONG
sh shr l =non-float =
LONG
sh and l =non-float =
LONG
sh or l =non-float =
LONG
sh xor l =non-float =
LONG
sh eqv l =non-float =
LONG
sh imp l =non-float =
LONG

relational ops (sh, l):

sh =l =integer =
INTEGER
sh >l =integer =
INTEGER
sh <l =integer =
INTEGER
sh <> l =integer =
INTEGER
sh <= l =integer =
INTEGER
sh >= l =integer =
INTEGER
sh andalso l =integer =
INTEGER
sh orelse l =integer =
INTEGER

math ops (ush, l):

ush + l =max =
LONG
ush -l =max =
LONG
ush * l =max =
LONG
ush / l =float =
DOUBLE
ush ^ l =float =
DOUBLE
ush \ l =non-float =
LONG
ush mod l =non-float =
LONG

bitops (ush, l):

ush shl l =non-float =
LONG
ush shr l =non-float =
LONG
ush and l =non-float =
LONG
ush or l =non-float =
LONG
ush xor l =non-float =
LONG
ush eqv l =non-float =
LONG
ush imp l =non-float =
LONG

relational ops (ush, l):

ush =l =integer =
INTEGER
ush >l =integer =
INTEGER
ush <l =integer =
INTEGER
ush <> l =integer =
INTEGER
ush <= l =integer =
INTEGER
ush >= l =integer =
INTEGER
ush andalso l =integer =
INTEGER
ush orelse l =integer =
INTEGER

math ops (i, l):

i + l =max =
INTEGER
i -l =max =
INTEGER
i * l =max =
INTEGER
i / l =float =
DOUBLE
i ^ l =float =
DOUBLE
i \ l =non-float =
INTEGER
i mod l =non-float =
INTEGER

bitops (i, l):

i shl l =non-float =
INTEGER
i shr l =non-float =
INTEGER
i and l =non-float =
INTEGER
i or l =non-float =
INTEGER
i xor l =non-float =
INTEGER
i eqv l =non-float =
INTEGER
i imp l =non-float =
INTEGER

relational ops (i, l):

i =l =integer =
INTEGER
i >l =integer =
INTEGER
i <l =integer =
INTEGER
i <> l =integer =
INTEGER
i <= l =integer =
INTEGER
i >= l =integer =
INTEGER
i andalso l =integer =
INTEGER
i orelse l =integer =
INTEGER

math ops (ui, l):

ui + l =max =
UINTEGER
ui -l =max =
UINTEGER
ui * l =max =
UINTEGER
ui / l =float =
DOUBLE
ui ^ l =float =
DOUBLE
ui \ l =non-float =
UINTEGER
ui mod l =non-float =
UINTEGER

bitops (ui, l):

ui shl l =non-float =
UINTEGER
ui shr l =non-float =
UINTEGER
ui and l =non-float =
UINTEGER
ui or l =non-float =
UINTEGER
ui xor l =non-float =
UINTEGER
ui eqv l =non-float =
UINTEGER
ui imp l =non-float =
UINTEGER

relational ops (ui, l):

ui =l =integer =
INTEGER
ui >l =integer =
INTEGER
ui <l =integer =
INTEGER
ui <> l =integer =
INTEGER
ui <= l =integer =
INTEGER
ui >= l =integer =
INTEGER
ui andalso l =integer =
INTEGER
ui orelse l =integer =
INTEGER

math ops (l, l):

l + l =max =
LONG
l -l =max =
LONG
l * l =max =
LONG
l / l =float =
DOUBLE
l ^ l =float =
DOUBLE
l \ l =non-float =
LONG
l mod l =non-float =
LONG

bitops (l, l):

l shl l =non-float =
LONG
l shr l =non-float =
LONG
l and l =non-float =
LONG
l or l =non-float =
LONG
l xor l =non-float =
LONG
l eqv l =non-float =
LONG
l imp l =non-float =
LONG

relational ops (l, l):

l =l =integer =
INTEGER
l >l =integer =
INTEGER
l <l =integer =
INTEGER
l <> l =integer =
INTEGER
l <= l =integer =
INTEGER
l >= l =integer =
INTEGER
l andalso l =integer =
INTEGER
l orelse l =integer =
INTEGER

math ops (ul, l):

ul + l =max =
ULONG
ul -l =max =
ULONG
ul * l =max =
ULONG
ul / l =float =
DOUBLE
ul ^ l =float =
DOUBLE
ul \ l =non-float =
ULONG
ul mod l =non-float =
ULONG

bitops (ul, l):

ul shl l =non-float =
ULONG
ul shr l =non-float =
ULONG
ul and l =non-float =
ULONG
ul or l =non-float =
ULONG
ul xor l =non-float =
ULONG
ul eqv l =non-float =
ULONG
ul imp l =non-float =
ULONG

relational ops (ul, l):

ul =l =integer =
INTEGER
ul >l =integer =
INTEGER
ul <l =integer =
INTEGER
ul <> l =integer =
INTEGER
ul <= l =integer =
INTEGER
ul >= l =integer =
INTEGER
ul andalso l =integer =
INTEGER
ul orelse l =integer =
INTEGER

math ops (ll, l):

ll + l =max =
LONGINT
ll -l =max =
LONGINT
ll * l =max =
LONGINT
ll / l =float =
DOUBLE
ll ^ l =float =
DOUBLE
ll \ l =non-float =
LONGINT
ll mod l =non-float =
LONGINT

bitops (ll, l):

ll shl l =non-float =
LONGINT
ll shr l =non-float =
LONGINT
ll and l =non-float =
LONGINT
ll or l =non-float =
LONGINT
ll xor l =non-float =
LONGINT
ll eqv l =non-float =
LONGINT
ll imp l =non-float =
LONGINT

relational ops (ll, l):

ll =l =integer =
INTEGER
ll >l =integer =
INTEGER
ll <l =integer =
INTEGER
ll <> l =integer =
INTEGER
ll <= l =integer =
INTEGER
ll >= l =integer =
INTEGER
ll andalso l =integer =
INTEGER
ll orelse l =integer =
INTEGER

math ops (ull, l):

ull + l =max =
ULONGINT
ull -l =max =
ULONGINT
ull * l =max =
ULONGINT
ull / l =float =
DOUBLE
ull ^ l =float =
DOUBLE
ull \ l =non-float =
ULONGINT
ull mod l =non-float =
ULONGINT

bitops (ull, l):

ull shl l =non-float =
ULONGINT
ull shr l =non-float =
ULONGINT
ull and l =non-float =
ULONGINT
ull or l =non-float =
ULONGINT
ull xor l =non-float =
ULONGINT
ull eqv l =non-float =
ULONGINT
ull imp l =non-float =
ULONGINT

relational ops (ull, l):

ull =l =integer =
INTEGER
ull >l =integer =
INTEGER
ull <l =integer =
INTEGER
ull <> l =integer =
INTEGER
ull <= l =integer =
INTEGER
ull >= l =integer =
INTEGER
ull andalso l =integer =
INTEGER
ull orelse l =integer =
INTEGER

math ops (enum1a, l):

enum1a + l =max =
ENUM1
enum1a -l =max =
ENUM1
enum1a * l =max =
ENUM1
enum1a / l =float =
DOUBLE
enum1a ^ l =float =
DOUBLE
enum1a \ l =non-float =
ENUM1
enum1a mod l =non-float =
ENUM1

bitops (enum1a, l):

enum1a shl l =non-float =
ENUM1
enum1a shr l =non-float =
ENUM1
enum1a and l =non-float =
ENUM1
enum1a or l =non-float =
ENUM1
enum1a xor l =non-float =
ENUM1
enum1a eqv l =non-float =
ENUM1
enum1a imp l =non-float =
ENUM1

relational ops (enum1a, l):

enum1a =l =integer =
INTEGER
enum1a >l =integer =
INTEGER
enum1a <l =integer =
INTEGER
enum1a <> l =integer =
INTEGER
enum1a <= l =integer =
INTEGER
enum1a >= l =integer =
INTEGER
enum1a andalso l =integer =
INTEGER
enum1a orelse l =integer =
INTEGER

math ops (l, f):

l + f =max =
SINGLE
l -f =max =
SINGLE
l * f =max =
SINGLE
l / f =float =
DOUBLE
l ^ f =float =
DOUBLE
l \ f =non-float =
LONG
l mod f =non-float =
LONG

bitops (l, f):

l shl f =non-float =
LONG
l shr f =non-float =
LONG
l and f =non-float =
LONG
l or f =non-float =
LONG
l xor f =non-float =
LONG
l eqv f =non-float =
LONG
l imp f =non-float =
LONG

relational ops (l, f):

l =f =integer =
INTEGER
l >f =integer =
INTEGER
l <f =integer =
INTEGER
l <> f =integer =
INTEGER
l <= f =integer =
INTEGER
l >= f =integer =
INTEGER
l andalso f =integer =
INTEGER
l orelse f =integer =
INTEGER

math ops (l, d):

l + d =max =
DOUBLE
l -d =max =
DOUBLE
l * d =max =
DOUBLE
l / d =float =
DOUBLE
l ^ d =float =
DOUBLE
l \ d =non-float =
LONG
l mod d =non-float =
LONG

bitops (l, d):

l shl d =non-float =
LONG
l shr d =non-float =
LONG
l and d =non-float =
LONG
l or d =non-float =
LONG
l xor d =non-float =
LONG
l eqv d =non-float =
LONG
l imp d =non-float =
LONG

relational ops (l, d):

l =d =integer =
INTEGER
l >d =integer =
INTEGER
l <d =integer =
INTEGER
l <> d =integer =
INTEGER
l <= d =integer =
INTEGER
l >= d =integer =
INTEGER
l andalso d =integer =
INTEGER
l orelse d =integer =
INTEGER

math ops (f, l):

f + l =max =
SINGLE
f -l =max =
SINGLE
f * l =max =
SINGLE
f / l =float =
DOUBLE
f ^ l =float =
DOUBLE
f \ l =non-float =
INTEGER
f mod l =non-float =
INTEGER

bitops (f, l):

f shl l =non-float =
INTEGER
f shr l =non-float =
INTEGER
f and l =non-float =
INTEGER
f or l =non-float =
INTEGER
f xor l =non-float =
INTEGER
f eqv l =non-float =
INTEGER
f imp l =non-float =
INTEGER

relational ops (f, l):

f =l =integer =
INTEGER
f >l =integer =
INTEGER
f <l =integer =
INTEGER
f <> l =integer =
INTEGER
f <= l =integer =
INTEGER
f >= l =integer =
INTEGER
f andalso l =integer =
INTEGER
f orelse l =integer =
INTEGER

math ops (d, l):

d + l =max =
DOUBLE
d -l =max =
DOUBLE
d * l =max =
DOUBLE
d / l =float =
DOUBLE
d ^ l =float =
DOUBLE
d \ l =non-float =
INTEGER
d mod l =non-float =
INTEGER

bitops (d, l):

d shl l =non-float =
INTEGER
d shr l =non-float =
INTEGER
d and l =non-float =
INTEGER
d or l =non-float =
INTEGER
d xor l =non-float =
INTEGER
d eqv l =non-float =
INTEGER
d imp l =non-float =
INTEGER

relational ops (d, l):

d =l =integer =
INTEGER
d >l =integer =
INTEGER
d <l =integer =
INTEGER
d <> l =integer =
INTEGER
d <= l =integer =
INTEGER
d >= l =integer =
INTEGER
d andalso l =integer =
INTEGER
d orelse l =integer =
INTEGER

-----ul -----------------------------------------------------


math ops (ul, b):

ul + b =max =
ULONG
ul -b =max =
ULONG
ul * b =max =
ULONG
ul / b =float =
DOUBLE
ul ^ b =float =
DOUBLE
ul \ b =non-float =
ULONG
ul mod b =non-float =
ULONG

bitops (ul, b):

ul shl b =non-float =
ULONG
ul shr b =non-float =
ULONG
ul and b =non-float =
ULONG
ul or b =non-float =
ULONG
ul xor b =non-float =
ULONG
ul eqv b =non-float =
ULONG
ul imp b =non-float =
ULONG

relational ops (ul, b):

ul =b =integer =
INTEGER
ul >b =integer =
INTEGER
ul <b =integer =
INTEGER
ul <> b =integer =
INTEGER
ul <= b =integer =
INTEGER
ul >= b =integer =
INTEGER
ul andalso b =integer =
INTEGER
ul orelse b =integer =
INTEGER

math ops (ul, ub):

ul + ub =max =
ULONG
ul -ub =max =
ULONG
ul * ub =max =
ULONG
ul / ub =float =
DOUBLE
ul ^ ub =float =
DOUBLE
ul \ ub =non-float =
ULONG
ul mod ub =non-float =
ULONG

bitops (ul, ub):

ul shl ub =non-float =
ULONG
ul shr ub =non-float =
ULONG
ul and ub =non-float =
ULONG
ul or ub =non-float =
ULONG
ul xor ub =non-float =
ULONG
ul eqv ub =non-float =
ULONG
ul imp ub =non-float =
ULONG

relational ops (ul, ub):

ul =ub =integer =
INTEGER
ul >ub =integer =
INTEGER
ul <ub =integer =
INTEGER
ul <> ub =integer =
INTEGER
ul <= ub =integer =
INTEGER
ul >= ub =integer =
INTEGER
ul andalso ub =integer =
INTEGER
ul orelse ub =integer =
INTEGER

math ops (ul, sh):

ul + sh =max =
ULONG
ul -sh =max =
ULONG
ul * sh =max =
ULONG
ul / sh =float =
DOUBLE
ul ^ sh =float =
DOUBLE
ul \ sh =non-float =
ULONG
ul mod sh =non-float =
ULONG

bitops (ul, sh):

ul shl sh =non-float =
ULONG
ul shr sh =non-float =
ULONG
ul and sh =non-float =
ULONG
ul or sh =non-float =
ULONG
ul xor sh =non-float =
ULONG
ul eqv sh =non-float =
ULONG
ul imp sh =non-float =
ULONG

relational ops (ul, sh):

ul =sh =integer =
INTEGER
ul >sh =integer =
INTEGER
ul <sh =integer =
INTEGER
ul <> sh =integer =
INTEGER
ul <= sh =integer =
INTEGER
ul >= sh =integer =
INTEGER
ul andalso sh =integer =
INTEGER
ul orelse sh =integer =
INTEGER

math ops (ul, ush):

ul + ush =max =
ULONG
ul -ush =max =
ULONG
ul * ush =max =
ULONG
ul / ush =float =
DOUBLE
ul ^ ush =float =
DOUBLE
ul \ ush =non-float =
ULONG
ul mod ush =non-float =
ULONG

bitops (ul, ush):

ul shl ush =non-float =
ULONG
ul shr ush =non-float =
ULONG
ul and ush =non-float =
ULONG
ul or ush =non-float =
ULONG
ul xor ush =non-float =
ULONG
ul eqv ush =non-float =
ULONG
ul imp ush =non-float =
ULONG

relational ops (ul, ush):

ul =ush =integer =
INTEGER
ul >ush =integer =
INTEGER
ul <ush =integer =
INTEGER
ul <> ush =integer =
INTEGER
ul <= ush =integer =
INTEGER
ul >= ush =integer =
INTEGER
ul andalso ush =integer =
INTEGER
ul orelse ush =integer =
INTEGER

math ops (ul, i):

ul + i =max =
ULONG
ul -i =max =
ULONG
ul * i =max =
ULONG
ul / i =float =
DOUBLE
ul ^ i =float =
DOUBLE
ul \ i =non-float =
ULONG
ul mod i =non-float =
ULONG

bitops (ul, i):

ul shl i =non-float =
ULONG
ul shr i =non-float =
ULONG
ul and i =non-float =
ULONG
ul or i =non-float =
ULONG
ul xor i =non-float =
ULONG
ul eqv i =non-float =
ULONG
ul imp i =non-float =
ULONG

relational ops (ul, i):

ul =i =integer =
INTEGER
ul >i =integer =
INTEGER
ul <i =integer =
INTEGER
ul <> i =integer =
INTEGER
ul <= i =integer =
INTEGER
ul >= i =integer =
INTEGER
ul andalso i =integer =
INTEGER
ul orelse i =integer =
INTEGER

math ops (ul, ui):

ul + ui =max =
ULONG
ul -ui =max =
ULONG
ul * ui =max =
ULONG
ul / ui =float =
DOUBLE
ul ^ ui =float =
DOUBLE
ul \ ui =non-float =
ULONG
ul mod ui =non-float =
ULONG

bitops (ul, ui):

ul shl ui =non-float =
ULONG
ul shr ui =non-float =
ULONG
ul and ui =non-float =
ULONG
ul or ui =non-float =
ULONG
ul xor ui =non-float =
ULONG
ul eqv ui =non-float =
ULONG
ul imp ui =non-float =
ULONG

relational ops (ul, ui):

ul =ui =integer =
INTEGER
ul >ui =integer =
INTEGER
ul <ui =integer =
INTEGER
ul <> ui =integer =
INTEGER
ul <= ui =integer =
INTEGER
ul >= ui =integer =
INTEGER
ul andalso ui =integer =
INTEGER
ul orelse ui =integer =
INTEGER

math ops (ul, l):

ul + l =max =
ULONG
ul -l =max =
ULONG
ul * l =max =
ULONG
ul / l =float =
DOUBLE
ul ^ l =float =
DOUBLE
ul \ l =non-float =
ULONG
ul mod l =non-float =
ULONG

bitops (ul, l):

ul shl l =non-float =
ULONG
ul shr l =non-float =
ULONG
ul and l =non-float =
ULONG
ul or l =non-float =
ULONG
ul xor l =non-float =
ULONG
ul eqv l =non-float =
ULONG
ul imp l =non-float =
ULONG

relational ops (ul, l):

ul =l =integer =
INTEGER
ul >l =integer =
INTEGER
ul <l =integer =
INTEGER
ul <> l =integer =
INTEGER
ul <= l =integer =
INTEGER
ul >= l =integer =
INTEGER
ul andalso l =integer =
INTEGER
ul orelse l =integer =
INTEGER

math ops (ul, ul):

ul + ul =max =
ULONG
ul -ul =max =
ULONG
ul * ul =max =
ULONG
ul / ul =float =
DOUBLE
ul ^ ul =float =
DOUBLE
ul \ ul =non-float =
ULONG
ul mod ul =non-float =
ULONG

bitops (ul, ul):

ul shl ul =non-float =
ULONG
ul shr ul =non-float =
ULONG
ul and ul =non-float =
ULONG
ul or ul =non-float =
ULONG
ul xor ul =non-float =
ULONG
ul eqv ul =non-float =
ULONG
ul imp ul =non-float =
ULONG

relational ops (ul, ul):

ul =ul =integer =
INTEGER
ul >ul =integer =
INTEGER
ul <ul =integer =
INTEGER
ul <> ul =integer =
INTEGER
ul <= ul =integer =
INTEGER
ul >= ul =integer =
INTEGER
ul andalso ul =integer =
INTEGER
ul orelse ul =integer =
INTEGER

math ops (ul, ll):

ul + ll =max =
LONGINT
ul -ll =max =
LONGINT
ul * ll =max =
LONGINT
ul / ll =float =
DOUBLE
ul ^ ll =float =
DOUBLE
ul \ ll =non-float =
LONGINT
ul mod ll =non-float =
LONGINT

bitops (ul, ll):

ul shl ll =non-float =
LONGINT
ul shr ll =non-float =
LONGINT
ul and ll =non-float =
LONGINT
ul or ll =non-float =
LONGINT
ul xor ll =non-float =
LONGINT
ul eqv ll =non-float =
LONGINT
ul imp ll =non-float =
LONGINT

relational ops (ul, ll):

ul =ll =integer =
INTEGER
ul >ll =integer =
INTEGER
ul <ll =integer =
INTEGER
ul <> ll =integer =
INTEGER
ul <= ll =integer =
INTEGER
ul >= ll =integer =
INTEGER
ul andalso ll =integer =
INTEGER
ul orelse ll =integer =
INTEGER

math ops (ul, ull):

ul + ull =max =
ULONGINT
ul -ull =max =
ULONGINT
ul * ull =max =
ULONGINT
ul / ull =float =
DOUBLE
ul ^ ull =float =
DOUBLE
ul \ ull =non-float =
ULONGINT
ul mod ull =non-float =
ULONGINT

bitops (ul, ull):

ul shl ull =non-float =
ULONGINT
ul shr ull =non-float =
ULONGINT
ul and ull =non-float =
ULONGINT
ul or ull =non-float =
ULONGINT
ul xor ull =non-float =
ULONGINT
ul eqv ull =non-float =
ULONGINT
ul imp ull =non-float =
ULONGINT

relational ops (ul, ull):

ul =ull =integer =
INTEGER
ul >ull =integer =
INTEGER
ul <ull =integer =
INTEGER
ul <> ull =integer =
INTEGER
ul <= ull =integer =
INTEGER
ul >= ull =integer =
INTEGER
ul andalso ull =integer =
INTEGER
ul orelse ull =integer =
INTEGER

math ops (ul, enum1a):

ul + enum1a =max =
ENUM1
ul -enum1a =max =
ENUM1
ul * enum1a =max =
ENUM1
ul / enum1a =float =
DOUBLE
ul ^ enum1a =float =
DOUBLE
ul \ enum1a =non-float =
ENUM1
ul mod enum1a =non-float =
ENUM1

bitops (ul, enum1a):

ul shl enum1a =non-float =
ENUM1
ul shr enum1a =non-float =
ENUM1
ul and enum1a =non-float =
ENUM1
ul or enum1a =non-float =
ENUM1
ul xor enum1a =non-float =
ENUM1
ul eqv enum1a =non-float =
ENUM1
ul imp enum1a =non-float =
ENUM1

relational ops (ul, enum1a):

ul =enum1a =integer =
INTEGER
ul >enum1a =integer =
INTEGER
ul <enum1a =integer =
INTEGER
ul <> enum1a =integer =
INTEGER
ul <= enum1a =integer =
INTEGER
ul >= enum1a =integer =
INTEGER
ul andalso enum1a =integer =
INTEGER
ul orelse enum1a =integer =
INTEGER

math ops (b, ul):

b + ul =max =
INTEGER
b -ul =max =
INTEGER
b * ul =max =
INTEGER
b / ul =float =
DOUBLE
b ^ ul =float =
DOUBLE
b \ ul =non-float =
INTEGER
b mod ul =non-float =
INTEGER

bitops (b, ul):

b shl ul =non-float =
INTEGER
b shr ul =non-float =
INTEGER
b and ul =non-float =
INTEGER
b or ul =non-float =
INTEGER
b xor ul =non-float =
INTEGER
b eqv ul =non-float =
INTEGER
b imp ul =non-float =
INTEGER

relational ops (b, ul):

b =ul =integer =
INTEGER
b >ul =integer =
INTEGER
b <ul =integer =
INTEGER
b <> ul =integer =
INTEGER
b <= ul =integer =
INTEGER
b >= ul =integer =
INTEGER
b andalso ul =integer =
INTEGER
b orelse ul =integer =
INTEGER

math ops (ub, ul):

ub + ul =max =
UINTEGER
ub -ul =max =
UINTEGER
ub * ul =max =
UINTEGER
ub / ul =float =
DOUBLE
ub ^ ul =float =
DOUBLE
ub \ ul =non-float =
UINTEGER
ub mod ul =non-float =
UINTEGER

bitops (ub, ul):

ub shl ul =non-float =
UINTEGER
ub shr ul =non-float =
UINTEGER
ub and ul =non-float =
UINTEGER
ub or ul =non-float =
UINTEGER
ub xor ul =non-float =
UINTEGER
ub eqv ul =non-float =
UINTEGER
ub imp ul =non-float =
UINTEGER

relational ops (ub, ul):

ub =ul =integer =
INTEGER
ub >ul =integer =
INTEGER
ub <ul =integer =
INTEGER
ub <> ul =integer =
INTEGER
ub <= ul =integer =
INTEGER
ub >= ul =integer =
INTEGER
ub andalso ul =integer =
INTEGER
ub orelse ul =integer =
INTEGER

math ops (sh, ul):

sh + ul =max =
ULONG
sh -ul =max =
ULONG
sh * ul =max =
ULONG
sh / ul =float =
DOUBLE
sh ^ ul =float =
DOUBLE
sh \ ul =non-float =
ULONG
sh mod ul =non-float =
ULONG

bitops (sh, ul):

sh shl ul =non-float =
ULONG
sh shr ul =non-float =
ULONG
sh and ul =non-float =
ULONG
sh or ul =non-float =
ULONG
sh xor ul =non-float =
ULONG
sh eqv ul =non-float =
ULONG
sh imp ul =non-float =
ULONG

relational ops (sh, ul):

sh =ul =integer =
INTEGER
sh >ul =integer =
INTEGER
sh <ul =integer =
INTEGER
sh <> ul =integer =
INTEGER
sh <= ul =integer =
INTEGER
sh >= ul =integer =
INTEGER
sh andalso ul =integer =
INTEGER
sh orelse ul =integer =
INTEGER

math ops (ush, ul):

ush + ul =max =
ULONG
ush -ul =max =
ULONG
ush * ul =max =
ULONG
ush / ul =float =
DOUBLE
ush ^ ul =float =
DOUBLE
ush \ ul =non-float =
ULONG
ush mod ul =non-float =
ULONG

bitops (ush, ul):

ush shl ul =non-float =
ULONG
ush shr ul =non-float =
ULONG
ush and ul =non-float =
ULONG
ush or ul =non-float =
ULONG
ush xor ul =non-float =
ULONG
ush eqv ul =non-float =
ULONG
ush imp ul =non-float =
ULONG

relational ops (ush, ul):

ush =ul =integer =
INTEGER
ush >ul =integer =
INTEGER
ush <ul =integer =
INTEGER
ush <> ul =integer =
INTEGER
ush <= ul =integer =
INTEGER
ush >= ul =integer =
INTEGER
ush andalso ul =integer =
INTEGER
ush orelse ul =integer =
INTEGER

math ops (i, ul):

i + ul =max =
INTEGER
i -ul =max =
INTEGER
i * ul =max =
INTEGER
i / ul =float =
DOUBLE
i ^ ul =float =
DOUBLE
i \ ul =non-float =
INTEGER
i mod ul =non-float =
INTEGER

bitops (i, ul):

i shl ul =non-float =
INTEGER
i shr ul =non-float =
INTEGER
i and ul =non-float =
INTEGER
i or ul =non-float =
INTEGER
i xor ul =non-float =
INTEGER
i eqv ul =non-float =
INTEGER
i imp ul =non-float =
INTEGER

relational ops (i, ul):

i =ul =integer =
INTEGER
i >ul =integer =
INTEGER
i <ul =integer =
INTEGER
i <> ul =integer =
INTEGER
i <= ul =integer =
INTEGER
i >= ul =integer =
INTEGER
i andalso ul =integer =
INTEGER
i orelse ul =integer =
INTEGER

math ops (ui, ul):

ui + ul =max =
UINTEGER
ui -ul =max =
UINTEGER
ui * ul =max =
UINTEGER
ui / ul =float =
DOUBLE
ui ^ ul =float =
DOUBLE
ui \ ul =non-float =
UINTEGER
ui mod ul =non-float =
UINTEGER

bitops (ui, ul):

ui shl ul =non-float =
UINTEGER
ui shr ul =non-float =
UINTEGER
ui and ul =non-float =
UINTEGER
ui or ul =non-float =
UINTEGER
ui xor ul =non-float =
UINTEGER
ui eqv ul =non-float =
UINTEGER
ui imp ul =non-float =
UINTEGER

relational ops (ui, ul):

ui =ul =integer =
INTEGER
ui >ul =integer =
INTEGER
ui <ul =integer =
INTEGER
ui <> ul =integer =
INTEGER
ui <= ul =integer =
INTEGER
ui >= ul =integer =
INTEGER
ui andalso ul =integer =
INTEGER
ui orelse ul =integer =
INTEGER

math ops (l, ul):

l + ul =max =
LONG
l -ul =max =
LONG
l * ul =max =
LONG
l / ul =float =
DOUBLE
l ^ ul =float =
DOUBLE
l \ ul =non-float =
LONG
l mod ul =non-float =
LONG

bitops (l, ul):

l shl ul =non-float =
LONG
l shr ul =non-float =
LONG
l and ul =non-float =
LONG
l or ul =non-float =
LONG
l xor ul =non-float =
LONG
l eqv ul =non-float =
LONG
l imp ul =non-float =
LONG

relational ops (l, ul):

l =ul =integer =
INTEGER
l >ul =integer =
INTEGER
l <ul =integer =
INTEGER
l <> ul =integer =
INTEGER
l <= ul =integer =
INTEGER
l >= ul =integer =
INTEGER
l andalso ul =integer =
INTEGER
l orelse ul =integer =
INTEGER

math ops (ul, ul):

ul + ul =max =
ULONG
ul -ul =max =
ULONG
ul * ul =max =
ULONG
ul / ul =float =
DOUBLE
ul ^ ul =float =
DOUBLE
ul \ ul =non-float =
ULONG
ul mod ul =non-float =
ULONG

bitops (ul, ul):

ul shl ul =non-float =
ULONG
ul shr ul =non-float =
ULONG
ul and ul =non-float =
ULONG
ul or ul =non-float =
ULONG
ul xor ul =non-float =
ULONG
ul eqv ul =non-float =
ULONG
ul imp ul =non-float =
ULONG

relational ops (ul, ul):

ul =ul =integer =
INTEGER
ul >ul =integer =
INTEGER
ul <ul =integer =
INTEGER
ul <> ul =integer =
INTEGER
ul <= ul =integer =
INTEGER
ul >= ul =integer =
INTEGER
ul andalso ul =integer =
INTEGER
ul orelse ul =integer =
INTEGER

math ops (ll, ul):

ll + ul =max =
LONGINT
ll -ul =max =
LONGINT
ll * ul =max =
LONGINT
ll / ul =float =
DOUBLE
ll ^ ul =float =
DOUBLE
ll \ ul =non-float =
LONGINT
ll mod ul =non-float =
LONGINT

bitops (ll, ul):

ll shl ul =non-float =
LONGINT
ll shr ul =non-float =
LONGINT
ll and ul =non-float =
LONGINT
ll or ul =non-float =
LONGINT
ll xor ul =non-float =
LONGINT
ll eqv ul =non-float =
LONGINT
ll imp ul =non-float =
LONGINT

relational ops (ll, ul):

ll =ul =integer =
INTEGER
ll >ul =integer =
INTEGER
ll <ul =integer =
INTEGER
ll <> ul =integer =
INTEGER
ll <= ul =integer =
INTEGER
ll >= ul =integer =
INTEGER
ll andalso ul =integer =
INTEGER
ll orelse ul =integer =
INTEGER

math ops (ull, ul):

ull + ul =max =
ULONGINT
ull -ul =max =
ULONGINT
ull * ul =max =
ULONGINT
ull / ul =float =
DOUBLE
ull ^ ul =float =
DOUBLE
ull \ ul =non-float =
ULONGINT
ull mod ul =non-float =
ULONGINT

bitops (ull, ul):

ull shl ul =non-float =
ULONGINT
ull shr ul =non-float =
ULONGINT
ull and ul =non-float =
ULONGINT
ull or ul =non-float =
ULONGINT
ull xor ul =non-float =
ULONGINT
ull eqv ul =non-float =
ULONGINT
ull imp ul =non-float =
ULONGINT

relational ops (ull, ul):

ull =ul =integer =
INTEGER
ull >ul =integer =
INTEGER
ull <ul =integer =
INTEGER
ull <> ul =integer =
INTEGER
ull <= ul =integer =
INTEGER
ull >= ul =integer =
INTEGER
ull andalso ul =integer =
INTEGER
ull orelse ul =integer =
INTEGER

math ops (enum1a, ul):

enum1a + ul =max =
ENUM1
enum1a -ul =max =
ENUM1
enum1a * ul =max =
ENUM1
enum1a / ul =float =
DOUBLE
enum1a ^ ul =float =
DOUBLE
enum1a \ ul =non-float =
ENUM1
enum1a mod ul =non-float =
ENUM1

bitops (enum1a, ul):

enum1a shl ul =non-float =
ENUM1
enum1a shr ul =non-float =
ENUM1
enum1a and ul =non-float =
ENUM1
enum1a or ul =non-float =
ENUM1
enum1a xor ul =non-float =
ENUM1
enum1a eqv ul =non-float =
ENUM1
enum1a imp ul =non-float =
ENUM1

relational ops (enum1a, ul):

enum1a =ul =integer =
INTEGER
enum1a >ul =integer =
INTEGER
enum1a <ul =integer =
INTEGER
enum1a <> ul =integer =
INTEGER
enum1a <= ul =integer =
INTEGER
enum1a >= ul =integer =
INTEGER
enum1a andalso ul =integer =
INTEGER
enum1a orelse ul =integer =
INTEGER

math ops (ul, f):

ul + f =max =
SINGLE
ul -f =max =
SINGLE
ul * f =max =
SINGLE
ul / f =float =
DOUBLE
ul ^ f =float =
DOUBLE
ul \ f =non-float =
ULONG
ul mod f =non-float =
ULONG

bitops (ul, f):

ul shl f =non-float =
ULONG
ul shr f =non-float =
ULONG
ul and f =non-float =
ULONG
ul or f =non-float =
ULONG
ul xor f =non-float =
ULONG
ul eqv f =non-float =
ULONG
ul imp f =non-float =
ULONG

relational ops (ul, f):

ul =f =integer =
INTEGER
ul >f =integer =
INTEGER
ul <f =integer =
INTEGER
ul <> f =integer =
INTEGER
ul <= f =integer =
INTEGER
ul >= f =integer =
INTEGER
ul andalso f =integer =
INTEGER
ul orelse f =integer =
INTEGER

math ops (ul, d):

ul + d =max =
DOUBLE
ul -d =max =
DOUBLE
ul * d =max =
DOUBLE
ul / d =float =
DOUBLE
ul ^ d =float =
DOUBLE
ul \ d =non-float =
ULONG
ul mod d =non-float =
ULONG

bitops (ul, d):

ul shl d =non-float =
ULONG
ul shr d =non-float =
ULONG
ul and d =non-float =
ULONG
ul or d =non-float =
ULONG
ul xor d =non-float =
ULONG
ul eqv d =non-float =
ULONG
ul imp d =non-float =
ULONG

relational ops (ul, d):

ul =d =integer =
INTEGER
ul >d =integer =
INTEGER
ul <d =integer =
INTEGER
ul <> d =integer =
INTEGER
ul <= d =integer =
INTEGER
ul >= d =integer =
INTEGER
ul andalso d =integer =
INTEGER
ul orelse d =integer =
INTEGER

math ops (f, ul):

f + ul =max =
SINGLE
f -ul =max =
SINGLE
f * ul =max =
SINGLE
f / ul =float =
DOUBLE
f ^ ul =float =
DOUBLE
f \ ul =non-float =
INTEGER
f mod ul =non-float =
INTEGER

bitops (f, ul):

f shl ul =non-float =
INTEGER
f shr ul =non-float =
INTEGER
f and ul =non-float =
INTEGER
f or ul =non-float =
INTEGER
f xor ul =non-float =
INTEGER
f eqv ul =non-float =
INTEGER
f imp ul =non-float =
INTEGER

relational ops (f, ul):

f =ul =integer =
INTEGER
f >ul =integer =
INTEGER
f <ul =integer =
INTEGER
f <> ul =integer =
INTEGER
f <= ul =integer =
INTEGER
f >= ul =integer =
INTEGER
f andalso ul =integer =
INTEGER
f orelse ul =integer =
INTEGER

math ops (d, ul):

d + ul =max =
DOUBLE
d -ul =max =
DOUBLE
d * ul =max =
DOUBLE
d / ul =float =
DOUBLE
d ^ ul =float =
DOUBLE
d \ ul =non-float =
INTEGER
d mod ul =non-float =
INTEGER

bitops (d, ul):

d shl ul =non-float =
INTEGER
d shr ul =non-float =
INTEGER
d and ul =non-float =
INTEGER
d or ul =non-float =
INTEGER
d xor ul =non-float =
INTEGER
d eqv ul =non-float =
INTEGER
d imp ul =non-float =
INTEGER

relational ops (d, ul):

d =ul =integer =
INTEGER
d >ul =integer =
INTEGER
d <ul =integer =
INTEGER
d <> ul =integer =
INTEGER
d <= ul =integer =
INTEGER
d >= ul =integer =
INTEGER
d andalso ul =integer =
INTEGER
d orelse ul =integer =
INTEGER

-----ll -----------------------------------------------------


math ops (ll, b):

ll + b =max =
LONGINT
ll -b =max =
LONGINT
ll * b =max =
LONGINT
ll / b =float =
DOUBLE
ll ^ b =float =
DOUBLE
ll \ b =non-float =
LONGINT
ll mod b =non-float =
LONGINT

bitops (ll, b):

ll shl b =non-float =
LONGINT
ll shr b =non-float =
LONGINT
ll and b =non-float =
LONGINT
ll or b =non-float =
LONGINT
ll xor b =non-float =
LONGINT
ll eqv b =non-float =
LONGINT
ll imp b =non-float =
LONGINT

relational ops (ll, b):

ll =b =integer =
INTEGER
ll >b =integer =
INTEGER
ll <b =integer =
INTEGER
ll <> b =integer =
INTEGER
ll <= b =integer =
INTEGER
ll >= b =integer =
INTEGER
ll andalso b =integer =
INTEGER
ll orelse b =integer =
INTEGER

math ops (ll, ub):

ll + ub =max =
LONGINT
ll -ub =max =
LONGINT
ll * ub =max =
LONGINT
ll / ub =float =
DOUBLE
ll ^ ub =float =
DOUBLE
ll \ ub =non-float =
LONGINT
ll mod ub =non-float =
LONGINT

bitops (ll, ub):

ll shl ub =non-float =
LONGINT
ll shr ub =non-float =
LONGINT
ll and ub =non-float =
LONGINT
ll or ub =non-float =
LONGINT
ll xor ub =non-float =
LONGINT
ll eqv ub =non-float =
LONGINT
ll imp ub =non-float =
LONGINT

relational ops (ll, ub):

ll =ub =integer =
INTEGER
ll >ub =integer =
INTEGER
ll <ub =integer =
INTEGER
ll <> ub =integer =
INTEGER
ll <= ub =integer =
INTEGER
ll >= ub =integer =
INTEGER
ll andalso ub =integer =
INTEGER
ll orelse ub =integer =
INTEGER

math ops (ll, sh):

ll + sh =max =
LONGINT
ll -sh =max =
LONGINT
ll * sh =max =
LONGINT
ll / sh =float =
DOUBLE
ll ^ sh =float =
DOUBLE
ll \ sh =non-float =
LONGINT
ll mod sh =non-float =
LONGINT

bitops (ll, sh):

ll shl sh =non-float =
LONGINT
ll shr sh =non-float =
LONGINT
ll and sh =non-float =
LONGINT
ll or sh =non-float =
LONGINT
ll xor sh =non-float =
LONGINT
ll eqv sh =non-float =
LONGINT
ll imp sh =non-float =
LONGINT

relational ops (ll, sh):

ll =sh =integer =
INTEGER
ll >sh =integer =
INTEGER
ll <sh =integer =
INTEGER
ll <> sh =integer =
INTEGER
ll <= sh =integer =
INTEGER
ll >= sh =integer =
INTEGER
ll andalso sh =integer =
INTEGER
ll orelse sh =integer =
INTEGER

math ops (ll, ush):

ll + ush =max =
LONGINT
ll -ush =max =
LONGINT
ll * ush =max =
LONGINT
ll / ush =float =
DOUBLE
ll ^ ush =float =
DOUBLE
ll \ ush =non-float =
LONGINT
ll mod ush =non-float =
LONGINT

bitops (ll, ush):

ll shl ush =non-float =
LONGINT
ll shr ush =non-float =
LONGINT
ll and ush =non-float =
LONGINT
ll or ush =non-float =
LONGINT
ll xor ush =non-float =
LONGINT
ll eqv ush =non-float =
LONGINT
ll imp ush =non-float =
LONGINT

relational ops (ll, ush):

ll =ush =integer =
INTEGER
ll >ush =integer =
INTEGER
ll <ush =integer =
INTEGER
ll <> ush =integer =
INTEGER
ll <= ush =integer =
INTEGER
ll >= ush =integer =
INTEGER
ll andalso ush =integer =
INTEGER
ll orelse ush =integer =
INTEGER

math ops (ll, i):

ll + i =max =
LONGINT
ll -i =max =
LONGINT
ll * i =max =
LONGINT
ll / i =float =
DOUBLE
ll ^ i =float =
DOUBLE
ll \ i =non-float =
LONGINT
ll mod i =non-float =
LONGINT

bitops (ll, i):

ll shl i =non-float =
LONGINT
ll shr i =non-float =
LONGINT
ll and i =non-float =
LONGINT
ll or i =non-float =
LONGINT
ll xor i =non-float =
LONGINT
ll eqv i =non-float =
LONGINT
ll imp i =non-float =
LONGINT

relational ops (ll, i):

ll =i =integer =
INTEGER
ll >i =integer =
INTEGER
ll <i =integer =
INTEGER
ll <> i =integer =
INTEGER
ll <= i =integer =
INTEGER
ll >= i =integer =
INTEGER
ll andalso i =integer =
INTEGER
ll orelse i =integer =
INTEGER

math ops (ll, ui):

ll + ui =max =
LONGINT
ll -ui =max =
LONGINT
ll * ui =max =
LONGINT
ll / ui =float =
DOUBLE
ll ^ ui =float =
DOUBLE
ll \ ui =non-float =
LONGINT
ll mod ui =non-float =
LONGINT

bitops (ll, ui):

ll shl ui =non-float =
LONGINT
ll shr ui =non-float =
LONGINT
ll and ui =non-float =
LONGINT
ll or ui =non-float =
LONGINT
ll xor ui =non-float =
LONGINT
ll eqv ui =non-float =
LONGINT
ll imp ui =non-float =
LONGINT

relational ops (ll, ui):

ll =ui =integer =
INTEGER
ll >ui =integer =
INTEGER
ll <ui =integer =
INTEGER
ll <> ui =integer =
INTEGER
ll <= ui =integer =
INTEGER
ll >= ui =integer =
INTEGER
ll andalso ui =integer =
INTEGER
ll orelse ui =integer =
INTEGER

math ops (ll, l):

ll + l =max =
LONGINT
ll -l =max =
LONGINT
ll * l =max =
LONGINT
ll / l =float =
DOUBLE
ll ^ l =float =
DOUBLE
ll \ l =non-float =
LONGINT
ll mod l =non-float =
LONGINT

bitops (ll, l):

ll shl l =non-float =
LONGINT
ll shr l =non-float =
LONGINT
ll and l =non-float =
LONGINT
ll or l =non-float =
LONGINT
ll xor l =non-float =
LONGINT
ll eqv l =non-float =
LONGINT
ll imp l =non-float =
LONGINT

relational ops (ll, l):

ll =l =integer =
INTEGER
ll >l =integer =
INTEGER
ll <l =integer =
INTEGER
ll <> l =integer =
INTEGER
ll <= l =integer =
INTEGER
ll >= l =integer =
INTEGER
ll andalso l =integer =
INTEGER
ll orelse l =integer =
INTEGER

math ops (ll, ul):

ll + ul =max =
LONGINT
ll -ul =max =
LONGINT
ll * ul =max =
LONGINT
ll / ul =float =
DOUBLE
ll ^ ul =float =
DOUBLE
ll \ ul =non-float =
LONGINT
ll mod ul =non-float =
LONGINT

bitops (ll, ul):

ll shl ul =non-float =
LONGINT
ll shr ul =non-float =
LONGINT
ll and ul =non-float =
LONGINT
ll or ul =non-float =
LONGINT
ll xor ul =non-float =
LONGINT
ll eqv ul =non-float =
LONGINT
ll imp ul =non-float =
LONGINT

relational ops (ll, ul):

ll =ul =integer =
INTEGER
ll >ul =integer =
INTEGER
ll <ul =integer =
INTEGER
ll <> ul =integer =
INTEGER
ll <= ul =integer =
INTEGER
ll >= ul =integer =
INTEGER
ll andalso ul =integer =
INTEGER
ll orelse ul =integer =
INTEGER

math ops (ll, ll):

ll + ll =max =
LONGINT
ll -ll =max =
LONGINT
ll * ll =max =
LONGINT
ll / ll =float =
DOUBLE
ll ^ ll =float =
DOUBLE
ll \ ll =non-float =
LONGINT
ll mod ll =non-float =
LONGINT

bitops (ll, ll):

ll shl ll =non-float =
LONGINT
ll shr ll =non-float =
LONGINT
ll and ll =non-float =
LONGINT
ll or ll =non-float =
LONGINT
ll xor ll =non-float =
LONGINT
ll eqv ll =non-float =
LONGINT
ll imp ll =non-float =
LONGINT

relational ops (ll, ll):

ll =ll =integer =
INTEGER
ll >ll =integer =
INTEGER
ll <ll =integer =
INTEGER
ll <> ll =integer =
INTEGER
ll <= ll =integer =
INTEGER
ll >= ll =integer =
INTEGER
ll andalso ll =integer =
INTEGER
ll orelse ll =integer =
INTEGER

math ops (ll, ull):

ll + ull =max =
LONGINT
ll -ull =max =
LONGINT
ll * ull =max =
LONGINT
ll / ull =float =
DOUBLE
ll ^ ull =float =
DOUBLE
ll \ ull =non-float =
LONGINT
ll mod ull =non-float =
LONGINT

bitops (ll, ull):

ll shl ull =non-float =
LONGINT
ll shr ull =non-float =
LONGINT
ll and ull =non-float =
LONGINT
ll or ull =non-float =
LONGINT
ll xor ull =non-float =
LONGINT
ll eqv ull =non-float =
LONGINT
ll imp ull =non-float =
LONGINT

relational ops (ll, ull):

ll =ull =integer =
INTEGER
ll >ull =integer =
INTEGER
ll <ull =integer =
INTEGER
ll <> ull =integer =
INTEGER
ll <= ull =integer =
INTEGER
ll >= ull =integer =
INTEGER
ll andalso ull =integer =
INTEGER
ll orelse ull =integer =
INTEGER

math ops (ll, enum1a):

ll + enum1a =max =
LONGINT
ll -enum1a =max =
LONGINT
ll * enum1a =max =
LONGINT
ll / enum1a =float =
DOUBLE
ll ^ enum1a =float =
DOUBLE
ll \ enum1a =non-float =
LONGINT
ll mod enum1a =non-float =
LONGINT

bitops (ll, enum1a):

ll shl enum1a =non-float =
LONGINT
ll shr enum1a =non-float =
LONGINT
ll and enum1a =non-float =
LONGINT
ll or enum1a =non-float =
LONGINT
ll xor enum1a =non-float =
LONGINT
ll eqv enum1a =non-float =
LONGINT
ll imp enum1a =non-float =
LONGINT

relational ops (ll, enum1a):

ll =enum1a =integer =
INTEGER
ll >enum1a =integer =
INTEGER
ll <enum1a =integer =
INTEGER
ll <> enum1a =integer =
INTEGER
ll <= enum1a =integer =
INTEGER
ll >= enum1a =integer =
INTEGER
ll andalso enum1a =integer =
INTEGER
ll orelse enum1a =integer =
INTEGER

math ops (b, ll):

b + ll =max =
LONGINT
b -ll =max =
LONGINT
b * ll =max =
LONGINT
b / ll =float =
DOUBLE
b ^ ll =float =
DOUBLE
b \ ll =non-float =
LONGINT
b mod ll =non-float =
LONGINT

bitops (b, ll):

b shl ll =non-float =
LONGINT
b shr ll =non-float =
LONGINT
b and ll =non-float =
LONGINT
b or ll =non-float =
LONGINT
b xor ll =non-float =
LONGINT
b eqv ll =non-float =
LONGINT
b imp ll =non-float =
LONGINT

relational ops (b, ll):

b =ll =integer =
INTEGER
b >ll =integer =
INTEGER
b <ll =integer =
INTEGER
b <> ll =integer =
INTEGER
b <= ll =integer =
INTEGER
b >= ll =integer =
INTEGER
b andalso ll =integer =
INTEGER
b orelse ll =integer =
INTEGER

math ops (ub, ll):

ub + ll =max =
LONGINT
ub -ll =max =
LONGINT
ub * ll =max =
LONGINT
ub / ll =float =
DOUBLE
ub ^ ll =float =
DOUBLE
ub \ ll =non-float =
LONGINT
ub mod ll =non-float =
LONGINT

bitops (ub, ll):

ub shl ll =non-float =
LONGINT
ub shr ll =non-float =
LONGINT
ub and ll =non-float =
LONGINT
ub or ll =non-float =
LONGINT
ub xor ll =non-float =
LONGINT
ub eqv ll =non-float =
LONGINT
ub imp ll =non-float =
LONGINT

relational ops (ub, ll):

ub =ll =integer =
INTEGER
ub >ll =integer =
INTEGER
ub <ll =integer =
INTEGER
ub <> ll =integer =
INTEGER
ub <= ll =integer =
INTEGER
ub >= ll =integer =
INTEGER
ub andalso ll =integer =
INTEGER
ub orelse ll =integer =
INTEGER

math ops (sh, ll):

sh + ll =max =
LONGINT
sh -ll =max =
LONGINT
sh * ll =max =
LONGINT
sh / ll =float =
DOUBLE
sh ^ ll =float =
DOUBLE
sh \ ll =non-float =
LONGINT
sh mod ll =non-float =
LONGINT

bitops (sh, ll):

sh shl ll =non-float =
LONGINT
sh shr ll =non-float =
LONGINT
sh and ll =non-float =
LONGINT
sh or ll =non-float =
LONGINT
sh xor ll =non-float =
LONGINT
sh eqv ll =non-float =
LONGINT
sh imp ll =non-float =
LONGINT

relational ops (sh, ll):

sh =ll =integer =
INTEGER
sh >ll =integer =
INTEGER
sh <ll =integer =
INTEGER
sh <> ll =integer =
INTEGER
sh <= ll =integer =
INTEGER
sh >= ll =integer =
INTEGER
sh andalso ll =integer =
INTEGER
sh orelse ll =integer =
INTEGER

math ops (ush, ll):

ush + ll =max =
LONGINT
ush -ll =max =
LONGINT
ush * ll =max =
LONGINT
ush / ll =float =
DOUBLE
ush ^ ll =float =
DOUBLE
ush \ ll =non-float =
LONGINT
ush mod ll =non-float =
LONGINT

bitops (ush, ll):

ush shl ll =non-float =
LONGINT
ush shr ll =non-float =
LONGINT
ush and ll =non-float =
LONGINT
ush or ll =non-float =
LONGINT
ush xor ll =non-float =
LONGINT
ush eqv ll =non-float =
LONGINT
ush imp ll =non-float =
LONGINT

relational ops (ush, ll):

ush =ll =integer =
INTEGER
ush >ll =integer =
INTEGER
ush <ll =integer =
INTEGER
ush <> ll =integer =
INTEGER
ush <= ll =integer =
INTEGER
ush >= ll =integer =
INTEGER
ush andalso ll =integer =
INTEGER
ush orelse ll =integer =
INTEGER

math ops (i, ll):

i + ll =max =
LONGINT
i -ll =max =
LONGINT
i * ll =max =
LONGINT
i / ll =float =
DOUBLE
i ^ ll =float =
DOUBLE
i \ ll =non-float =
LONGINT
i mod ll =non-float =
LONGINT

bitops (i, ll):

i shl ll =non-float =
LONGINT
i shr ll =non-float =
LONGINT
i and ll =non-float =
LONGINT
i or ll =non-float =
LONGINT
i xor ll =non-float =
LONGINT
i eqv ll =non-float =
LONGINT
i imp ll =non-float =
LONGINT

relational ops (i, ll):

i =ll =integer =
INTEGER
i >ll =integer =
INTEGER
i <ll =integer =
INTEGER
i <> ll =integer =
INTEGER
i <= ll =integer =
INTEGER
i >= ll =integer =
INTEGER
i andalso ll =integer =
INTEGER
i orelse ll =integer =
INTEGER

math ops (ui, ll):

ui + ll =max =
LONGINT
ui -ll =max =
LONGINT
ui * ll =max =
LONGINT
ui / ll =float =
DOUBLE
ui ^ ll =float =
DOUBLE
ui \ ll =non-float =
LONGINT
ui mod ll =non-float =
LONGINT

bitops (ui, ll):

ui shl ll =non-float =
LONGINT
ui shr ll =non-float =
LONGINT
ui and ll =non-float =
LONGINT
ui or ll =non-float =
LONGINT
ui xor ll =non-float =
LONGINT
ui eqv ll =non-float =
LONGINT
ui imp ll =non-float =
LONGINT

relational ops (ui, ll):

ui =ll =integer =
INTEGER
ui >ll =integer =
INTEGER
ui <ll =integer =
INTEGER
ui <> ll =integer =
INTEGER
ui <= ll =integer =
INTEGER
ui >= ll =integer =
INTEGER
ui andalso ll =integer =
INTEGER
ui orelse ll =integer =
INTEGER

math ops (l, ll):

l + ll =max =
LONGINT
l -ll =max =
LONGINT
l * ll =max =
LONGINT
l / ll =float =
DOUBLE
l ^ ll =float =
DOUBLE
l \ ll =non-float =
LONGINT
l mod ll =non-float =
LONGINT

bitops (l, ll):

l shl ll =non-float =
LONGINT
l shr ll =non-float =
LONGINT
l and ll =non-float =
LONGINT
l or ll =non-float =
LONGINT
l xor ll =non-float =
LONGINT
l eqv ll =non-float =
LONGINT
l imp ll =non-float =
LONGINT

relational ops (l, ll):

l =ll =integer =
INTEGER
l >ll =integer =
INTEGER
l <ll =integer =
INTEGER
l <> ll =integer =
INTEGER
l <= ll =integer =
INTEGER
l >= ll =integer =
INTEGER
l andalso ll =integer =
INTEGER
l orelse ll =integer =
INTEGER

math ops (ul, ll):

ul + ll =max =
LONGINT
ul -ll =max =
LONGINT
ul * ll =max =
LONGINT
ul / ll =float =
DOUBLE
ul ^ ll =float =
DOUBLE
ul \ ll =non-float =
LONGINT
ul mod ll =non-float =
LONGINT

bitops (ul, ll):

ul shl ll =non-float =
LONGINT
ul shr ll =non-float =
LONGINT
ul and ll =non-float =
LONGINT
ul or ll =non-float =
LONGINT
ul xor ll =non-float =
LONGINT
ul eqv ll =non-float =
LONGINT
ul imp ll =non-float =
LONGINT

relational ops (ul, ll):

ul =ll =integer =
INTEGER
ul >ll =integer =
INTEGER
ul <ll =integer =
INTEGER
ul <> ll =integer =
INTEGER
ul <= ll =integer =
INTEGER
ul >= ll =integer =
INTEGER
ul andalso ll =integer =
INTEGER
ul orelse ll =integer =
INTEGER

math ops (ll, ll):

ll + ll =max =
LONGINT
ll -ll =max =
LONGINT
ll * ll =max =
LONGINT
ll / ll =float =
DOUBLE
ll ^ ll =float =
DOUBLE
ll \ ll =non-float =
LONGINT
ll mod ll =non-float =
LONGINT

bitops (ll, ll):

ll shl ll =non-float =
LONGINT
ll shr ll =non-float =
LONGINT
ll and ll =non-float =
LONGINT
ll or ll =non-float =
LONGINT
ll xor ll =non-float =
LONGINT
ll eqv ll =non-float =
LONGINT
ll imp ll =non-float =
LONGINT

relational ops (ll, ll):

ll =ll =integer =
INTEGER
ll >ll =integer =
INTEGER
ll <ll =integer =
INTEGER
ll <> ll =integer =
INTEGER
ll <= ll =integer =
INTEGER
ll >= ll =integer =
INTEGER
ll andalso ll =integer =
INTEGER
ll orelse ll =integer =
INTEGER

math ops (ull, ll):

ull + ll =max =
ULONGINT
ull -ll =max =
ULONGINT
ull * ll =max =
ULONGINT
ull / ll =float =
DOUBLE
ull ^ ll =float =
DOUBLE
ull \ ll =non-float =
ULONGINT
ull mod ll =non-float =
ULONGINT

bitops (ull, ll):

ull shl ll =non-float =
ULONGINT
ull shr ll =non-float =
ULONGINT
ull and ll =non-float =
ULONGINT
ull or ll =non-float =
ULONGINT
ull xor ll =non-float =
ULONGINT
ull eqv ll =non-float =
ULONGINT
ull imp ll =non-float =
ULONGINT

relational ops (ull, ll):

ull =ll =integer =
INTEGER
ull >ll =integer =
INTEGER
ull <ll =integer =
INTEGER
ull <> ll =integer =
INTEGER
ull <= ll =integer =
INTEGER
ull >= ll =integer =
INTEGER
ull andalso ll =integer =
INTEGER
ull orelse ll =integer =
INTEGER

math ops (enum1a, ll):

enum1a + ll =max =
LONGINT
enum1a -ll =max =
LONGINT
enum1a * ll =max =
LONGINT
enum1a / ll =float =
DOUBLE
enum1a ^ ll =float =
DOUBLE
enum1a \ ll =non-float =
LONGINT
enum1a mod ll =non-float =
LONGINT

bitops (enum1a, ll):

enum1a shl ll =non-float =
LONGINT
enum1a shr ll =non-float =
LONGINT
enum1a and ll =non-float =
LONGINT
enum1a or ll =non-float =
LONGINT
enum1a xor ll =non-float =
LONGINT
enum1a eqv ll =non-float =
LONGINT
enum1a imp ll =non-float =
LONGINT

relational ops (enum1a, ll):

enum1a =ll =integer =
INTEGER
enum1a >ll =integer =
INTEGER
enum1a <ll =integer =
INTEGER
enum1a <> ll =integer =
INTEGER
enum1a <= ll =integer =
INTEGER
enum1a >= ll =integer =
INTEGER
enum1a andalso ll =integer =
INTEGER
enum1a orelse ll =integer =
INTEGER

math ops (ll, f):

ll + f =max =
SINGLE
ll -f =max =
SINGLE
ll * f =max =
SINGLE
ll / f =float =
DOUBLE
ll ^ f =float =
DOUBLE
ll \ f =non-float =
LONGINT
ll mod f =non-float =
LONGINT

bitops (ll, f):

ll shl f =non-float =
LONGINT
ll shr f =non-float =
LONGINT
ll and f =non-float =
LONGINT
ll or f =non-float =
LONGINT
ll xor f =non-float =
LONGINT
ll eqv f =non-float =
LONGINT
ll imp f =non-float =
LONGINT

relational ops (ll, f):

ll =f =integer =
INTEGER
ll >f =integer =
INTEGER
ll <f =integer =
INTEGER
ll <> f =integer =
INTEGER
ll <= f =integer =
INTEGER
ll >= f =integer =
INTEGER
ll andalso f =integer =
INTEGER
ll orelse f =integer =
INTEGER

math ops (ll, d):

ll + d =max =
DOUBLE
ll -d =max =
DOUBLE
ll * d =max =
DOUBLE
ll / d =float =
DOUBLE
ll ^ d =float =
DOUBLE
ll \ d =non-float =
LONGINT
ll mod d =non-float =
LONGINT

bitops (ll, d):

ll shl d =non-float =
LONGINT
ll shr d =non-float =
LONGINT
ll and d =non-float =
LONGINT
ll or d =non-float =
LONGINT
ll xor d =non-float =
LONGINT
ll eqv d =non-float =
LONGINT
ll imp d =non-float =
LONGINT

relational ops (ll, d):

ll =d =integer =
INTEGER
ll >d =integer =
INTEGER
ll <d =integer =
INTEGER
ll <> d =integer =
INTEGER
ll <= d =integer =
INTEGER
ll >= d =integer =
INTEGER
ll andalso d =integer =
INTEGER
ll orelse d =integer =
INTEGER

math ops (f, ll):

f + ll =max =
SINGLE
f -ll =max =
SINGLE
f * ll =max =
SINGLE
f / ll =float =
DOUBLE
f ^ ll =float =
DOUBLE
f \ ll =non-float =
LONGINT
f mod ll =non-float =
LONGINT

bitops (f, ll):

f shl ll =non-float =
LONGINT
f shr ll =non-float =
LONGINT
f and ll =non-float =
LONGINT
f or ll =non-float =
LONGINT
f xor ll =non-float =
LONGINT
f eqv ll =non-float =
LONGINT
f imp ll =non-float =
LONGINT

relational ops (f, ll):

f =ll =integer =
INTEGER
f >ll =integer =
INTEGER
f <ll =integer =
INTEGER
f <> ll =integer =
INTEGER
f <= ll =integer =
INTEGER
f >= ll =integer =
INTEGER
f andalso ll =integer =
INTEGER
f orelse ll =integer =
INTEGER

math ops (d, ll):

d + ll =max =
DOUBLE
d -ll =max =
DOUBLE
d * ll =max =
DOUBLE
d / ll =float =
DOUBLE
d ^ ll =float =
DOUBLE
d \ ll =non-float =
LONGINT
d mod ll =non-float =
LONGINT

bitops (d, ll):

d shl ll =non-float =
LONGINT
d shr ll =non-float =
LONGINT
d and ll =non-float =
LONGINT
d or ll =non-float =
LONGINT
d xor ll =non-float =
LONGINT
d eqv ll =non-float =
LONGINT
d imp ll =non-float =
LONGINT

relational ops (d, ll):

d =ll =integer =
INTEGER
d >ll =integer =
INTEGER
d <ll =integer =
INTEGER
d <> ll =integer =
INTEGER
d <= ll =integer =
INTEGER
d >= ll =integer =
INTEGER
d andalso ll =integer =
INTEGER
d orelse ll =integer =
INTEGER

-----ull -----------------------------------------------------


math ops (ull, b):

ull + b =max =
ULONGINT
ull -b =max =
ULONGINT
ull * b =max =
ULONGINT
ull / b =float =
DOUBLE
ull ^ b =float =
DOUBLE
ull \ b =non-float =
ULONGINT
ull mod b =non-float =
ULONGINT

bitops (ull, b):

ull shl b =non-float =
ULONGINT
ull shr b =non-float =
ULONGINT
ull and b =non-float =
ULONGINT
ull or b =non-float =
ULONGINT
ull xor b =non-float =
ULONGINT
ull eqv b =non-float =
ULONGINT
ull imp b =non-float =
ULONGINT

relational ops (ull, b):

ull =b =integer =
INTEGER
ull >b =integer =
INTEGER
ull <b =integer =
INTEGER
ull <> b =integer =
INTEGER
ull <= b =integer =
INTEGER
ull >= b =integer =
INTEGER
ull andalso b =integer =
INTEGER
ull orelse b =integer =
INTEGER

math ops (ull, ub):

ull + ub =max =
ULONGINT
ull -ub =max =
ULONGINT
ull * ub =max =
ULONGINT
ull / ub =float =
DOUBLE
ull ^ ub =float =
DOUBLE
ull \ ub =non-float =
ULONGINT
ull mod ub =non-float =
ULONGINT

bitops (ull, ub):

ull shl ub =non-float =
ULONGINT
ull shr ub =non-float =
ULONGINT
ull and ub =non-float =
ULONGINT
ull or ub =non-float =
ULONGINT
ull xor ub =non-float =
ULONGINT
ull eqv ub =non-float =
ULONGINT
ull imp ub =non-float =
ULONGINT

relational ops (ull, ub):

ull =ub =integer =
INTEGER
ull >ub =integer =
INTEGER
ull <ub =integer =
INTEGER
ull <> ub =integer =
INTEGER
ull <= ub =integer =
INTEGER
ull >= ub =integer =
INTEGER
ull andalso ub =integer =
INTEGER
ull orelse ub =integer =
INTEGER

math ops (ull, sh):

ull + sh =max =
ULONGINT
ull -sh =max =
ULONGINT
ull * sh =max =
ULONGINT
ull / sh =float =
DOUBLE
ull ^ sh =float =
DOUBLE
ull \ sh =non-float =
ULONGINT
ull mod sh =non-float =
ULONGINT

bitops (ull, sh):

ull shl sh =non-float =
ULONGINT
ull shr sh =non-float =
ULONGINT
ull and sh =non-float =
ULONGINT
ull or sh =non-float =
ULONGINT
ull xor sh =non-float =
ULONGINT
ull eqv sh =non-float =
ULONGINT
ull imp sh =non-float =
ULONGINT

relational ops (ull, sh):

ull =sh =integer =
INTEGER
ull >sh =integer =
INTEGER
ull <sh =integer =
INTEGER
ull <> sh =integer =
INTEGER
ull <= sh =integer =
INTEGER
ull >= sh =integer =
INTEGER
ull andalso sh =integer =
INTEGER
ull orelse sh =integer =
INTEGER

math ops (ull, ush):

ull + ush =max =
ULONGINT
ull -ush =max =
ULONGINT
ull * ush =max =
ULONGINT
ull / ush =float =
DOUBLE
ull ^ ush =float =
DOUBLE
ull \ ush =non-float =
ULONGINT
ull mod ush =non-float =
ULONGINT

bitops (ull, ush):

ull shl ush =non-float =
ULONGINT
ull shr ush =non-float =
ULONGINT
ull and ush =non-float =
ULONGINT
ull or ush =non-float =
ULONGINT
ull xor ush =non-float =
ULONGINT
ull eqv ush =non-float =
ULONGINT
ull imp ush =non-float =
ULONGINT

relational ops (ull, ush):

ull =ush =integer =
INTEGER
ull >ush =integer =
INTEGER
ull <ush =integer =
INTEGER
ull <> ush =integer =
INTEGER
ull <= ush =integer =
INTEGER
ull >= ush =integer =
INTEGER
ull andalso ush =integer =
INTEGER
ull orelse ush =integer =
INTEGER

math ops (ull, i):

ull + i =max =
ULONGINT
ull -i =max =
ULONGINT
ull * i =max =
ULONGINT
ull / i =float =
DOUBLE
ull ^ i =float =
DOUBLE
ull \ i =non-float =
ULONGINT
ull mod i =non-float =
ULONGINT

bitops (ull, i):

ull shl i =non-float =
ULONGINT
ull shr i =non-float =
ULONGINT
ull and i =non-float =
ULONGINT
ull or i =non-float =
ULONGINT
ull xor i =non-float =
ULONGINT
ull eqv i =non-float =
ULONGINT
ull imp i =non-float =
ULONGINT

relational ops (ull, i):

ull =i =integer =
INTEGER
ull >i =integer =
INTEGER
ull <i =integer =
INTEGER
ull <> i =integer =
INTEGER
ull <= i =integer =
INTEGER
ull >= i =integer =
INTEGER
ull andalso i =integer =
INTEGER
ull orelse i =integer =
INTEGER

math ops (ull, ui):

ull + ui =max =
ULONGINT
ull -ui =max =
ULONGINT
ull * ui =max =
ULONGINT
ull / ui =float =
DOUBLE
ull ^ ui =float =
DOUBLE
ull \ ui =non-float =
ULONGINT
ull mod ui =non-float =
ULONGINT

bitops (ull, ui):

ull shl ui =non-float =
ULONGINT
ull shr ui =non-float =
ULONGINT
ull and ui =non-float =
ULONGINT
ull or ui =non-float =
ULONGINT
ull xor ui =non-float =
ULONGINT
ull eqv ui =non-float =
ULONGINT
ull imp ui =non-float =
ULONGINT

relational ops (ull, ui):

ull =ui =integer =
INTEGER
ull >ui =integer =
INTEGER
ull <ui =integer =
INTEGER
ull <> ui =integer =
INTEGER
ull <= ui =integer =
INTEGER
ull >= ui =integer =
INTEGER
ull andalso ui =integer =
INTEGER
ull orelse ui =integer =
INTEGER

math ops (ull, l):

ull + l =max =
ULONGINT
ull -l =max =
ULONGINT
ull * l =max =
ULONGINT
ull / l =float =
DOUBLE
ull ^ l =float =
DOUBLE
ull \ l =non-float =
ULONGINT
ull mod l =non-float =
ULONGINT

bitops (ull, l):

ull shl l =non-float =
ULONGINT
ull shr l =non-float =
ULONGINT
ull and l =non-float =
ULONGINT
ull or l =non-float =
ULONGINT
ull xor l =non-float =
ULONGINT
ull eqv l =non-float =
ULONGINT
ull imp l =non-float =
ULONGINT

relational ops (ull, l):

ull =l =integer =
INTEGER
ull >l =integer =
INTEGER
ull <l =integer =
INTEGER
ull <> l =integer =
INTEGER
ull <= l =integer =
INTEGER
ull >= l =integer =
INTEGER
ull andalso l =integer =
INTEGER
ull orelse l =integer =
INTEGER

math ops (ull, ul):

ull + ul =max =
ULONGINT
ull -ul =max =
ULONGINT
ull * ul =max =
ULONGINT
ull / ul =float =
DOUBLE
ull ^ ul =float =
DOUBLE
ull \ ul =non-float =
ULONGINT
ull mod ul =non-float =
ULONGINT

bitops (ull, ul):

ull shl ul =non-float =
ULONGINT
ull shr ul =non-float =
ULONGINT
ull and ul =non-float =
ULONGINT
ull or ul =non-float =
ULONGINT
ull xor ul =non-float =
ULONGINT
ull eqv ul =non-float =
ULONGINT
ull imp ul =non-float =
ULONGINT

relational ops (ull, ul):

ull =ul =integer =
INTEGER
ull >ul =integer =
INTEGER
ull <ul =integer =
INTEGER
ull <> ul =integer =
INTEGER
ull <= ul =integer =
INTEGER
ull >= ul =integer =
INTEGER
ull andalso ul =integer =
INTEGER
ull orelse ul =integer =
INTEGER

math ops (ull, ll):

ull + ll =max =
ULONGINT
ull -ll =max =
ULONGINT
ull * ll =max =
ULONGINT
ull / ll =float =
DOUBLE
ull ^ ll =float =
DOUBLE
ull \ ll =non-float =
ULONGINT
ull mod ll =non-float =
ULONGINT

bitops (ull, ll):

ull shl ll =non-float =
ULONGINT
ull shr ll =non-float =
ULONGINT
ull and ll =non-float =
ULONGINT
ull or ll =non-float =
ULONGINT
ull xor ll =non-float =
ULONGINT
ull eqv ll =non-float =
ULONGINT
ull imp ll =non-float =
ULONGINT

relational ops (ull, ll):

ull =ll =integer =
INTEGER
ull >ll =integer =
INTEGER
ull <ll =integer =
INTEGER
ull <> ll =integer =
INTEGER
ull <= ll =integer =
INTEGER
ull >= ll =integer =
INTEGER
ull andalso ll =integer =
INTEGER
ull orelse ll =integer =
INTEGER

math ops (ull, ull):

ull + ull =max =
ULONGINT
ull -ull =max =
ULONGINT
ull * ull =max =
ULONGINT
ull / ull =float =
DOUBLE
ull ^ ull =float =
DOUBLE
ull \ ull =non-float =
ULONGINT
ull mod ull =non-float =
ULONGINT

bitops (ull, ull):

ull shl ull =non-float =
ULONGINT
ull shr ull =non-float =
ULONGINT
ull and ull =non-float =
ULONGINT
ull or ull =non-float =
ULONGINT
ull xor ull =non-float =
ULONGINT
ull eqv ull =non-float =
ULONGINT
ull imp ull =non-float =
ULONGINT

relational ops (ull, ull):

ull =ull =integer =
INTEGER
ull >ull =integer =
INTEGER
ull <ull =integer =
INTEGER
ull <> ull =integer =
INTEGER
ull <= ull =integer =
INTEGER
ull >= ull =integer =
INTEGER
ull andalso ull =integer =
INTEGER
ull orelse ull =integer =
INTEGER

math ops (ull, enum1a):

ull + enum1a =max =
ULONGINT
ull -enum1a =max =
ULONGINT
ull * enum1a =max =
ULONGINT
ull / enum1a =float =
DOUBLE
ull ^ enum1a =float =
DOUBLE
ull \ enum1a =non-float =
ULONGINT
ull mod enum1a =non-float =
ULONGINT

bitops (ull, enum1a):

ull shl enum1a =non-float =
ULONGINT
ull shr enum1a =non-float =
ULONGINT
ull and enum1a =non-float =
ULONGINT
ull or enum1a =non-float =
ULONGINT
ull xor enum1a =non-float =
ULONGINT
ull eqv enum1a =non-float =
ULONGINT
ull imp enum1a =non-float =
ULONGINT

relational ops (ull, enum1a):

ull =enum1a =integer =
INTEGER
ull >enum1a =integer =
INTEGER
ull <enum1a =integer =
INTEGER
ull <> enum1a =integer =
INTEGER
ull <= enum1a =integer =
INTEGER
ull >= enum1a =integer =
INTEGER
ull andalso enum1a =integer =
INTEGER
ull orelse enum1a =integer =
INTEGER

math ops (b, ull):

b + ull =max =
ULONGINT
b -ull =max =
ULONGINT
b * ull =max =
ULONGINT
b / ull =float =
DOUBLE
b ^ ull =float =
DOUBLE
b \ ull =non-float =
ULONGINT
b mod ull =non-float =
ULONGINT

bitops (b, ull):

b shl ull =non-float =
ULONGINT
b shr ull =non-float =
ULONGINT
b and ull =non-float =
ULONGINT
b or ull =non-float =
ULONGINT
b xor ull =non-float =
ULONGINT
b eqv ull =non-float =
ULONGINT
b imp ull =non-float =
ULONGINT

relational ops (b, ull):

b =ull =integer =
INTEGER
b >ull =integer =
INTEGER
b <ull =integer =
INTEGER
b <> ull =integer =
INTEGER
b <= ull =integer =
INTEGER
b >= ull =integer =
INTEGER
b andalso ull =integer =
INTEGER
b orelse ull =integer =
INTEGER

math ops (ub, ull):

ub + ull =max =
ULONGINT
ub -ull =max =
ULONGINT
ub * ull =max =
ULONGINT
ub / ull =float =
DOUBLE
ub ^ ull =float =
DOUBLE
ub \ ull =non-float =
ULONGINT
ub mod ull =non-float =
ULONGINT

bitops (ub, ull):

ub shl ull =non-float =
ULONGINT
ub shr ull =non-float =
ULONGINT
ub and ull =non-float =
ULONGINT
ub or ull =non-float =
ULONGINT
ub xor ull =non-float =
ULONGINT
ub eqv ull =non-float =
ULONGINT
ub imp ull =non-float =
ULONGINT

relational ops (ub, ull):

ub =ull =integer =
INTEGER
ub >ull =integer =
INTEGER
ub <ull =integer =
INTEGER
ub <> ull =integer =
INTEGER
ub <= ull =integer =
INTEGER
ub >= ull =integer =
INTEGER
ub andalso ull =integer =
INTEGER
ub orelse ull =integer =
INTEGER

math ops (sh, ull):

sh + ull =max =
ULONGINT
sh -ull =max =
ULONGINT
sh * ull =max =
ULONGINT
sh / ull =float =
DOUBLE
sh ^ ull =float =
DOUBLE
sh \ ull =non-float =
ULONGINT
sh mod ull =non-float =
ULONGINT

bitops (sh, ull):

sh shl ull =non-float =
ULONGINT
sh shr ull =non-float =
ULONGINT
sh and ull =non-float =
ULONGINT
sh or ull =non-float =
ULONGINT
sh xor ull =non-float =
ULONGINT
sh eqv ull =non-float =
ULONGINT
sh imp ull =non-float =
ULONGINT

relational ops (sh, ull):

sh =ull =integer =
INTEGER
sh >ull =integer =
INTEGER
sh <ull =integer =
INTEGER
sh <> ull =integer =
INTEGER
sh <= ull =integer =
INTEGER
sh >= ull =integer =
INTEGER
sh andalso ull =integer =
INTEGER
sh orelse ull =integer =
INTEGER

math ops (ush, ull):

ush + ull =max =
ULONGINT
ush -ull =max =
ULONGINT
ush * ull =max =
ULONGINT
ush / ull =float =
DOUBLE
ush ^ ull =float =
DOUBLE
ush \ ull =non-float =
ULONGINT
ush mod ull =non-float =
ULONGINT

bitops (ush, ull):

ush shl ull =non-float =
ULONGINT
ush shr ull =non-float =
ULONGINT
ush and ull =non-float =
ULONGINT
ush or ull =non-float =
ULONGINT
ush xor ull =non-float =
ULONGINT
ush eqv ull =non-float =
ULONGINT
ush imp ull =non-float =
ULONGINT

relational ops (ush, ull):

ush =ull =integer =
INTEGER
ush >ull =integer =
INTEGER
ush <ull =integer =
INTEGER
ush <> ull =integer =
INTEGER
ush <= ull =integer =
INTEGER
ush >= ull =integer =
INTEGER
ush andalso ull =integer =
INTEGER
ush orelse ull =integer =
INTEGER

math ops (i, ull):

i + ull =max =
ULONGINT
i -ull =max =
ULONGINT
i * ull =max =
ULONGINT
i / ull =float =
DOUBLE
i ^ ull =float =
DOUBLE
i \ ull =non-float =
ULONGINT
i mod ull =non-float =
ULONGINT

bitops (i, ull):

i shl ull =non-float =
ULONGINT
i shr ull =non-float =
ULONGINT
i and ull =non-float =
ULONGINT
i or ull =non-float =
ULONGINT
i xor ull =non-float =
ULONGINT
i eqv ull =non-float =
ULONGINT
i imp ull =non-float =
ULONGINT

relational ops (i, ull):

i =ull =integer =
INTEGER
i >ull =integer =
INTEGER
i <ull =integer =
INTEGER
i <> ull =integer =
INTEGER
i <= ull =integer =
INTEGER
i >= ull =integer =
INTEGER
i andalso ull =integer =
INTEGER
i orelse ull =integer =
INTEGER

math ops (ui, ull):

ui + ull =max =
ULONGINT
ui -ull =max =
ULONGINT
ui * ull =max =
ULONGINT
ui / ull =float =
DOUBLE
ui ^ ull =float =
DOUBLE
ui \ ull =non-float =
ULONGINT
ui mod ull =non-float =
ULONGINT

bitops (ui, ull):

ui shl ull =non-float =
ULONGINT
ui shr ull =non-float =
ULONGINT
ui and ull =non-float =
ULONGINT
ui or ull =non-float =
ULONGINT
ui xor ull =non-float =
ULONGINT
ui eqv ull =non-float =
ULONGINT
ui imp ull =non-float =
ULONGINT

relational ops (ui, ull):

ui =ull =integer =
INTEGER
ui >ull =integer =
INTEGER
ui <ull =integer =
INTEGER
ui <> ull =integer =
INTEGER
ui <= ull =integer =
INTEGER
ui >= ull =integer =
INTEGER
ui andalso ull =integer =
INTEGER
ui orelse ull =integer =
INTEGER

math ops (l, ull):

l + ull =max =
ULONGINT
l -ull =max =
ULONGINT
l * ull =max =
ULONGINT
l / ull =float =
DOUBLE
l ^ ull =float =
DOUBLE
l \ ull =non-float =
ULONGINT
l mod ull =non-float =
ULONGINT

bitops (l, ull):

l shl ull =non-float =
ULONGINT
l shr ull =non-float =
ULONGINT
l and ull =non-float =
ULONGINT
l or ull =non-float =
ULONGINT
l xor ull =non-float =
ULONGINT
l eqv ull =non-float =
ULONGINT
l imp ull =non-float =
ULONGINT

relational ops (l, ull):

l =ull =integer =
INTEGER
l >ull =integer =
INTEGER
l <ull =integer =
INTEGER
l <> ull =integer =
INTEGER
l <= ull =integer =
INTEGER
l >= ull =integer =
INTEGER
l andalso ull =integer =
INTEGER
l orelse ull =integer =
INTEGER

math ops (ul, ull):

ul + ull =max =
ULONGINT
ul -ull =max =
ULONGINT
ul * ull =max =
ULONGINT
ul / ull =float =
DOUBLE
ul ^ ull =float =
DOUBLE
ul \ ull =non-float =
ULONGINT
ul mod ull =non-float =
ULONGINT

bitops (ul, ull):

ul shl ull =non-float =
ULONGINT
ul shr ull =non-float =
ULONGINT
ul and ull =non-float =
ULONGINT
ul or ull =non-float =
ULONGINT
ul xor ull =non-float =
ULONGINT
ul eqv ull =non-float =
ULONGINT
ul imp ull =non-float =
ULONGINT

relational ops (ul, ull):

ul =ull =integer =
INTEGER
ul >ull =integer =
INTEGER
ul <ull =integer =
INTEGER
ul <> ull =integer =
INTEGER
ul <= ull =integer =
INTEGER
ul >= ull =integer =
INTEGER
ul andalso ull =integer =
INTEGER
ul orelse ull =integer =
INTEGER

math ops (ll, ull):

ll + ull =max =
LONGINT
ll -ull =max =
LONGINT
ll * ull =max =
LONGINT
ll / ull =float =
DOUBLE
ll ^ ull =float =
DOUBLE
ll \ ull =non-float =
LONGINT
ll mod ull =non-float =
LONGINT

bitops (ll, ull):

ll shl ull =non-float =
LONGINT
ll shr ull =non-float =
LONGINT
ll and ull =non-float =
LONGINT
ll or ull =non-float =
LONGINT
ll xor ull =non-float =
LONGINT
ll eqv ull =non-float =
LONGINT
ll imp ull =non-float =
LONGINT

relational ops (ll, ull):

ll =ull =integer =
INTEGER
ll >ull =integer =
INTEGER
ll <ull =integer =
INTEGER
ll <> ull =integer =
INTEGER
ll <= ull =integer =
INTEGER
ll >= ull =integer =
INTEGER
ll andalso ull =integer =
INTEGER
ll orelse ull =integer =
INTEGER

math ops (ull, ull):

ull + ull =max =
ULONGINT
ull -ull =max =
ULONGINT
ull * ull =max =
ULONGINT
ull / ull =float =
DOUBLE
ull ^ ull =float =
DOUBLE
ull \ ull =non-float =
ULONGINT
ull mod ull =non-float =
ULONGINT

bitops (ull, ull):

ull shl ull =non-float =
ULONGINT
ull shr ull =non-float =
ULONGINT
ull and ull =non-float =
ULONGINT
ull or ull =non-float =
ULONGINT
ull xor ull =non-float =
ULONGINT
ull eqv ull =non-float =
ULONGINT
ull imp ull =non-float =
ULONGINT

relational ops (ull, ull):

ull =ull =integer =
INTEGER
ull >ull =integer =
INTEGER
ull <ull =integer =
INTEGER
ull <> ull =integer =
INTEGER
ull <= ull =integer =
INTEGER
ull >= ull =integer =
INTEGER
ull andalso ull =integer =
INTEGER
ull orelse ull =integer =
INTEGER

math ops (enum1a, ull):

enum1a + ull =max =
ULONGINT
enum1a -ull =max =
ULONGINT
enum1a * ull =max =
ULONGINT
enum1a / ull =float =
DOUBLE
enum1a ^ ull =float =
DOUBLE
enum1a \ ull =non-float =
ULONGINT
enum1a mod ull =non-float =
ULONGINT

bitops (enum1a, ull):

enum1a shl ull =non-float =
ULONGINT
enum1a shr ull =non-float =
ULONGINT
enum1a and ull =non-float =
ULONGINT
enum1a or ull =non-float =
ULONGINT
enum1a xor ull =non-float =
ULONGINT
enum1a eqv ull =non-float =
ULONGINT
enum1a imp ull =non-float =
ULONGINT

relational ops (enum1a, ull):

enum1a =ull =integer =
INTEGER
enum1a >ull =integer =
INTEGER
enum1a <ull =integer =
INTEGER
enum1a <> ull =integer =
INTEGER
enum1a <= ull =integer =
INTEGER
enum1a >= ull =integer =
INTEGER
enum1a andalso ull =integer =
INTEGER
enum1a orelse ull =integer =
INTEGER

math ops (ull, f):

ull + f =max =
SINGLE
ull -f =max =
SINGLE
ull * f =max =
SINGLE
ull / f =float =
DOUBLE
ull ^ f =float =
DOUBLE
ull \ f =non-float =
ULONGINT
ull mod f =non-float =
ULONGINT

bitops (ull, f):

ull shl f =non-float =
ULONGINT
ull shr f =non-float =
ULONGINT
ull and f =non-float =
ULONGINT
ull or f =non-float =
ULONGINT
ull xor f =non-float =
ULONGINT
ull eqv f =non-float =
ULONGINT
ull imp f =non-float =
ULONGINT

relational ops (ull, f):

ull =f =integer =
INTEGER
ull >f =integer =
INTEGER
ull <f =integer =
INTEGER
ull <> f =integer =
INTEGER
ull <= f =integer =
INTEGER
ull >= f =integer =
INTEGER
ull andalso f =integer =
INTEGER
ull orelse f =integer =
INTEGER

math ops (ull, d):

ull + d =max =
DOUBLE
ull -d =max =
DOUBLE
ull * d =max =
DOUBLE
ull / d =float =
DOUBLE
ull ^ d =float =
DOUBLE
ull \ d =non-float =
ULONGINT
ull mod d =non-float =
ULONGINT

bitops (ull, d):

ull shl d =non-float =
ULONGINT
ull shr d =non-float =
ULONGINT
ull and d =non-float =
ULONGINT
ull or d =non-float =
ULONGINT
ull xor d =non-float =
ULONGINT
ull eqv d =non-float =
ULONGINT
ull imp d =non-float =
ULONGINT

relational ops (ull, d):

ull =d =integer =
INTEGER
ull >d =integer =
INTEGER
ull <d =integer =
INTEGER
ull <> d =integer =
INTEGER
ull <= d =integer =
INTEGER
ull >= d =integer =
INTEGER
ull andalso d =integer =
INTEGER
ull orelse d =integer =
INTEGER

math ops (f, ull):

f + ull =max =
SINGLE
f -ull =max =
SINGLE
f * ull =max =
SINGLE
f / ull =float =
DOUBLE
f ^ ull =float =
DOUBLE
f \ ull =non-float =
ULONGINT
f mod ull =non-float =
ULONGINT

bitops (f, ull):

f shl ull =non-float =
ULONGINT
f shr ull =non-float =
ULONGINT
f and ull =non-float =
ULONGINT
f or ull =non-float =
ULONGINT
f xor ull =non-float =
ULONGINT
f eqv ull =non-float =
ULONGINT
f imp ull =non-float =
ULONGINT

relational ops (f, ull):

f =ull =integer =
INTEGER
f >ull =integer =
INTEGER
f <ull =integer =
INTEGER
f <> ull =integer =
INTEGER
f <= ull =integer =
INTEGER
f >= ull =integer =
INTEGER
f andalso ull =integer =
INTEGER
f orelse ull =integer =
INTEGER

math ops (d, ull):

d + ull =max =
DOUBLE
d -ull =max =
DOUBLE
d * ull =max =
DOUBLE
d / ull =float =
DOUBLE
d ^ ull =float =
DOUBLE
d \ ull =non-float =
ULONGINT
d mod ull =non-float =
ULONGINT

bitops (d, ull):

d shl ull =non-float =
ULONGINT
d shr ull =non-float =
ULONGINT
d and ull =non-float =
ULONGINT
d or ull =non-float =
ULONGINT
d xor ull =non-float =
ULONGINT
d eqv ull =non-float =
ULONGINT
d imp ull =non-float =
ULONGINT

relational ops (d, ull):

d =ull =integer =
INTEGER
d >ull =integer =
INTEGER
d <ull =integer =
INTEGER
d <> ull =integer =
INTEGER
d <= ull =integer =
INTEGER
d >= ull =integer =
INTEGER
d andalso ull =integer =
INTEGER
d orelse ull =integer =
INTEGER

-----f -----------------------------------------------------


math ops (f, b):

f + b =max =
SINGLE
f -b =max =
SINGLE
f * b =max =
SINGLE
f / b =float =
DOUBLE
f ^ b =float =
DOUBLE
f \ b =non-float =
INTEGER
f mod b =non-float =
INTEGER

bitops (f, b):

f shl b =non-float =
INTEGER
f shr b =non-float =
INTEGER
f and b =non-float =
INTEGER
f or b =non-float =
INTEGER
f xor b =non-float =
INTEGER
f eqv b =non-float =
INTEGER
f imp b =non-float =
INTEGER

relational ops (f, b):

f =b =integer =
INTEGER
f >b =integer =
INTEGER
f <b =integer =
INTEGER
f <> b =integer =
INTEGER
f <= b =integer =
INTEGER
f >= b =integer =
INTEGER
f andalso b =integer =
INTEGER
f orelse b =integer =
INTEGER

math ops (f, ub):

f + ub =max =
SINGLE
f -ub =max =
SINGLE
f * ub =max =
SINGLE
f / ub =float =
DOUBLE
f ^ ub =float =
DOUBLE
f \ ub =non-float =
INTEGER
f mod ub =non-float =
INTEGER

bitops (f, ub):

f shl ub =non-float =
INTEGER
f shr ub =non-float =
INTEGER
f and ub =non-float =
INTEGER
f or ub =non-float =
INTEGER
f xor ub =non-float =
INTEGER
f eqv ub =non-float =
INTEGER
f imp ub =non-float =
INTEGER

relational ops (f, ub):

f =ub =integer =
INTEGER
f >ub =integer =
INTEGER
f <ub =integer =
INTEGER
f <> ub =integer =
INTEGER
f <= ub =integer =
INTEGER
f >= ub =integer =
INTEGER
f andalso ub =integer =
INTEGER
f orelse ub =integer =
INTEGER

math ops (f, sh):

f + sh =max =
SINGLE
f -sh =max =
SINGLE
f * sh =max =
SINGLE
f / sh =float =
DOUBLE
f ^ sh =float =
DOUBLE
f \ sh =non-float =
INTEGER
f mod sh =non-float =
INTEGER

bitops (f, sh):

f shl sh =non-float =
INTEGER
f shr sh =non-float =
INTEGER
f and sh =non-float =
INTEGER
f or sh =non-float =
INTEGER
f xor sh =non-float =
INTEGER
f eqv sh =non-float =
INTEGER
f imp sh =non-float =
INTEGER

relational ops (f, sh):

f =sh =integer =
INTEGER
f >sh =integer =
INTEGER
f <sh =integer =
INTEGER
f <> sh =integer =
INTEGER
f <= sh =integer =
INTEGER
f >= sh =integer =
INTEGER
f andalso sh =integer =
INTEGER
f orelse sh =integer =
INTEGER

math ops (f, ush):

f + ush =max =
SINGLE
f -ush =max =
SINGLE
f * ush =max =
SINGLE
f / ush =float =
DOUBLE
f ^ ush =float =
DOUBLE
f \ ush =non-float =
INTEGER
f mod ush =non-float =
INTEGER

bitops (f, ush):

f shl ush =non-float =
INTEGER
f shr ush =non-float =
INTEGER
f and ush =non-float =
INTEGER
f or ush =non-float =
INTEGER
f xor ush =non-float =
INTEGER
f eqv ush =non-float =
INTEGER
f imp ush =non-float =
INTEGER

relational ops (f, ush):

f =ush =integer =
INTEGER
f >ush =integer =
INTEGER
f <ush =integer =
INTEGER
f <> ush =integer =
INTEGER
f <= ush =integer =
INTEGER
f >= ush =integer =
INTEGER
f andalso ush =integer =
INTEGER
f orelse ush =integer =
INTEGER

math ops (f, i):

f + i =max =
SINGLE
f -i =max =
SINGLE
f * i =max =
SINGLE
f / i =float =
DOUBLE
f ^ i =float =
DOUBLE
f \ i =non-float =
INTEGER
f mod i =non-float =
INTEGER

bitops (f, i):

f shl i =non-float =
INTEGER
f shr i =non-float =
INTEGER
f and i =non-float =
INTEGER
f or i =non-float =
INTEGER
f xor i =non-float =
INTEGER
f eqv i =non-float =
INTEGER
f imp i =non-float =
INTEGER

relational ops (f, i):

f =i =integer =
INTEGER
f >i =integer =
INTEGER
f <i =integer =
INTEGER
f <> i =integer =
INTEGER
f <= i =integer =
INTEGER
f >= i =integer =
INTEGER
f andalso i =integer =
INTEGER
f orelse i =integer =
INTEGER

math ops (f, ui):

f + ui =max =
SINGLE
f -ui =max =
SINGLE
f * ui =max =
SINGLE
f / ui =float =
DOUBLE
f ^ ui =float =
DOUBLE
f \ ui =non-float =
INTEGER
f mod ui =non-float =
INTEGER

bitops (f, ui):

f shl ui =non-float =
INTEGER
f shr ui =non-float =
INTEGER
f and ui =non-float =
INTEGER
f or ui =non-float =
INTEGER
f xor ui =non-float =
INTEGER
f eqv ui =non-float =
INTEGER
f imp ui =non-float =
INTEGER

relational ops (f, ui):

f =ui =integer =
INTEGER
f >ui =integer =
INTEGER
f <ui =integer =
INTEGER
f <> ui =integer =
INTEGER
f <= ui =integer =
INTEGER
f >= ui =integer =
INTEGER
f andalso ui =integer =
INTEGER
f orelse ui =integer =
INTEGER

math ops (f, l):

f + l =max =
SINGLE
f -l =max =
SINGLE
f * l =max =
SINGLE
f / l =float =
DOUBLE
f ^ l =float =
DOUBLE
f \ l =non-float =
INTEGER
f mod l =non-float =
INTEGER

bitops (f, l):

f shl l =non-float =
INTEGER
f shr l =non-float =
INTEGER
f and l =non-float =
INTEGER
f or l =non-float =
INTEGER
f xor l =non-float =
INTEGER
f eqv l =non-float =
INTEGER
f imp l =non-float =
INTEGER

relational ops (f, l):

f =l =integer =
INTEGER
f >l =integer =
INTEGER
f <l =integer =
INTEGER
f <> l =integer =
INTEGER
f <= l =integer =
INTEGER
f >= l =integer =
INTEGER
f andalso l =integer =
INTEGER
f orelse l =integer =
INTEGER

math ops (f, ul):

f + ul =max =
SINGLE
f -ul =max =
SINGLE
f * ul =max =
SINGLE
f / ul =float =
DOUBLE
f ^ ul =float =
DOUBLE
f \ ul =non-float =
INTEGER
f mod ul =non-float =
INTEGER

bitops (f, ul):

f shl ul =non-float =
INTEGER
f shr ul =non-float =
INTEGER
f and ul =non-float =
INTEGER
f or ul =non-float =
INTEGER
f xor ul =non-float =
INTEGER
f eqv ul =non-float =
INTEGER
f imp ul =non-float =
INTEGER

relational ops (f, ul):

f =ul =integer =
INTEGER
f >ul =integer =
INTEGER
f <ul =integer =
INTEGER
f <> ul =integer =
INTEGER
f <= ul =integer =
INTEGER
f >= ul =integer =
INTEGER
f andalso ul =integer =
INTEGER
f orelse ul =integer =
INTEGER

math ops (f, ll):

f + ll =max =
SINGLE
f -ll =max =
SINGLE
f * ll =max =
SINGLE
f / ll =float =
DOUBLE
f ^ ll =float =
DOUBLE
f \ ll =non-float =
LONGINT
f mod ll =non-float =
LONGINT

bitops (f, ll):

f shl ll =non-float =
LONGINT
f shr ll =non-float =
LONGINT
f and ll =non-float =
LONGINT
f or ll =non-float =
LONGINT
f xor ll =non-float =
LONGINT
f eqv ll =non-float =
LONGINT
f imp ll =non-float =
LONGINT

relational ops (f, ll):

f =ll =integer =
INTEGER
f >ll =integer =
INTEGER
f <ll =integer =
INTEGER
f <> ll =integer =
INTEGER
f <= ll =integer =
INTEGER
f >= ll =integer =
INTEGER
f andalso ll =integer =
INTEGER
f orelse ll =integer =
INTEGER

math ops (f, ull):

f + ull =max =
SINGLE
f -ull =max =
SINGLE
f * ull =max =
SINGLE
f / ull =float =
DOUBLE
f ^ ull =float =
DOUBLE
f \ ull =non-float =
ULONGINT
f mod ull =non-float =
ULONGINT

bitops (f, ull):

f shl ull =non-float =
ULONGINT
f shr ull =non-float =
ULONGINT
f and ull =non-float =
ULONGINT
f or ull =non-float =
ULONGINT
f xor ull =non-float =
ULONGINT
f eqv ull =non-float =
ULONGINT
f imp ull =non-float =
ULONGINT

relational ops (f, ull):

f =ull =integer =
INTEGER
f >ull =integer =
INTEGER
f <ull =integer =
INTEGER
f <> ull =integer =
INTEGER
f <= ull =integer =
INTEGER
f >= ull =integer =
INTEGER
f andalso ull =integer =
INTEGER
f orelse ull =integer =
INTEGER

math ops (f, enum1a):

f + enum1a =max =
	Implicit conversion
SINGLE
f -enum1a =max =
	Implicit conversion
SINGLE
f * enum1a =max =
	Implicit conversion
SINGLE
f / enum1a =float =
	Implicit conversion
DOUBLE
f ^ enum1a =float =
	Implicit conversion
DOUBLE
f \ enum1a =non-float =
	Implicit conversion
ENUM1
f mod enum1a =non-float =
	Implicit conversion
ENUM1

bitops (f, enum1a):

f shl enum1a =non-float =
	Implicit conversion
ENUM1
f shr enum1a =non-float =
	Implicit conversion
ENUM1
f and enum1a =non-float =
	Implicit conversion
ENUM1
f or enum1a =non-float =
	Implicit conversion
ENUM1
f xor enum1a =non-float =
	Implicit conversion
ENUM1
f eqv enum1a =non-float =
	Implicit conversion
ENUM1
f imp enum1a =non-float =
	Implicit conversion
ENUM1

relational ops (f, enum1a):

f =enum1a =integer =
	Implicit conversion
INTEGER
f >enum1a =integer =
	Implicit conversion
INTEGER
f <enum1a =integer =
	Implicit conversion
INTEGER
f <> enum1a =integer =
	Implicit conversion
INTEGER
f <= enum1a =integer =
	Implicit conversion
INTEGER
f >= enum1a =integer =
	Implicit conversion
INTEGER
f andalso enum1a =integer =
	Implicit conversion
INTEGER
f orelse enum1a =integer =
	Implicit conversion
INTEGER

math ops (b, f):

b + f =max =
SINGLE
b -f =max =
SINGLE
b * f =max =
SINGLE
b / f =float =
DOUBLE
b ^ f =float =
DOUBLE
b \ f =non-float =
INTEGER
b mod f =non-float =
INTEGER

bitops (b, f):

b shl f =non-float =
INTEGER
b shr f =non-float =
INTEGER
b and f =non-float =
INTEGER
b or f =non-float =
INTEGER
b xor f =non-float =
INTEGER
b eqv f =non-float =
INTEGER
b imp f =non-float =
INTEGER

relational ops (b, f):

b =f =integer =
INTEGER
b >f =integer =
INTEGER
b <f =integer =
INTEGER
b <> f =integer =
INTEGER
b <= f =integer =
INTEGER
b >= f =integer =
INTEGER
b andalso f =integer =
INTEGER
b orelse f =integer =
INTEGER

math ops (ub, f):

ub + f =max =
SINGLE
ub -f =max =
SINGLE
ub * f =max =
SINGLE
ub / f =float =
DOUBLE
ub ^ f =float =
DOUBLE
ub \ f =non-float =
UINTEGER
ub mod f =non-float =
UINTEGER

bitops (ub, f):

ub shl f =non-float =
UINTEGER
ub shr f =non-float =
UINTEGER
ub and f =non-float =
UINTEGER
ub or f =non-float =
UINTEGER
ub xor f =non-float =
UINTEGER
ub eqv f =non-float =
UINTEGER
ub imp f =non-float =
UINTEGER

relational ops (ub, f):

ub =f =integer =
INTEGER
ub >f =integer =
INTEGER
ub <f =integer =
INTEGER
ub <> f =integer =
INTEGER
ub <= f =integer =
INTEGER
ub >= f =integer =
INTEGER
ub andalso f =integer =
INTEGER
ub orelse f =integer =
INTEGER

math ops (sh, f):

sh + f =max =
SINGLE
sh -f =max =
SINGLE
sh * f =max =
SINGLE
sh / f =float =
DOUBLE
sh ^ f =float =
DOUBLE
sh \ f =non-float =
INTEGER
sh mod f =non-float =
INTEGER

bitops (sh, f):

sh shl f =non-float =
INTEGER
sh shr f =non-float =
INTEGER
sh and f =non-float =
INTEGER
sh or f =non-float =
INTEGER
sh xor f =non-float =
INTEGER
sh eqv f =non-float =
INTEGER
sh imp f =non-float =
INTEGER

relational ops (sh, f):

sh =f =integer =
INTEGER
sh >f =integer =
INTEGER
sh <f =integer =
INTEGER
sh <> f =integer =
INTEGER
sh <= f =integer =
INTEGER
sh >= f =integer =
INTEGER
sh andalso f =integer =
INTEGER
sh orelse f =integer =
INTEGER

math ops (ush, f):

ush + f =max =
SINGLE
ush -f =max =
SINGLE
ush * f =max =
SINGLE
ush / f =float =
DOUBLE
ush ^ f =float =
DOUBLE
ush \ f =non-float =
INTEGER
ush mod f =non-float =
INTEGER

bitops (ush, f):

ush shl f =non-float =
INTEGER
ush shr f =non-float =
INTEGER
ush and f =non-float =
INTEGER
ush or f =non-float =
INTEGER
ush xor f =non-float =
INTEGER
ush eqv f =non-float =
INTEGER
ush imp f =non-float =
INTEGER

relational ops (ush, f):

ush =f =integer =
INTEGER
ush >f =integer =
INTEGER
ush <f =integer =
INTEGER
ush <> f =integer =
INTEGER
ush <= f =integer =
INTEGER
ush >= f =integer =
INTEGER
ush andalso f =integer =
INTEGER
ush orelse f =integer =
INTEGER

math ops (i, f):

i + f =max =
SINGLE
i -f =max =
SINGLE
i * f =max =
SINGLE
i / f =float =
DOUBLE
i ^ f =float =
DOUBLE
i \ f =non-float =
INTEGER
i mod f =non-float =
INTEGER

bitops (i, f):

i shl f =non-float =
INTEGER
i shr f =non-float =
INTEGER
i and f =non-float =
INTEGER
i or f =non-float =
INTEGER
i xor f =non-float =
INTEGER
i eqv f =non-float =
INTEGER
i imp f =non-float =
INTEGER

relational ops (i, f):

i =f =integer =
INTEGER
i >f =integer =
INTEGER
i <f =integer =
INTEGER
i <> f =integer =
INTEGER
i <= f =integer =
INTEGER
i >= f =integer =
INTEGER
i andalso f =integer =
INTEGER
i orelse f =integer =
INTEGER

math ops (ui, f):

ui + f =max =
SINGLE
ui -f =max =
SINGLE
ui * f =max =
SINGLE
ui / f =float =
DOUBLE
ui ^ f =float =
DOUBLE
ui \ f =non-float =
UINTEGER
ui mod f =non-float =
UINTEGER

bitops (ui, f):

ui shl f =non-float =
UINTEGER
ui shr f =non-float =
UINTEGER
ui and f =non-float =
UINTEGER
ui or f =non-float =
UINTEGER
ui xor f =non-float =
UINTEGER
ui eqv f =non-float =
UINTEGER
ui imp f =non-float =
UINTEGER

relational ops (ui, f):

ui =f =integer =
INTEGER
ui >f =integer =
INTEGER
ui <f =integer =
INTEGER
ui <> f =integer =
INTEGER
ui <= f =integer =
INTEGER
ui >= f =integer =
INTEGER
ui andalso f =integer =
INTEGER
ui orelse f =integer =
INTEGER

math ops (l, f):

l + f =max =
SINGLE
l -f =max =
SINGLE
l * f =max =
SINGLE
l / f =float =
DOUBLE
l ^ f =float =
DOUBLE
l \ f =non-float =
LONG
l mod f =non-float =
LONG

bitops (l, f):

l shl f =non-float =
LONG
l shr f =non-float =
LONG
l and f =non-float =
LONG
l or f =non-float =
LONG
l xor f =non-float =
LONG
l eqv f =non-float =
LONG
l imp f =non-float =
LONG

relational ops (l, f):

l =f =integer =
INTEGER
l >f =integer =
INTEGER
l <f =integer =
INTEGER
l <> f =integer =
INTEGER
l <= f =integer =
INTEGER
l >= f =integer =
INTEGER
l andalso f =integer =
INTEGER
l orelse f =integer =
INTEGER

math ops (ul, f):

ul + f =max =
SINGLE
ul -f =max =
SINGLE
ul * f =max =
SINGLE
ul / f =float =
DOUBLE
ul ^ f =float =
DOUBLE
ul \ f =non-float =
ULONG
ul mod f =non-float =
ULONG

bitops (ul, f):

ul shl f =non-float =
ULONG
ul shr f =non-float =
ULONG
ul and f =non-float =
ULONG
ul or f =non-float =
ULONG
ul xor f =non-float =
ULONG
ul eqv f =non-float =
ULONG
ul imp f =non-float =
ULONG

relational ops (ul, f):

ul =f =integer =
INTEGER
ul >f =integer =
INTEGER
ul <f =integer =
INTEGER
ul <> f =integer =
INTEGER
ul <= f =integer =
INTEGER
ul >= f =integer =
INTEGER
ul andalso f =integer =
INTEGER
ul orelse f =integer =
INTEGER

math ops (ll, f):

ll + f =max =
SINGLE
ll -f =max =
SINGLE
ll * f =max =
SINGLE
ll / f =float =
DOUBLE
ll ^ f =float =
DOUBLE
ll \ f =non-float =
LONGINT
ll mod f =non-float =
LONGINT

bitops (ll, f):

ll shl f =non-float =
LONGINT
ll shr f =non-float =
LONGINT
ll and f =non-float =
LONGINT
ll or f =non-float =
LONGINT
ll xor f =non-float =
LONGINT
ll eqv f =non-float =
LONGINT
ll imp f =non-float =
LONGINT

relational ops (ll, f):

ll =f =integer =
INTEGER
ll >f =integer =
INTEGER
ll <f =integer =
INTEGER
ll <> f =integer =
INTEGER
ll <= f =integer =
INTEGER
ll >= f =integer =
INTEGER
ll andalso f =integer =
INTEGER
ll orelse f =integer =
INTEGER

math ops (ull, f):

ull + f =max =
SINGLE
ull -f =max =
SINGLE
ull * f =max =
SINGLE
ull / f =float =
DOUBLE
ull ^ f =float =
DOUBLE
ull \ f =non-float =
ULONGINT
ull mod f =non-float =
ULONGINT

bitops (ull, f):

ull shl f =non-float =
ULONGINT
ull shr f =non-float =
ULONGINT
ull and f =non-float =
ULONGINT
ull or f =non-float =
ULONGINT
ull xor f =non-float =
ULONGINT
ull eqv f =non-float =
ULONGINT
ull imp f =non-float =
ULONGINT

relational ops (ull, f):

ull =f =integer =
INTEGER
ull >f =integer =
INTEGER
ull <f =integer =
INTEGER
ull <> f =integer =
INTEGER
ull <= f =integer =
INTEGER
ull >= f =integer =
INTEGER
ull andalso f =integer =
INTEGER
ull orelse f =integer =
INTEGER

math ops (enum1a, f):

enum1a + f =max =
	Implicit conversion
SINGLE
enum1a -f =max =
	Implicit conversion
SINGLE
enum1a * f =max =
	Implicit conversion
SINGLE
enum1a / f =float =
	Implicit conversion
DOUBLE
enum1a ^ f =float =
	Implicit conversion
DOUBLE
enum1a \ f =non-float =
	Implicit conversion
ENUM1
enum1a mod f =non-float =
	Implicit conversion
ENUM1

bitops (enum1a, f):

enum1a shl f =non-float =
	Implicit conversion
ENUM1
enum1a shr f =non-float =
	Implicit conversion
ENUM1
enum1a and f =non-float =
	Implicit conversion
ENUM1
enum1a or f =non-float =
	Implicit conversion
ENUM1
enum1a xor f =non-float =
	Implicit conversion
ENUM1
enum1a eqv f =non-float =
	Implicit conversion
ENUM1
enum1a imp f =non-float =
	Implicit conversion
ENUM1

relational ops (enum1a, f):

enum1a =f =integer =
	Implicit conversion
INTEGER
enum1a >f =integer =
	Implicit conversion
INTEGER
enum1a <f =integer =
	Implicit conversion
INTEGER
enum1a <> f =integer =
	Implicit conversion
INTEGER
enum1a <= f =integer =
	Implicit conversion
INTEGER
enum1a >= f =integer =
	Implicit conversion
INTEGER
enum1a andalso f =integer =
	Implicit conversion
INTEGER
enum1a orelse f =integer =
	Implicit conversion
INTEGER

math ops (f, f):

f + f =max =
SINGLE
f -f =max =
SINGLE
f * f =max =
SINGLE
f / f =float =
SINGLE
f ^ f =float =
DOUBLE
f \ f =non-float =
INTEGER
f mod f =non-float =
INTEGER

bitops (f, f):

f shl f =non-float =
INTEGER
f shr f =non-float =
INTEGER
f and f =non-float =
INTEGER
f or f =non-float =
INTEGER
f xor f =non-float =
INTEGER
f eqv f =non-float =
INTEGER
f imp f =non-float =
INTEGER

relational ops (f, f):

f =f =integer =
INTEGER
f >f =integer =
INTEGER
f <f =integer =
INTEGER
f <> f =integer =
INTEGER
f <= f =integer =
INTEGER
f >= f =integer =
INTEGER
f andalso f =integer =
INTEGER
f orelse f =integer =
INTEGER

math ops (f, d):

f + d =max =
DOUBLE
f -d =max =
DOUBLE
f * d =max =
DOUBLE
f / d =float =
DOUBLE
f ^ d =float =
DOUBLE
f \ d =non-float =
INTEGER
f mod d =non-float =
INTEGER

bitops (f, d):

f shl d =non-float =
INTEGER
f shr d =non-float =
INTEGER
f and d =non-float =
INTEGER
f or d =non-float =
INTEGER
f xor d =non-float =
INTEGER
f eqv d =non-float =
INTEGER
f imp d =non-float =
INTEGER

relational ops (f, d):

f =d =integer =
INTEGER
f >d =integer =
INTEGER
f <d =integer =
INTEGER
f <> d =integer =
INTEGER
f <= d =integer =
INTEGER
f >= d =integer =
INTEGER
f andalso d =integer =
INTEGER
f orelse d =integer =
INTEGER

math ops (f, f):

f + f =max =
SINGLE
f -f =max =
SINGLE
f * f =max =
SINGLE
f / f =float =
SINGLE
f ^ f =float =
DOUBLE
f \ f =non-float =
INTEGER
f mod f =non-float =
INTEGER

bitops (f, f):

f shl f =non-float =
INTEGER
f shr f =non-float =
INTEGER
f and f =non-float =
INTEGER
f or f =non-float =
INTEGER
f xor f =non-float =
INTEGER
f eqv f =non-float =
INTEGER
f imp f =non-float =
INTEGER

relational ops (f, f):

f =f =integer =
INTEGER
f >f =integer =
INTEGER
f <f =integer =
INTEGER
f <> f =integer =
INTEGER
f <= f =integer =
INTEGER
f >= f =integer =
INTEGER
f andalso f =integer =
INTEGER
f orelse f =integer =
INTEGER

math ops (d, f):

d + f =max =
DOUBLE
d -f =max =
DOUBLE
d * f =max =
DOUBLE
d / f =float =
DOUBLE
d ^ f =float =
DOUBLE
d \ f =non-float =
INTEGER
d mod f =non-float =
INTEGER

bitops (d, f):

d shl f =non-float =
INTEGER
d shr f =non-float =
INTEGER
d and f =non-float =
INTEGER
d or f =non-float =
INTEGER
d xor f =non-float =
INTEGER
d eqv f =non-float =
INTEGER
d imp f =non-float =
INTEGER

relational ops (d, f):

d =f =integer =
INTEGER
d >f =integer =
INTEGER
d <f =integer =
INTEGER
d <> f =integer =
INTEGER
d <= f =integer =
INTEGER
d >= f =integer =
INTEGER
d andalso f =integer =
INTEGER
d orelse f =integer =
INTEGER

-----d -----------------------------------------------------


math ops (d, b):

d + b =max =
DOUBLE
d -b =max =
DOUBLE
d * b =max =
DOUBLE
d / b =float =
DOUBLE
d ^ b =float =
DOUBLE
d \ b =non-float =
INTEGER
d mod b =non-float =
INTEGER

bitops (d, b):

d shl b =non-float =
INTEGER
d shr b =non-float =
INTEGER
d and b =non-float =
INTEGER
d or b =non-float =
INTEGER
d xor b =non-float =
INTEGER
d eqv b =non-float =
INTEGER
d imp b =non-float =
INTEGER

relational ops (d, b):

d =b =integer =
INTEGER
d >b =integer =
INTEGER
d <b =integer =
INTEGER
d <> b =integer =
INTEGER
d <= b =integer =
INTEGER
d >= b =integer =
INTEGER
d andalso b =integer =
INTEGER
d orelse b =integer =
INTEGER

math ops (d, ub):

d + ub =max =
DOUBLE
d -ub =max =
DOUBLE
d * ub =max =
DOUBLE
d / ub =float =
DOUBLE
d ^ ub =float =
DOUBLE
d \ ub =non-float =
INTEGER
d mod ub =non-float =
INTEGER

bitops (d, ub):

d shl ub =non-float =
INTEGER
d shr ub =non-float =
INTEGER
d and ub =non-float =
INTEGER
d or ub =non-float =
INTEGER
d xor ub =non-float =
INTEGER
d eqv ub =non-float =
INTEGER
d imp ub =non-float =
INTEGER

relational ops (d, ub):

d =ub =integer =
INTEGER
d >ub =integer =
INTEGER
d <ub =integer =
INTEGER
d <> ub =integer =
INTEGER
d <= ub =integer =
INTEGER
d >= ub =integer =
INTEGER
d andalso ub =integer =
INTEGER
d orelse ub =integer =
INTEGER

math ops (d, sh):

d + sh =max =
DOUBLE
d -sh =max =
DOUBLE
d * sh =max =
DOUBLE
d / sh =float =
DOUBLE
d ^ sh =float =
DOUBLE
d \ sh =non-float =
INTEGER
d mod sh =non-float =
INTEGER

bitops (d, sh):

d shl sh =non-float =
INTEGER
d shr sh =non-float =
INTEGER
d and sh =non-float =
INTEGER
d or sh =non-float =
INTEGER
d xor sh =non-float =
INTEGER
d eqv sh =non-float =
INTEGER
d imp sh =non-float =
INTEGER

relational ops (d, sh):

d =sh =integer =
INTEGER
d >sh =integer =
INTEGER
d <sh =integer =
INTEGER
d <> sh =integer =
INTEGER
d <= sh =integer =
INTEGER
d >= sh =integer =
INTEGER
d andalso sh =integer =
INTEGER
d orelse sh =integer =
INTEGER

math ops (d, ush):

d + ush =max =
DOUBLE
d -ush =max =
DOUBLE
d * ush =max =
DOUBLE
d / ush =float =
DOUBLE
d ^ ush =float =
DOUBLE
d \ ush =non-float =
INTEGER
d mod ush =non-float =
INTEGER

bitops (d, ush):

d shl ush =non-float =
INTEGER
d shr ush =non-float =
INTEGER
d and ush =non-float =
INTEGER
d or ush =non-float =
INTEGER
d xor ush =non-float =
INTEGER
d eqv ush =non-float =
INTEGER
d imp ush =non-float =
INTEGER

relational ops (d, ush):

d =ush =integer =
INTEGER
d >ush =integer =
INTEGER
d <ush =integer =
INTEGER
d <> ush =integer =
INTEGER
d <= ush =integer =
INTEGER
d >= ush =integer =
INTEGER
d andalso ush =integer =
INTEGER
d orelse ush =integer =
INTEGER

math ops (d, i):

d + i =max =
DOUBLE
d -i =max =
DOUBLE
d * i =max =
DOUBLE
d / i =float =
DOUBLE
d ^ i =float =
DOUBLE
d \ i =non-float =
INTEGER
d mod i =non-float =
INTEGER

bitops (d, i):

d shl i =non-float =
INTEGER
d shr i =non-float =
INTEGER
d and i =non-float =
INTEGER
d or i =non-float =
INTEGER
d xor i =non-float =
INTEGER
d eqv i =non-float =
INTEGER
d imp i =non-float =
INTEGER

relational ops (d, i):

d =i =integer =
INTEGER
d >i =integer =
INTEGER
d <i =integer =
INTEGER
d <> i =integer =
INTEGER
d <= i =integer =
INTEGER
d >= i =integer =
INTEGER
d andalso i =integer =
INTEGER
d orelse i =integer =
INTEGER

math ops (d, ui):

d + ui =max =
DOUBLE
d -ui =max =
DOUBLE
d * ui =max =
DOUBLE
d / ui =float =
DOUBLE
d ^ ui =float =
DOUBLE
d \ ui =non-float =
INTEGER
d mod ui =non-float =
INTEGER

bitops (d, ui):

d shl ui =non-float =
INTEGER
d shr ui =non-float =
INTEGER
d and ui =non-float =
INTEGER
d or ui =non-float =
INTEGER
d xor ui =non-float =
INTEGER
d eqv ui =non-float =
INTEGER
d imp ui =non-float =
INTEGER

relational ops (d, ui):

d =ui =integer =
INTEGER
d >ui =integer =
INTEGER
d <ui =integer =
INTEGER
d <> ui =integer =
INTEGER
d <= ui =integer =
INTEGER
d >= ui =integer =
INTEGER
d andalso ui =integer =
INTEGER
d orelse ui =integer =
INTEGER

math ops (d, l):

d + l =max =
DOUBLE
d -l =max =
DOUBLE
d * l =max =
DOUBLE
d / l =float =
DOUBLE
d ^ l =float =
DOUBLE
d \ l =non-float =
INTEGER
d mod l =non-float =
INTEGER

bitops (d, l):

d shl l =non-float =
INTEGER
d shr l =non-float =
INTEGER
d and l =non-float =
INTEGER
d or l =non-float =
INTEGER
d xor l =non-float =
INTEGER
d eqv l =non-float =
INTEGER
d imp l =non-float =
INTEGER

relational ops (d, l):

d =l =integer =
INTEGER
d >l =integer =
INTEGER
d <l =integer =
INTEGER
d <> l =integer =
INTEGER
d <= l =integer =
INTEGER
d >= l =integer =
INTEGER
d andalso l =integer =
INTEGER
d orelse l =integer =
INTEGER

math ops (d, ul):

d + ul =max =
DOUBLE
d -ul =max =
DOUBLE
d * ul =max =
DOUBLE
d / ul =float =
DOUBLE
d ^ ul =float =
DOUBLE
d \ ul =non-float =
INTEGER
d mod ul =non-float =
INTEGER

bitops (d, ul):

d shl ul =non-float =
INTEGER
d shr ul =non-float =
INTEGER
d and ul =non-float =
INTEGER
d or ul =non-float =
INTEGER
d xor ul =non-float =
INTEGER
d eqv ul =non-float =
INTEGER
d imp ul =non-float =
INTEGER

relational ops (d, ul):

d =ul =integer =
INTEGER
d >ul =integer =
INTEGER
d <ul =integer =
INTEGER
d <> ul =integer =
INTEGER
d <= ul =integer =
INTEGER
d >= ul =integer =
INTEGER
d andalso ul =integer =
INTEGER
d orelse ul =integer =
INTEGER

math ops (d, ll):

d + ll =max =
DOUBLE
d -ll =max =
DOUBLE
d * ll =max =
DOUBLE
d / ll =float =
DOUBLE
d ^ ll =float =
DOUBLE
d \ ll =non-float =
LONGINT
d mod ll =non-float =
LONGINT

bitops (d, ll):

d shl ll =non-float =
LONGINT
d shr ll =non-float =
LONGINT
d and ll =non-float =
LONGINT
d or ll =non-float =
LONGINT
d xor ll =non-float =
LONGINT
d eqv ll =non-float =
LONGINT
d imp ll =non-float =
LONGINT

relational ops (d, ll):

d =ll =integer =
INTEGER
d >ll =integer =
INTEGER
d <ll =integer =
INTEGER
d <> ll =integer =
INTEGER
d <= ll =integer =
INTEGER
d >= ll =integer =
INTEGER
d andalso ll =integer =
INTEGER
d orelse ll =integer =
INTEGER

math ops (d, ull):

d + ull =max =
DOUBLE
d -ull =max =
DOUBLE
d * ull =max =
DOUBLE
d / ull =float =
DOUBLE
d ^ ull =float =
DOUBLE
d \ ull =non-float =
ULONGINT
d mod ull =non-float =
ULONGINT

bitops (d, ull):

d shl ull =non-float =
ULONGINT
d shr ull =non-float =
ULONGINT
d and ull =non-float =
ULONGINT
d or ull =non-float =
ULONGINT
d xor ull =non-float =
ULONGINT
d eqv ull =non-float =
ULONGINT
d imp ull =non-float =
ULONGINT

relational ops (d, ull):

d =ull =integer =
INTEGER
d >ull =integer =
INTEGER
d <ull =integer =
INTEGER
d <> ull =integer =
INTEGER
d <= ull =integer =
INTEGER
d >= ull =integer =
INTEGER
d andalso ull =integer =
INTEGER
d orelse ull =integer =
INTEGER

math ops (d, enum1a):

d + enum1a =max =
	Implicit conversion
DOUBLE
d -enum1a =max =
	Implicit conversion
DOUBLE
d * enum1a =max =
	Implicit conversion
DOUBLE
d / enum1a =float =
	Implicit conversion
DOUBLE
d ^ enum1a =float =
	Implicit conversion
DOUBLE
d \ enum1a =non-float =
	Implicit conversion
ENUM1
d mod enum1a =non-float =
	Implicit conversion
ENUM1

bitops (d, enum1a):

d shl enum1a =non-float =
	Implicit conversion
ENUM1
d shr enum1a =non-float =
	Implicit conversion
ENUM1
d and enum1a =non-float =
	Implicit conversion
ENUM1
d or enum1a =non-float =
	Implicit conversion
ENUM1
d xor enum1a =non-float =
	Implicit conversion
ENUM1
d eqv enum1a =non-float =
	Implicit conversion
ENUM1
d imp enum1a =non-float =
	Implicit conversion
ENUM1

relational ops (d, enum1a):

d =enum1a =integer =
	Implicit conversion
INTEGER
d >enum1a =integer =
	Implicit conversion
INTEGER
d <enum1a =integer =
	Implicit conversion
INTEGER
d <> enum1a =integer =
	Implicit conversion
INTEGER
d <= enum1a =integer =
	Implicit conversion
INTEGER
d >= enum1a =integer =
	Implicit conversion
INTEGER
d andalso enum1a =integer =
	Implicit conversion
INTEGER
d orelse enum1a =integer =
	Implicit conversion
INTEGER

math ops (b, d):

b + d =max =
DOUBLE
b -d =max =
DOUBLE
b * d =max =
DOUBLE
b / d =float =
DOUBLE
b ^ d =float =
DOUBLE
b \ d =non-float =
INTEGER
b mod d =non-float =
INTEGER

bitops (b, d):

b shl d =non-float =
INTEGER
b shr d =non-float =
INTEGER
b and d =non-float =
INTEGER
b or d =non-float =
INTEGER
b xor d =non-float =
INTEGER
b eqv d =non-float =
INTEGER
b imp d =non-float =
INTEGER

relational ops (b, d):

b =d =integer =
INTEGER
b >d =integer =
INTEGER
b <d =integer =
INTEGER
b <> d =integer =
INTEGER
b <= d =integer =
INTEGER
b >= d =integer =
INTEGER
b andalso d =integer =
INTEGER
b orelse d =integer =
INTEGER

math ops (ub, d):

ub + d =max =
DOUBLE
ub -d =max =
DOUBLE
ub * d =max =
DOUBLE
ub / d =float =
DOUBLE
ub ^ d =float =
DOUBLE
ub \ d =non-float =
UINTEGER
ub mod d =non-float =
UINTEGER

bitops (ub, d):

ub shl d =non-float =
UINTEGER
ub shr d =non-float =
UINTEGER
ub and d =non-float =
UINTEGER
ub or d =non-float =
UINTEGER
ub xor d =non-float =
UINTEGER
ub eqv d =non-float =
UINTEGER
ub imp d =non-float =
UINTEGER

relational ops (ub, d):

ub =d =integer =
INTEGER
ub >d =integer =
INTEGER
ub <d =integer =
INTEGER
ub <> d =integer =
INTEGER
ub <= d =integer =
INTEGER
ub >= d =integer =
INTEGER
ub andalso d =integer =
INTEGER
ub orelse d =integer =
INTEGER

math ops (sh, d):

sh + d =max =
DOUBLE
sh -d =max =
DOUBLE
sh * d =max =
DOUBLE
sh / d =float =
DOUBLE
sh ^ d =float =
DOUBLE
sh \ d =non-float =
INTEGER
sh mod d =non-float =
INTEGER

bitops (sh, d):

sh shl d =non-float =
INTEGER
sh shr d =non-float =
INTEGER
sh and d =non-float =
INTEGER
sh or d =non-float =
INTEGER
sh xor d =non-float =
INTEGER
sh eqv d =non-float =
INTEGER
sh imp d =non-float =
INTEGER

relational ops (sh, d):

sh =d =integer =
INTEGER
sh >d =integer =
INTEGER
sh <d =integer =
INTEGER
sh <> d =integer =
INTEGER
sh <= d =integer =
INTEGER
sh >= d =integer =
INTEGER
sh andalso d =integer =
INTEGER
sh orelse d =integer =
INTEGER

math ops (ush, d):

ush + d =max =
DOUBLE
ush -d =max =
DOUBLE
ush * d =max =
DOUBLE
ush / d =float =
DOUBLE
ush ^ d =float =
DOUBLE
ush \ d =non-float =
INTEGER
ush mod d =non-float =
INTEGER

bitops (ush, d):

ush shl d =non-float =
INTEGER
ush shr d =non-float =
INTEGER
ush and d =non-float =
INTEGER
ush or d =non-float =
INTEGER
ush xor d =non-float =
INTEGER
ush eqv d =non-float =
INTEGER
ush imp d =non-float =
INTEGER

relational ops (ush, d):

ush =d =integer =
INTEGER
ush >d =integer =
INTEGER
ush <d =integer =
INTEGER
ush <> d =integer =
INTEGER
ush <= d =integer =
INTEGER
ush >= d =integer =
INTEGER
ush andalso d =integer =
INTEGER
ush orelse d =integer =
INTEGER

math ops (i, d):

i + d =max =
DOUBLE
i -d =max =
DOUBLE
i * d =max =
DOUBLE
i / d =float =
DOUBLE
i ^ d =float =
DOUBLE
i \ d =non-float =
INTEGER
i mod d =non-float =
INTEGER

bitops (i, d):

i shl d =non-float =
INTEGER
i shr d =non-float =
INTEGER
i and d =non-float =
INTEGER
i or d =non-float =
INTEGER
i xor d =non-float =
INTEGER
i eqv d =non-float =
INTEGER
i imp d =non-float =
INTEGER

relational ops (i, d):

i =d =integer =
INTEGER
i >d =integer =
INTEGER
i <d =integer =
INTEGER
i <> d =integer =
INTEGER
i <= d =integer =
INTEGER
i >= d =integer =
INTEGER
i andalso d =integer =
INTEGER
i orelse d =integer =
INTEGER

math ops (ui, d):

ui + d =max =
DOUBLE
ui -d =max =
DOUBLE
ui * d =max =
DOUBLE
ui / d =float =
DOUBLE
ui ^ d =float =
DOUBLE
ui \ d =non-float =
UINTEGER
ui mod d =non-float =
UINTEGER

bitops (ui, d):

ui shl d =non-float =
UINTEGER
ui shr d =non-float =
UINTEGER
ui and d =non-float =
UINTEGER
ui or d =non-float =
UINTEGER
ui xor d =non-float =
UINTEGER
ui eqv d =non-float =
UINTEGER
ui imp d =non-float =
UINTEGER

relational ops (ui, d):

ui =d =integer =
INTEGER
ui >d =integer =
INTEGER
ui <d =integer =
INTEGER
ui <> d =integer =
INTEGER
ui <= d =integer =
INTEGER
ui >= d =integer =
INTEGER
ui andalso d =integer =
INTEGER
ui orelse d =integer =
INTEGER

math ops (l, d):

l + d =max =
DOUBLE
l -d =max =
DOUBLE
l * d =max =
DOUBLE
l / d =float =
DOUBLE
l ^ d =float =
DOUBLE
l \ d =non-float =
LONG
l mod d =non-float =
LONG

bitops (l, d):

l shl d =non-float =
LONG
l shr d =non-float =
LONG
l and d =non-float =
LONG
l or d =non-float =
LONG
l xor d =non-float =
LONG
l eqv d =non-float =
LONG
l imp d =non-float =
LONG

relational ops (l, d):

l =d =integer =
INTEGER
l >d =integer =
INTEGER
l <d =integer =
INTEGER
l <> d =integer =
INTEGER
l <= d =integer =
INTEGER
l >= d =integer =
INTEGER
l andalso d =integer =
INTEGER
l orelse d =integer =
INTEGER

math ops (ul, d):

ul + d =max =
DOUBLE
ul -d =max =
DOUBLE
ul * d =max =
DOUBLE
ul / d =float =
DOUBLE
ul ^ d =float =
DOUBLE
ul \ d =non-float =
ULONG
ul mod d =non-float =
ULONG

bitops (ul, d):

ul shl d =non-float =
ULONG
ul shr d =non-float =
ULONG
ul and d =non-float =
ULONG
ul or d =non-float =
ULONG
ul xor d =non-float =
ULONG
ul eqv d =non-float =
ULONG
ul imp d =non-float =
ULONG

relational ops (ul, d):

ul =d =integer =
INTEGER
ul >d =integer =
INTEGER
ul <d =integer =
INTEGER
ul <> d =integer =
INTEGER
ul <= d =integer =
INTEGER
ul >= d =integer =
INTEGER
ul andalso d =integer =
INTEGER
ul orelse d =integer =
INTEGER

math ops (ll, d):

ll + d =max =
DOUBLE
ll -d =max =
DOUBLE
ll * d =max =
DOUBLE
ll / d =float =
DOUBLE
ll ^ d =float =
DOUBLE
ll \ d =non-float =
LONGINT
ll mod d =non-float =
LONGINT

bitops (ll, d):

ll shl d =non-float =
LONGINT
ll shr d =non-float =
LONGINT
ll and d =non-float =
LONGINT
ll or d =non-float =
LONGINT
ll xor d =non-float =
LONGINT
ll eqv d =non-float =
LONGINT
ll imp d =non-float =
LONGINT

relational ops (ll, d):

ll =d =integer =
INTEGER
ll >d =integer =
INTEGER
ll <d =integer =
INTEGER
ll <> d =integer =
INTEGER
ll <= d =integer =
INTEGER
ll >= d =integer =
INTEGER
ll andalso d =integer =
INTEGER
ll orelse d =integer =
INTEGER

math ops (ull, d):

ull + d =max =
DOUBLE
ull -d =max =
DOUBLE
ull * d =max =
DOUBLE
ull / d =float =
DOUBLE
ull ^ d =float =
DOUBLE
ull \ d =non-float =
ULONGINT
ull mod d =non-float =
ULONGINT

bitops (ull, d):

ull shl d =non-float =
ULONGINT
ull shr d =non-float =
ULONGINT
ull and d =non-float =
ULONGINT
ull or d =non-float =
ULONGINT
ull xor d =non-float =
ULONGINT
ull eqv d =non-float =
ULONGINT
ull imp d =non-float =
ULONGINT

relational ops (ull, d):

ull =d =integer =
INTEGER
ull >d =integer =
INTEGER
ull <d =integer =
INTEGER
ull <> d =integer =
INTEGER
ull <= d =integer =
INTEGER
ull >= d =integer =
INTEGER
ull andalso d =integer =
INTEGER
ull orelse d =integer =
INTEGER

math ops (enum1a, d):

enum1a + d =max =
	Implicit conversion
DOUBLE
enum1a -d =max =
	Implicit conversion
DOUBLE
enum1a * d =max =
	Implicit conversion
DOUBLE
enum1a / d =float =
	Implicit conversion
DOUBLE
enum1a ^ d =float =
	Implicit conversion
DOUBLE
enum1a \ d =non-float =
	Implicit conversion
ENUM1
enum1a mod d =non-float =
	Implicit conversion
ENUM1

bitops (enum1a, d):

enum1a shl d =non-float =
	Implicit conversion
ENUM1
enum1a shr d =non-float =
	Implicit conversion
ENUM1
enum1a and d =non-float =
	Implicit conversion
ENUM1
enum1a or d =non-float =
	Implicit conversion
ENUM1
enum1a xor d =non-float =
	Implicit conversion
ENUM1
enum1a eqv d =non-float =
	Implicit conversion
ENUM1
enum1a imp d =non-float =
	Implicit conversion
ENUM1

relational ops (enum1a, d):

enum1a =d =integer =
	Implicit conversion
INTEGER
enum1a >d =integer =
	Implicit conversion
INTEGER
enum1a <d =integer =
	Implicit conversion
INTEGER
enum1a <> d =integer =
	Implicit conversion
INTEGER
enum1a <= d =integer =
	Implicit conversion
INTEGER
enum1a >= d =integer =
	Implicit conversion
INTEGER
enum1a andalso d =integer =
	Implicit conversion
INTEGER
enum1a orelse d =integer =
	Implicit conversion
INTEGER

math ops (d, f):

d + f =max =
DOUBLE
d -f =max =
DOUBLE
d * f =max =
DOUBLE
d / f =float =
DOUBLE
d ^ f =float =
DOUBLE
d \ f =non-float =
INTEGER
d mod f =non-float =
INTEGER

bitops (d, f):

d shl f =non-float =
INTEGER
d shr f =non-float =
INTEGER
d and f =non-float =
INTEGER
d or f =non-float =
INTEGER
d xor f =non-float =
INTEGER
d eqv f =non-float =
INTEGER
d imp f =non-float =
INTEGER

relational ops (d, f):

d =f =integer =
INTEGER
d >f =integer =
INTEGER
d <f =integer =
INTEGER
d <> f =integer =
INTEGER
d <= f =integer =
INTEGER
d >= f =integer =
INTEGER
d andalso f =integer =
INTEGER
d orelse f =integer =
INTEGER

math ops (d, d):

d + d =max =
DOUBLE
d -d =max =
DOUBLE
d * d =max =
DOUBLE
d / d =float =
DOUBLE
d ^ d =float =
DOUBLE
d \ d =non-float =
INTEGER
d mod d =non-float =
INTEGER

bitops (d, d):

d shl d =non-float =
INTEGER
d shr d =non-float =
INTEGER
d and d =non-float =
INTEGER
d or d =non-float =
INTEGER
d xor d =non-float =
INTEGER
d eqv d =non-float =
INTEGER
d imp d =non-float =
INTEGER

relational ops (d, d):

d =d =integer =
INTEGER
d >d =integer =
INTEGER
d <d =integer =
INTEGER
d <> d =integer =
INTEGER
d <= d =integer =
INTEGER
d >= d =integer =
INTEGER
d andalso d =integer =
INTEGER
d orelse d =integer =
INTEGER

math ops (f, d):

f + d =max =
DOUBLE
f -d =max =
DOUBLE
f * d =max =
DOUBLE
f / d =float =
DOUBLE
f ^ d =float =
DOUBLE
f \ d =non-float =
INTEGER
f mod d =non-float =
INTEGER

bitops (f, d):

f shl d =non-float =
INTEGER
f shr d =non-float =
INTEGER
f and d =non-float =
INTEGER
f or d =non-float =
INTEGER
f xor d =non-float =
INTEGER
f eqv d =non-float =
INTEGER
f imp d =non-float =
INTEGER

relational ops (f, d):

f =d =integer =
INTEGER
f >d =integer =
INTEGER
f <d =integer =
INTEGER
f <> d =integer =
INTEGER
f <= d =integer =
INTEGER
f >= d =integer =
INTEGER
f andalso d =integer =
INTEGER
f orelse d =integer =
INTEGER

math ops (d, d):

d + d =max =
DOUBLE
d -d =max =
DOUBLE
d * d =max =
DOUBLE
d / d =float =
DOUBLE
d ^ d =float =
DOUBLE
d \ d =non-float =
INTEGER
d mod d =non-float =
INTEGER

bitops (d, d):

d shl d =non-float =
INTEGER
d shr d =non-float =
INTEGER
d and d =non-float =
INTEGER
d or d =non-float =
INTEGER
d xor d =non-float =
INTEGER
d eqv d =non-float =
INTEGER
d imp d =non-float =
INTEGER

relational ops (d, d):

d =d =integer =
INTEGER
d >d =integer =
INTEGER
d <d =integer =
INTEGER
d <> d =integer =
INTEGER
d <= d =integer =
INTEGER
d >= d =integer =
INTEGER
d andalso d =integer =
INTEGER
d orelse d =integer =
INTEGER

----------------------------------------------------------------------
enums:
----------------------------------------------------------------------


-----enum1a -----------------------------------------------------


math ops (enum1a, b):

enum1a + b =max =
ENUM1
enum1a -b =max =
ENUM1
enum1a * b =max =
ENUM1
enum1a / b =float =
DOUBLE
enum1a ^ b =float =
DOUBLE
enum1a \ b =non-float =
ENUM1
enum1a mod b =non-float =
ENUM1

bitops (enum1a, b):

enum1a shl b =non-float =
ENUM1
enum1a shr b =non-float =
ENUM1
enum1a and b =non-float =
ENUM1
enum1a or b =non-float =
ENUM1
enum1a xor b =non-float =
ENUM1
enum1a eqv b =non-float =
ENUM1
enum1a imp b =non-float =
ENUM1

relational ops (enum1a, b):

enum1a =b =integer =
INTEGER
enum1a >b =integer =
INTEGER
enum1a <b =integer =
INTEGER
enum1a <> b =integer =
INTEGER
enum1a <= b =integer =
INTEGER
enum1a >= b =integer =
INTEGER
enum1a andalso b =integer =
INTEGER
enum1a orelse b =integer =
INTEGER

math ops (enum1a, ub):

enum1a + ub =max =
ENUM1
enum1a -ub =max =
ENUM1
enum1a * ub =max =
ENUM1
enum1a / ub =float =
DOUBLE
enum1a ^ ub =float =
DOUBLE
enum1a \ ub =non-float =
ENUM1
enum1a mod ub =non-float =
ENUM1

bitops (enum1a, ub):

enum1a shl ub =non-float =
ENUM1
enum1a shr ub =non-float =
ENUM1
enum1a and ub =non-float =
ENUM1
enum1a or ub =non-float =
ENUM1
enum1a xor ub =non-float =
ENUM1
enum1a eqv ub =non-float =
ENUM1
enum1a imp ub =non-float =
ENUM1

relational ops (enum1a, ub):

enum1a =ub =integer =
INTEGER
enum1a >ub =integer =
INTEGER
enum1a <ub =integer =
INTEGER
enum1a <> ub =integer =
INTEGER
enum1a <= ub =integer =
INTEGER
enum1a >= ub =integer =
INTEGER
enum1a andalso ub =integer =
INTEGER
enum1a orelse ub =integer =
INTEGER

math ops (enum1a, sh):

enum1a + sh =max =
ENUM1
enum1a -sh =max =
ENUM1
enum1a * sh =max =
ENUM1
enum1a / sh =float =
DOUBLE
enum1a ^ sh =float =
DOUBLE
enum1a \ sh =non-float =
ENUM1
enum1a mod sh =non-float =
ENUM1

bitops (enum1a, sh):

enum1a shl sh =non-float =
ENUM1
enum1a shr sh =non-float =
ENUM1
enum1a and sh =non-float =
ENUM1
enum1a or sh =non-float =
ENUM1
enum1a xor sh =non-float =
ENUM1
enum1a eqv sh =non-float =
ENUM1
enum1a imp sh =non-float =
ENUM1

relational ops (enum1a, sh):

enum1a =sh =integer =
INTEGER
enum1a >sh =integer =
INTEGER
enum1a <sh =integer =
INTEGER
enum1a <> sh =integer =
INTEGER
enum1a <= sh =integer =
INTEGER
enum1a >= sh =integer =
INTEGER
enum1a andalso sh =integer =
INTEGER
enum1a orelse sh =integer =
INTEGER

math ops (enum1a, ush):

enum1a + ush =max =
ENUM1
enum1a -ush =max =
ENUM1
enum1a * ush =max =
ENUM1
enum1a / ush =float =
DOUBLE
enum1a ^ ush =float =
DOUBLE
enum1a \ ush =non-float =
ENUM1
enum1a mod ush =non-float =
ENUM1

bitops (enum1a, ush):

enum1a shl ush =non-float =
ENUM1
enum1a shr ush =non-float =
ENUM1
enum1a and ush =non-float =
ENUM1
enum1a or ush =non-float =
ENUM1
enum1a xor ush =non-float =
ENUM1
enum1a eqv ush =non-float =
ENUM1
enum1a imp ush =non-float =
ENUM1

relational ops (enum1a, ush):

enum1a =ush =integer =
INTEGER
enum1a >ush =integer =
INTEGER
enum1a <ush =integer =
INTEGER
enum1a <> ush =integer =
INTEGER
enum1a <= ush =integer =
INTEGER
enum1a >= ush =integer =
INTEGER
enum1a andalso ush =integer =
INTEGER
enum1a orelse ush =integer =
INTEGER

math ops (enum1a, i):

enum1a + i =max =
ENUM1
enum1a -i =max =
ENUM1
enum1a * i =max =
ENUM1
enum1a / i =float =
DOUBLE
enum1a ^ i =float =
DOUBLE
enum1a \ i =non-float =
ENUM1
enum1a mod i =non-float =
ENUM1

bitops (enum1a, i):

enum1a shl i =non-float =
ENUM1
enum1a shr i =non-float =
ENUM1
enum1a and i =non-float =
ENUM1
enum1a or i =non-float =
ENUM1
enum1a xor i =non-float =
ENUM1
enum1a eqv i =non-float =
ENUM1
enum1a imp i =non-float =
ENUM1

relational ops (enum1a, i):

enum1a =i =integer =
INTEGER
enum1a >i =integer =
INTEGER
enum1a <i =integer =
INTEGER
enum1a <> i =integer =
INTEGER
enum1a <= i =integer =
INTEGER
enum1a >= i =integer =
INTEGER
enum1a andalso i =integer =
INTEGER
enum1a orelse i =integer =
INTEGER

math ops (enum1a, ui):

enum1a + ui =max =
ENUM1
enum1a -ui =max =
ENUM1
enum1a * ui =max =
ENUM1
enum1a / ui =float =
DOUBLE
enum1a ^ ui =float =
DOUBLE
enum1a \ ui =non-float =
ENUM1
enum1a mod ui =non-float =
ENUM1

bitops (enum1a, ui):

enum1a shl ui =non-float =
ENUM1
enum1a shr ui =non-float =
ENUM1
enum1a and ui =non-float =
ENUM1
enum1a or ui =non-float =
ENUM1
enum1a xor ui =non-float =
ENUM1
enum1a eqv ui =non-float =
ENUM1
enum1a imp ui =non-float =
ENUM1

relational ops (enum1a, ui):

enum1a =ui =integer =
INTEGER
enum1a >ui =integer =
INTEGER
enum1a <ui =integer =
INTEGER
enum1a <> ui =integer =
INTEGER
enum1a <= ui =integer =
INTEGER
enum1a >= ui =integer =
INTEGER
enum1a andalso ui =integer =
INTEGER
enum1a orelse ui =integer =
INTEGER

math ops (enum1a, l):

enum1a + l =max =
ENUM1
enum1a -l =max =
ENUM1
enum1a * l =max =
ENUM1
enum1a / l =float =
DOUBLE
enum1a ^ l =float =
DOUBLE
enum1a \ l =non-float =
ENUM1
enum1a mod l =non-float =
ENUM1

bitops (enum1a, l):

enum1a shl l =non-float =
ENUM1
enum1a shr l =non-float =
ENUM1
enum1a and l =non-float =
ENUM1
enum1a or l =non-float =
ENUM1
enum1a xor l =non-float =
ENUM1
enum1a eqv l =non-float =
ENUM1
enum1a imp l =non-float =
ENUM1

relational ops (enum1a, l):

enum1a =l =integer =
INTEGER
enum1a >l =integer =
INTEGER
enum1a <l =integer =
INTEGER
enum1a <> l =integer =
INTEGER
enum1a <= l =integer =
INTEGER
enum1a >= l =integer =
INTEGER
enum1a andalso l =integer =
INTEGER
enum1a orelse l =integer =
INTEGER

math ops (enum1a, ul):

enum1a + ul =max =
ENUM1
enum1a -ul =max =
ENUM1
enum1a * ul =max =
ENUM1
enum1a / ul =float =
DOUBLE
enum1a ^ ul =float =
DOUBLE
enum1a \ ul =non-float =
ENUM1
enum1a mod ul =non-float =
ENUM1

bitops (enum1a, ul):

enum1a shl ul =non-float =
ENUM1
enum1a shr ul =non-float =
ENUM1
enum1a and ul =non-float =
ENUM1
enum1a or ul =non-float =
ENUM1
enum1a xor ul =non-float =
ENUM1
enum1a eqv ul =non-float =
ENUM1
enum1a imp ul =non-float =
ENUM1

relational ops (enum1a, ul):

enum1a =ul =integer =
INTEGER
enum1a >ul =integer =
INTEGER
enum1a <ul =integer =
INTEGER
enum1a <> ul =integer =
INTEGER
enum1a <= ul =integer =
INTEGER
enum1a >= ul =integer =
INTEGER
enum1a andalso ul =integer =
INTEGER
enum1a orelse ul =integer =
INTEGER

math ops (enum1a, ll):

enum1a + ll =max =
LONGINT
enum1a -ll =max =
LONGINT
enum1a * ll =max =
LONGINT
enum1a / ll =float =
DOUBLE
enum1a ^ ll =float =
DOUBLE
enum1a \ ll =non-float =
LONGINT
enum1a mod ll =non-float =
LONGINT

bitops (enum1a, ll):

enum1a shl ll =non-float =
LONGINT
enum1a shr ll =non-float =
LONGINT
enum1a and ll =non-float =
LONGINT
enum1a or ll =non-float =
LONGINT
enum1a xor ll =non-float =
LONGINT
enum1a eqv ll =non-float =
LONGINT
enum1a imp ll =non-float =
LONGINT

relational ops (enum1a, ll):

enum1a =ll =integer =
INTEGER
enum1a >ll =integer =
INTEGER
enum1a <ll =integer =
INTEGER
enum1a <> ll =integer =
INTEGER
enum1a <= ll =integer =
INTEGER
enum1a >= ll =integer =
INTEGER
enum1a andalso ll =integer =
INTEGER
enum1a orelse ll =integer =
INTEGER

math ops (enum1a, ull):

enum1a + ull =max =
ULONGINT
enum1a -ull =max =
ULONGINT
enum1a * ull =max =
ULONGINT
enum1a / ull =float =
DOUBLE
enum1a ^ ull =float =
DOUBLE
enum1a \ ull =non-float =
ULONGINT
enum1a mod ull =non-float =
ULONGINT

bitops (enum1a, ull):

enum1a shl ull =non-float =
ULONGINT
enum1a shr ull =non-float =
ULONGINT
enum1a and ull =non-float =
ULONGINT
enum1a or ull =non-float =
ULONGINT
enum1a xor ull =non-float =
ULONGINT
enum1a eqv ull =non-float =
ULONGINT
enum1a imp ull =non-float =
ULONGINT

relational ops (enum1a, ull):

enum1a =ull =integer =
INTEGER
enum1a >ull =integer =
INTEGER
enum1a <ull =integer =
INTEGER
enum1a <> ull =integer =
INTEGER
enum1a <= ull =integer =
INTEGER
enum1a >= ull =integer =
INTEGER
enum1a andalso ull =integer =
INTEGER
enum1a orelse ull =integer =
INTEGER

math ops (enum1a, enum1a):

enum1a + enum1a =max =
ENUM1
enum1a -enum1a =max =
ENUM1
enum1a * enum1a =max =
ENUM1
enum1a / enum1a =float =
DOUBLE
enum1a ^ enum1a =float =
DOUBLE
enum1a \ enum1a =non-float =
ENUM1
enum1a mod enum1a =non-float =
ENUM1

bitops (enum1a, enum1a):

enum1a shl enum1a =non-float =
ENUM1
enum1a shr enum1a =non-float =
ENUM1
enum1a and enum1a =non-float =
ENUM1
enum1a or enum1a =non-float =
ENUM1
enum1a xor enum1a =non-float =
ENUM1
enum1a eqv enum1a =non-float =
ENUM1
enum1a imp enum1a =non-float =
ENUM1

relational ops (enum1a, enum1a):

enum1a =enum1a =integer =
INTEGER
enum1a >enum1a =integer =
INTEGER
enum1a <enum1a =integer =
INTEGER
enum1a <> enum1a =integer =
INTEGER
enum1a <= enum1a =integer =
INTEGER
enum1a >= enum1a =integer =
INTEGER
enum1a andalso enum1a =integer =
INTEGER
enum1a orelse enum1a =integer =
INTEGER

math ops (b, enum1a):

b + enum1a =max =
ENUM1
b -enum1a =max =
ENUM1
b * enum1a =max =
ENUM1
b / enum1a =float =
DOUBLE
b ^ enum1a =float =
DOUBLE
b \ enum1a =non-float =
ENUM1
b mod enum1a =non-float =
ENUM1

bitops (b, enum1a):

b shl enum1a =non-float =
ENUM1
b shr enum1a =non-float =
ENUM1
b and enum1a =non-float =
ENUM1
b or enum1a =non-float =
ENUM1
b xor enum1a =non-float =
ENUM1
b eqv enum1a =non-float =
ENUM1
b imp enum1a =non-float =
ENUM1

relational ops (b, enum1a):

b =enum1a =integer =
INTEGER
b >enum1a =integer =
INTEGER
b <enum1a =integer =
INTEGER
b <> enum1a =integer =
INTEGER
b <= enum1a =integer =
INTEGER
b >= enum1a =integer =
INTEGER
b andalso enum1a =integer =
INTEGER
b orelse enum1a =integer =
INTEGER

math ops (ub, enum1a):

ub + enum1a =max =
ENUM1
ub -enum1a =max =
ENUM1
ub * enum1a =max =
ENUM1
ub / enum1a =float =
DOUBLE
ub ^ enum1a =float =
DOUBLE
ub \ enum1a =non-float =
ENUM1
ub mod enum1a =non-float =
ENUM1

bitops (ub, enum1a):

ub shl enum1a =non-float =
ENUM1
ub shr enum1a =non-float =
ENUM1
ub and enum1a =non-float =
ENUM1
ub or enum1a =non-float =
ENUM1
ub xor enum1a =non-float =
ENUM1
ub eqv enum1a =non-float =
ENUM1
ub imp enum1a =non-float =
ENUM1

relational ops (ub, enum1a):

ub =enum1a =integer =
INTEGER
ub >enum1a =integer =
INTEGER
ub <enum1a =integer =
INTEGER
ub <> enum1a =integer =
INTEGER
ub <= enum1a =integer =
INTEGER
ub >= enum1a =integer =
INTEGER
ub andalso enum1a =integer =
INTEGER
ub orelse enum1a =integer =
INTEGER

math ops (sh, enum1a):

sh + enum1a =max =
ENUM1
sh -enum1a =max =
ENUM1
sh * enum1a =max =
ENUM1
sh / enum1a =float =
DOUBLE
sh ^ enum1a =float =
DOUBLE
sh \ enum1a =non-float =
ENUM1
sh mod enum1a =non-float =
ENUM1

bitops (sh, enum1a):

sh shl enum1a =non-float =
ENUM1
sh shr enum1a =non-float =
ENUM1
sh and enum1a =non-float =
ENUM1
sh or enum1a =non-float =
ENUM1
sh xor enum1a =non-float =
ENUM1
sh eqv enum1a =non-float =
ENUM1
sh imp enum1a =non-float =
ENUM1

relational ops (sh, enum1a):

sh =enum1a =integer =
INTEGER
sh >enum1a =integer =
INTEGER
sh <enum1a =integer =
INTEGER
sh <> enum1a =integer =
INTEGER
sh <= enum1a =integer =
INTEGER
sh >= enum1a =integer =
INTEGER
sh andalso enum1a =integer =
INTEGER
sh orelse enum1a =integer =
INTEGER

math ops (ush, enum1a):

ush + enum1a =max =
ENUM1
ush -enum1a =max =
ENUM1
ush * enum1a =max =
ENUM1
ush / enum1a =float =
DOUBLE
ush ^ enum1a =float =
DOUBLE
ush \ enum1a =non-float =
ENUM1
ush mod enum1a =non-float =
ENUM1

bitops (ush, enum1a):

ush shl enum1a =non-float =
ENUM1
ush shr enum1a =non-float =
ENUM1
ush and enum1a =non-float =
ENUM1
ush or enum1a =non-float =
ENUM1
ush xor enum1a =non-float =
ENUM1
ush eqv enum1a =non-float =
ENUM1
ush imp enum1a =non-float =
ENUM1

relational ops (ush, enum1a):

ush =enum1a =integer =
INTEGER
ush >enum1a =integer =
INTEGER
ush <enum1a =integer =
INTEGER
ush <> enum1a =integer =
INTEGER
ush <= enum1a =integer =
INTEGER
ush >= enum1a =integer =
INTEGER
ush andalso enum1a =integer =
INTEGER
ush orelse enum1a =integer =
INTEGER

math ops (i, enum1a):

i + enum1a =max =
ENUM1
i -enum1a =max =
ENUM1
i * enum1a =max =
ENUM1
i / enum1a =float =
DOUBLE
i ^ enum1a =float =
DOUBLE
i \ enum1a =non-float =
ENUM1
i mod enum1a =non-float =
ENUM1

bitops (i, enum1a):

i shl enum1a =non-float =
ENUM1
i shr enum1a =non-float =
ENUM1
i and enum1a =non-float =
ENUM1
i or enum1a =non-float =
ENUM1
i xor enum1a =non-float =
ENUM1
i eqv enum1a =non-float =
ENUM1
i imp enum1a =non-float =
ENUM1

relational ops (i, enum1a):

i =enum1a =integer =
INTEGER
i >enum1a =integer =
INTEGER
i <enum1a =integer =
INTEGER
i <> enum1a =integer =
INTEGER
i <= enum1a =integer =
INTEGER
i >= enum1a =integer =
INTEGER
i andalso enum1a =integer =
INTEGER
i orelse enum1a =integer =
INTEGER

math ops (ui, enum1a):

ui + enum1a =max =
ENUM1
ui -enum1a =max =
ENUM1
ui * enum1a =max =
ENUM1
ui / enum1a =float =
DOUBLE
ui ^ enum1a =float =
DOUBLE
ui \ enum1a =non-float =
ENUM1
ui mod enum1a =non-float =
ENUM1

bitops (ui, enum1a):

ui shl enum1a =non-float =
ENUM1
ui shr enum1a =non-float =
ENUM1
ui and enum1a =non-float =
ENUM1
ui or enum1a =non-float =
ENUM1
ui xor enum1a =non-float =
ENUM1
ui eqv enum1a =non-float =
ENUM1
ui imp enum1a =non-float =
ENUM1

relational ops (ui, enum1a):

ui =enum1a =integer =
INTEGER
ui >enum1a =integer =
INTEGER
ui <enum1a =integer =
INTEGER
ui <> enum1a =integer =
INTEGER
ui <= enum1a =integer =
INTEGER
ui >= enum1a =integer =
INTEGER
ui andalso enum1a =integer =
INTEGER
ui orelse enum1a =integer =
INTEGER

math ops (l, enum1a):

l + enum1a =max =
ENUM1
l -enum1a =max =
ENUM1
l * enum1a =max =
ENUM1
l / enum1a =float =
DOUBLE
l ^ enum1a =float =
DOUBLE
l \ enum1a =non-float =
ENUM1
l mod enum1a =non-float =
ENUM1

bitops (l, enum1a):

l shl enum1a =non-float =
ENUM1
l shr enum1a =non-float =
ENUM1
l and enum1a =non-float =
ENUM1
l or enum1a =non-float =
ENUM1
l xor enum1a =non-float =
ENUM1
l eqv enum1a =non-float =
ENUM1
l imp enum1a =non-float =
ENUM1

relational ops (l, enum1a):

l =enum1a =integer =
INTEGER
l >enum1a =integer =
INTEGER
l <enum1a =integer =
INTEGER
l <> enum1a =integer =
INTEGER
l <= enum1a =integer =
INTEGER
l >= enum1a =integer =
INTEGER
l andalso enum1a =integer =
INTEGER
l orelse enum1a =integer =
INTEGER

math ops (ul, enum1a):

ul + enum1a =max =
ENUM1
ul -enum1a =max =
ENUM1
ul * enum1a =max =
ENUM1
ul / enum1a =float =
DOUBLE
ul ^ enum1a =float =
DOUBLE
ul \ enum1a =non-float =
ENUM1
ul mod enum1a =non-float =
ENUM1

bitops (ul, enum1a):

ul shl enum1a =non-float =
ENUM1
ul shr enum1a =non-float =
ENUM1
ul and enum1a =non-float =
ENUM1
ul or enum1a =non-float =
ENUM1
ul xor enum1a =non-float =
ENUM1
ul eqv enum1a =non-float =
ENUM1
ul imp enum1a =non-float =
ENUM1

relational ops (ul, enum1a):

ul =enum1a =integer =
INTEGER
ul >enum1a =integer =
INTEGER
ul <enum1a =integer =
INTEGER
ul <> enum1a =integer =
INTEGER
ul <= enum1a =integer =
INTEGER
ul >= enum1a =integer =
INTEGER
ul andalso enum1a =integer =
INTEGER
ul orelse enum1a =integer =
INTEGER

math ops (ll, enum1a):

ll + enum1a =max =
LONGINT
ll -enum1a =max =
LONGINT
ll * enum1a =max =
LONGINT
ll / enum1a =float =
DOUBLE
ll ^ enum1a =float =
DOUBLE
ll \ enum1a =non-float =
LONGINT
ll mod enum1a =non-float =
LONGINT

bitops (ll, enum1a):

ll shl enum1a =non-float =
LONGINT
ll shr enum1a =non-float =
LONGINT
ll and enum1a =non-float =
LONGINT
ll or enum1a =non-float =
LONGINT
ll xor enum1a =non-float =
LONGINT
ll eqv enum1a =non-float =
LONGINT
ll imp enum1a =non-float =
LONGINT

relational ops (ll, enum1a):

ll =enum1a =integer =
INTEGER
ll >enum1a =integer =
INTEGER
ll <enum1a =integer =
INTEGER
ll <> enum1a =integer =
INTEGER
ll <= enum1a =integer =
INTEGER
ll >= enum1a =integer =
INTEGER
ll andalso enum1a =integer =
INTEGER
ll orelse enum1a =integer =
INTEGER

math ops (ull, enum1a):

ull + enum1a =max =
ULONGINT
ull -enum1a =max =
ULONGINT
ull * enum1a =max =
ULONGINT
ull / enum1a =float =
DOUBLE
ull ^ enum1a =float =
DOUBLE
ull \ enum1a =non-float =
ULONGINT
ull mod enum1a =non-float =
ULONGINT

bitops (ull, enum1a):

ull shl enum1a =non-float =
ULONGINT
ull shr enum1a =non-float =
ULONGINT
ull and enum1a =non-float =
ULONGINT
ull or enum1a =non-float =
ULONGINT
ull xor enum1a =non-float =
ULONGINT
ull eqv enum1a =non-float =
ULONGINT
ull imp enum1a =non-float =
ULONGINT

relational ops (ull, enum1a):

ull =enum1a =integer =
INTEGER
ull >enum1a =integer =
INTEGER
ull <enum1a =integer =
INTEGER
ull <> enum1a =integer =
INTEGER
ull <= enum1a =integer =
INTEGER
ull >= enum1a =integer =
INTEGER
ull andalso enum1a =integer =
INTEGER
ull orelse enum1a =integer =
INTEGER

math ops (enum1a, enum1a):

enum1a + enum1a =max =
ENUM1
enum1a -enum1a =max =
ENUM1
enum1a * enum1a =max =
ENUM1
enum1a / enum1a =float =
DOUBLE
enum1a ^ enum1a =float =
DOUBLE
enum1a \ enum1a =non-float =
ENUM1
enum1a mod enum1a =non-float =
ENUM1

bitops (enum1a, enum1a):

enum1a shl enum1a =non-float =
ENUM1
enum1a shr enum1a =non-float =
ENUM1
enum1a and enum1a =non-float =
ENUM1
enum1a or enum1a =non-float =
ENUM1
enum1a xor enum1a =non-float =
ENUM1
enum1a eqv enum1a =non-float =
ENUM1
enum1a imp enum1a =non-float =
ENUM1

relational ops (enum1a, enum1a):

enum1a =enum1a =integer =
INTEGER
enum1a >enum1a =integer =
INTEGER
enum1a <enum1a =integer =
INTEGER
enum1a <> enum1a =integer =
INTEGER
enum1a <= enum1a =integer =
INTEGER
enum1a >= enum1a =integer =
INTEGER
enum1a andalso enum1a =integer =
INTEGER
enum1a orelse enum1a =integer =
INTEGER

enum1 + enum2 =
ENUM1

----------------------------------------------------------------------
pointers:
----------------------------------------------------------------------


ptr ops (pi, i):

pi + i =ptr =
INTEGER PTR
i + pi =ptr =
INTEGER PTR
pi -i =ptr =
INTEGER PTR

relational (pi, i):

pi =i =integer =
INTEGER
pi >i =integer =
INTEGER
pi <i =integer =
INTEGER
pi <> i =integer =
INTEGER
pi <= i =integer =
INTEGER
pi >= i =integer =
INTEGER
pi andalso i =integer =
INTEGER
pi orelse i =integer =
INTEGER

relational (i, pi):

i =pi =integer =
INTEGER
i >pi =integer =
INTEGER
i <pi =integer =
INTEGER
i <> pi =integer =
INTEGER
i <= pi =integer =
INTEGER
i >= pi =integer =
INTEGER
i andalso pi =integer =
INTEGER
i orelse pi =integer =
INTEGER

ptr ops (pi, ui):

pi + ui =ptr =
INTEGER PTR
ui + pi =ptr =
INTEGER PTR
pi -ui =ptr =
INTEGER PTR

relational (pi, ui):

pi =ui =integer =
INTEGER
pi >ui =integer =
INTEGER
pi <ui =integer =
INTEGER
pi <> ui =integer =
INTEGER
pi <= ui =integer =
INTEGER
pi >= ui =integer =
INTEGER
pi andalso ui =integer =
INTEGER
pi orelse ui =integer =
INTEGER

relational (ui, pi):

ui =pi =integer =
INTEGER
ui >pi =integer =
INTEGER
ui <pi =integer =
INTEGER
ui <> pi =integer =
INTEGER
ui <= pi =integer =
INTEGER
ui >= pi =integer =
INTEGER
ui andalso pi =integer =
INTEGER
ui orelse pi =integer =
INTEGER

ptr ops (pi, enum1a):

pi + enum1a =ptr =
INTEGER PTR
enum1a + pi =ptr =
INTEGER PTR
pi -enum1a =ptr =
INTEGER PTR

relational (pi, enum1a):

pi =enum1a =integer =
INTEGER
pi >enum1a =integer =
INTEGER
pi <enum1a =integer =
INTEGER
pi <> enum1a =integer =
INTEGER
pi <= enum1a =integer =
INTEGER
pi >= enum1a =integer =
INTEGER
pi andalso enum1a =integer =
INTEGER
pi orelse enum1a =integer =
INTEGER

relational (enum1a, pi):

enum1a =pi =integer =
INTEGER
enum1a >pi =integer =
INTEGER
enum1a <pi =integer =
INTEGER
enum1a <> pi =integer =
INTEGER
enum1a <= pi =integer =
INTEGER
enum1a >= pi =integer =
INTEGER
enum1a andalso pi =integer =
INTEGER
enum1a orelse pi =integer =
INTEGER

ptr ops (ppi, i):

ppi + i =ptr =
INTEGER PTR PTR
i + ppi =ptr =
INTEGER PTR PTR
ppi -i =ptr =
INTEGER PTR PTR

relational (ppi, i):

ppi =i =integer =
INTEGER
ppi >i =integer =
INTEGER
ppi <i =integer =
INTEGER
ppi <> i =integer =
INTEGER
ppi <= i =integer =
INTEGER
ppi >= i =integer =
INTEGER
ppi andalso i =integer =
INTEGER
ppi orelse i =integer =
INTEGER

relational (i, ppi):

i =ppi =integer =
INTEGER
i >ppi =integer =
INTEGER
i <ppi =integer =
INTEGER
i <> ppi =integer =
INTEGER
i <= ppi =integer =
INTEGER
i >= ppi =integer =
INTEGER
i andalso ppi =integer =
INTEGER
i orelse ppi =integer =
INTEGER

ptr ops (ppi, ui):

ppi + ui =ptr =
INTEGER PTR PTR
ui + ppi =ptr =
INTEGER PTR PTR
ppi -ui =ptr =
INTEGER PTR PTR

relational (ppi, ui):

ppi =ui =integer =
INTEGER
ppi >ui =integer =
INTEGER
ppi <ui =integer =
INTEGER
ppi <> ui =integer =
INTEGER
ppi <= ui =integer =
INTEGER
ppi >= ui =integer =
INTEGER
ppi andalso ui =integer =
INTEGER
ppi orelse ui =integer =
INTEGER

relational (ui, ppi):

ui =ppi =integer =
INTEGER
ui >ppi =integer =
INTEGER
ui <ppi =integer =
INTEGER
ui <> ppi =integer =
INTEGER
ui <= ppi =integer =
INTEGER
ui >= ppi =integer =
INTEGER
ui andalso ppi =integer =
INTEGER
ui orelse ppi =integer =
INTEGER

ptr ops (ppi, enum1a):

ppi + enum1a =ptr =
INTEGER PTR PTR
enum1a + ppi =ptr =
INTEGER PTR PTR
ppi -enum1a =ptr =
INTEGER PTR PTR

relational (ppi, enum1a):

ppi =enum1a =integer =
INTEGER
ppi >enum1a =integer =
INTEGER
ppi <enum1a =integer =
INTEGER
ppi <> enum1a =integer =
INTEGER
ppi <= enum1a =integer =
INTEGER
ppi >= enum1a =integer =
INTEGER
ppi andalso enum1a =integer =
INTEGER
ppi orelse enum1a =integer =
INTEGER

relational (enum1a, ppi):

enum1a =ppi =integer =
INTEGER
enum1a >ppi =integer =
INTEGER
enum1a <ppi =integer =
INTEGER
enum1a <> ppi =integer =
INTEGER
enum1a <= ppi =integer =
INTEGER
enum1a >= ppi =integer =
INTEGER
enum1a andalso ppi =integer =
INTEGER
enum1a orelse ppi =integer =
INTEGER

ptr ops (pudt, i):

pudt + i =ptr =
UDT PTR
i + pudt =ptr =
UDT PTR
pudt -i =ptr =
UDT PTR

relational (pudt, i):

pudt =i =integer =
INTEGER
pudt >i =integer =
INTEGER
pudt <i =integer =
INTEGER
pudt <> i =integer =
INTEGER
pudt <= i =integer =
INTEGER
pudt >= i =integer =
INTEGER
pudt andalso i =integer =
INTEGER
pudt orelse i =integer =
INTEGER

relational (i, pudt):

i =pudt =integer =
INTEGER
i >pudt =integer =
INTEGER
i <pudt =integer =
INTEGER
i <> pudt =integer =
INTEGER
i <= pudt =integer =
INTEGER
i >= pudt =integer =
INTEGER
i andalso pudt =integer =
INTEGER
i orelse pudt =integer =
INTEGER

ptr ops (pudt, ui):

pudt + ui =ptr =
UDT PTR
ui + pudt =ptr =
UDT PTR
pudt -ui =ptr =
UDT PTR

relational (pudt, ui):

pudt =ui =integer =
INTEGER
pudt >ui =integer =
INTEGER
pudt <ui =integer =
INTEGER
pudt <> ui =integer =
INTEGER
pudt <= ui =integer =
INTEGER
pudt >= ui =integer =
INTEGER
pudt andalso ui =integer =
INTEGER
pudt orelse ui =integer =
INTEGER

relational (ui, pudt):

ui =pudt =integer =
INTEGER
ui >pudt =integer =
INTEGER
ui <pudt =integer =
INTEGER
ui <> pudt =integer =
INTEGER
ui <= pudt =integer =
INTEGER
ui >= pudt =integer =
INTEGER
ui andalso pudt =integer =
INTEGER
ui orelse pudt =integer =
INTEGER

ptr ops (pudt, enum1a):

pudt + enum1a =ptr =
UDT PTR
enum1a + pudt =ptr =
UDT PTR
pudt -enum1a =ptr =
UDT PTR

relational (pudt, enum1a):

pudt =enum1a =integer =
INTEGER
pudt >enum1a =integer =
INTEGER
pudt <enum1a =integer =
INTEGER
pudt <> enum1a =integer =
INTEGER
pudt <= enum1a =integer =
INTEGER
pudt >= enum1a =integer =
INTEGER
pudt andalso enum1a =integer =
INTEGER
pudt orelse enum1a =integer =
INTEGER

relational (enum1a, pudt):

enum1a =pudt =integer =
INTEGER
enum1a >pudt =integer =
INTEGER
enum1a <pudt =integer =
INTEGER
enum1a <> pudt =integer =
INTEGER
enum1a <= pudt =integer =
INTEGER
enum1a >= pudt =integer =
INTEGER
enum1a andalso pudt =integer =
INTEGER
enum1a orelse pudt =integer =
INTEGER
